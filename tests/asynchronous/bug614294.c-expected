/* asynchronous_bug614294.c generated by valac, the Vala compiler
 * generated from asynchronous_bug614294.vala, do not modify */

#include <glib-object.h>
#include <gio/gio.h>
#include <glib.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_IFOO (ifoo_get_type ())
#define IFOO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IFOO, IFoo))
#define IS_IFOO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IFOO))
#define IFOO_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IFOO, IFooIface))

typedef struct _IFoo IFoo;
typedef struct _IFooIface IFooIface;

#define TYPE_BAR (bar_get_type ())
#define BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BAR, Bar))
#define BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BAR, BarClass))
#define IS_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BAR))
#define IS_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BAR))
#define BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BAR, BarClass))

typedef struct _Bar Bar;
typedef struct _BarClass BarClass;
typedef struct _BarPrivate BarPrivate;
enum  {
	BAR_0_PROPERTY,
	BAR_NUM_PROPERTIES
};
static GParamSpec* bar_properties[BAR_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _BarFooAsyncData BarFooAsyncData;

#define TYPE_SUB_BAR (sub_bar_get_type ())
#define SUB_BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SUB_BAR, SubBar))
#define SUB_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SUB_BAR, SubBarClass))
#define IS_SUB_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SUB_BAR))
#define IS_SUB_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SUB_BAR))
#define SUB_BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SUB_BAR, SubBarClass))

typedef struct _SubBar SubBar;
typedef struct _SubBarClass SubBarClass;
typedef struct _SubBarPrivate SubBarPrivate;
enum  {
	SUB_BAR_0_PROPERTY,
	SUB_BAR_NUM_PROPERTIES
};
static GParamSpec* sub_bar_properties[SUB_BAR_NUM_PROPERTIES];
typedef struct _SubBarFooAsyncData SubBarFooAsyncData;

#define TYPE_AFOO (afoo_get_type ())
#define AFOO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_AFOO, AFoo))
#define AFOO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_AFOO, AFooClass))
#define IS_AFOO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_AFOO))
#define IS_AFOO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_AFOO))
#define AFOO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_AFOO, AFooClass))

typedef struct _AFoo AFoo;
typedef struct _AFooClass AFooClass;
typedef struct _AFooPrivate AFooPrivate;
enum  {
	AFOO_0_PROPERTY,
	AFOO_NUM_PROPERTIES
};
static GParamSpec* afoo_properties[AFOO_NUM_PROPERTIES];

#define TYPE_BAZ (baz_get_type ())
#define BAZ(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BAZ, Baz))
#define BAZ_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BAZ, BazClass))
#define IS_BAZ(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BAZ))
#define IS_BAZ_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BAZ))
#define BAZ_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BAZ, BazClass))

typedef struct _Baz Baz;
typedef struct _BazClass BazClass;
typedef struct _BazPrivate BazPrivate;
enum  {
	BAZ_0_PROPERTY,
	BAZ_NUM_PROPERTIES
};
static GParamSpec* baz_properties[BAZ_NUM_PROPERTIES];
typedef struct _BazFooAsyncData BazFooAsyncData;

#define TYPE_SUB_BAZ (sub_baz_get_type ())
#define SUB_BAZ(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SUB_BAZ, SubBaz))
#define SUB_BAZ_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SUB_BAZ, SubBazClass))
#define IS_SUB_BAZ(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SUB_BAZ))
#define IS_SUB_BAZ_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SUB_BAZ))
#define SUB_BAZ_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SUB_BAZ, SubBazClass))

typedef struct _SubBaz SubBaz;
typedef struct _SubBazClass SubBazClass;
typedef struct _SubBazPrivate SubBazPrivate;
enum  {
	SUB_BAZ_0_PROPERTY,
	SUB_BAZ_NUM_PROPERTIES
};
static GParamSpec* sub_baz_properties[SUB_BAZ_NUM_PROPERTIES];
typedef struct _SubBazFooAsyncData SubBazFooAsyncData;
typedef struct _RunData RunData;

struct _IFooIface {
	GTypeInterface parent_iface;
	void (*foo_async) (IFoo* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*foo_finish) (IFoo* self, GAsyncResult* _res_, GError** error);
	void (*foo) (IFoo* self, GError** error);
};

struct _Bar {
	GObject parent_instance;
	BarPrivate * priv;
};

struct _BarClass {
	GObjectClass parent_class;
	void (*foo_async) (Bar* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*foo_finish) (Bar* self, GAsyncResult* _res_, GError** error);
	void (*foo) (Bar* self, GError** error);
};

struct _BarFooAsyncData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	Bar* self;
};

struct _SubBar {
	Bar parent_instance;
	SubBarPrivate * priv;
};

struct _SubBarClass {
	BarClass parent_class;
};

struct _SubBarFooAsyncData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	SubBar* self;
};

struct _AFoo {
	GObject parent_instance;
	AFooPrivate * priv;
};

struct _AFooClass {
	GObjectClass parent_class;
	void (*foo_async) (AFoo* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*foo_finish) (AFoo* self, GAsyncResult* _res_, GError** error);
	void (*foo) (AFoo* self, GError** error);
};

struct _Baz {
	AFoo parent_instance;
	BazPrivate * priv;
};

struct _BazClass {
	AFooClass parent_class;
};

struct _BazFooAsyncData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	Baz* self;
};

struct _SubBaz {
	Baz parent_instance;
	SubBazPrivate * priv;
};

struct _SubBazClass {
	BazClass parent_class;
};

struct _SubBazFooAsyncData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	SubBaz* self;
};

struct _RunData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	Bar* bar;
	Bar* _tmp0_;
	Bar* _tmp1_;
	Bar* _tmp2_;
	SubBar* subbar;
	SubBar* _tmp3_;
	SubBar* _tmp4_;
	SubBar* _tmp5_;
	Baz* baz;
	Baz* _tmp6_;
	Baz* _tmp7_;
	Bar* _tmp8_;
	SubBaz* subbaz;
	SubBaz* _tmp9_;
	SubBaz* _tmp10_;
	SubBaz* _tmp11_;
	GError* _inner_error0_;
};

static gpointer bar_parent_class = NULL;
static IFooIface * bar_ifoo_parent_iface = NULL;
static gpointer sub_bar_parent_class = NULL;
static gpointer afoo_parent_class = NULL;
static gpointer baz_parent_class = NULL;
static gpointer sub_baz_parent_class = NULL;

VALA_EXTERN GType ifoo_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (IFoo, g_object_unref)
VALA_EXTERN void ifoo_foo_async (IFoo* self,
                     GAsyncReadyCallback _callback_,
                     gpointer _user_data_);
VALA_EXTERN void ifoo_foo_finish (IFoo* self,
                      GAsyncResult* _res_,
                      GError** error);
VALA_EXTERN void ifoo_foo (IFoo* self,
               GError** error);
static GType ifoo_get_type_once (void);
VALA_EXTERN GType bar_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Bar, g_object_unref)
VALA_EXTERN void bar_foo_async (Bar* self,
                    GAsyncReadyCallback _callback_,
                    gpointer _user_data_);
VALA_EXTERN void bar_foo_finish (Bar* self,
                     GAsyncResult* _res_,
                     GError** error);
VALA_EXTERN void bar_foo (Bar* self,
              GError** error);
static void bar_real_foo_async_data_free (gpointer _data);
static void bar_real_foo_async (Bar* self,
                         GAsyncReadyCallback _callback_,
                         gpointer _user_data_);
static gboolean bar_real_foo_async_co (BarFooAsyncData* _data_);
static void bar_real_foo (Bar* self,
                   GError** error);
VALA_EXTERN Bar* bar_new (void);
VALA_EXTERN Bar* bar_construct (GType object_type);
static GType bar_get_type_once (void);
VALA_EXTERN GType sub_bar_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (SubBar, g_object_unref)
static void sub_bar_real_foo_async_data_free (gpointer _data);
static void sub_bar_real_foo_async (Bar* base,
                             GAsyncReadyCallback _callback_,
                             gpointer _user_data_);
static gboolean sub_bar_real_foo_async_co (SubBarFooAsyncData* _data_);
static void sub_bar_real_foo (Bar* base,
                       GError** error);
VALA_EXTERN SubBar* sub_bar_new (void);
VALA_EXTERN SubBar* sub_bar_construct (GType object_type);
static GType sub_bar_get_type_once (void);
VALA_EXTERN GType afoo_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (AFoo, g_object_unref)
VALA_EXTERN void afoo_foo (AFoo* self,
               GError** error);
VALA_EXTERN void afoo_foo_async (AFoo* self,
                     GAsyncReadyCallback _callback_,
                     gpointer _user_data_);
VALA_EXTERN void afoo_foo_finish (AFoo* self,
                      GAsyncResult* _res_,
                      GError** error);
static void afoo_real_foo (AFoo* self,
                    GError** error);
VALA_EXTERN AFoo* afoo_construct (GType object_type);
static GType afoo_get_type_once (void);
VALA_EXTERN GType baz_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Baz, g_object_unref)
static void baz_real_foo_async_data_free (gpointer _data);
static void baz_real_foo_async (AFoo* base,
                         GAsyncReadyCallback _callback_,
                         gpointer _user_data_);
static gboolean baz_real_foo_async_co (BazFooAsyncData* _data_);
static void baz_real_foo (AFoo* base,
                   GError** error);
VALA_EXTERN Baz* baz_new (void);
VALA_EXTERN Baz* baz_construct (GType object_type);
static GType baz_get_type_once (void);
VALA_EXTERN GType sub_baz_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (SubBaz, g_object_unref)
static void sub_baz_real_foo_async_data_free (gpointer _data);
static void sub_baz_real_foo_async (AFoo* base,
                             GAsyncReadyCallback _callback_,
                             gpointer _user_data_);
static gboolean sub_baz_real_foo_async_co (SubBazFooAsyncData* _data_);
static void sub_baz_real_foo (AFoo* base,
                       GError** error);
VALA_EXTERN SubBaz* sub_baz_new (void);
VALA_EXTERN SubBaz* sub_baz_construct (GType object_type);
static GType sub_baz_get_type_once (void);
static void run_data_free (gpointer _data);
VALA_EXTERN void run (GAsyncReadyCallback _callback_,
          gpointer _user_data_);
VALA_EXTERN void run_finish (GAsyncResult* _res_);
static gboolean run_co (RunData* _data_);
static void run_ready (GObject* source_object,
                GAsyncResult* _res_,
                gpointer _user_data_);
static void _vala_main (void);

void
ifoo_foo_async (IFoo* self,
                GAsyncReadyCallback _callback_,
                gpointer _user_data_)
{
	IFooIface* _iface_;
	_iface_ = IFOO_GET_INTERFACE (self);
	if (_iface_->foo_async) {
		_iface_->foo_async (self, _callback_, _user_data_);
	}
}

void
ifoo_foo_finish (IFoo* self,
                 GAsyncResult* _res_,
                 GError** error)
{
	IFooIface* _iface_;
	_iface_ = IFOO_GET_INTERFACE (self);
	if (_iface_->foo_finish) {
		_iface_->foo_finish (self, _res_, error);
	}
}

void
ifoo_foo (IFoo* self,
          GError** error)
{
	IFooIface* _iface_;
	g_return_if_fail (IS_IFOO (self));
	_iface_ = IFOO_GET_INTERFACE (self);
	if (_iface_->foo) {
		_iface_->foo (self, error);
	}
}

static void
ifoo_default_init (IFooIface * iface,
                   gpointer iface_data)
{
}

static GType
ifoo_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (IFooIface), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ifoo_default_init, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
	GType ifoo_type_id;
	ifoo_type_id = g_type_register_static (G_TYPE_INTERFACE, "IFoo", &g_define_type_info, 0);
	g_type_interface_add_prerequisite (ifoo_type_id, G_TYPE_OBJECT);
	return ifoo_type_id;
}

GType
ifoo_get_type (void)
{
	static volatile gsize ifoo_type_id__once = 0;
	if (g_once_init_enter (&ifoo_type_id__once)) {
		GType ifoo_type_id;
		ifoo_type_id = ifoo_get_type_once ();
		g_once_init_leave (&ifoo_type_id__once, ifoo_type_id);
	}
	return ifoo_type_id__once;
}

static void
bar_real_foo_async_data_free (gpointer _data)
{
	BarFooAsyncData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (BarFooAsyncData, _data_);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static void
bar_real_foo_async (Bar* self,
                    GAsyncReadyCallback _callback_,
                    gpointer _user_data_)
{
	BarFooAsyncData* _data_;
	Bar* _tmp0_;
	_data_ = g_slice_new0 (BarFooAsyncData);
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, _callback_, _user_data_);
	g_task_set_source_tag (_data_->_async_result, bar_real_foo_async);
	g_task_set_task_data (_data_->_async_result, _data_, bar_real_foo_async_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	bar_real_foo_async_co (_data_);
}

static void
bar_real_foo_finish (Bar* self,
                     GAsyncResult* _res_,
                     GError** error)
{
	BarFooAsyncData* _data_;
	g_return_if_fail (g_task_is_valid (_res_, G_OBJECT (self)));
	g_return_if_fail (g_async_result_is_tagged (_res_, bar_real_foo_async));
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static gboolean
bar_real_foo_async_co (BarFooAsyncData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

void
bar_foo_async (Bar* self,
               GAsyncReadyCallback _callback_,
               gpointer _user_data_)
{
	BarClass* _klass_;
	_klass_ = BAR_GET_CLASS (self);
	if (_klass_->foo_async) {
		_klass_->foo_async (self, _callback_, _user_data_);
	}
}

void
bar_foo_finish (Bar* self,
                GAsyncResult* _res_,
                GError** error)
{
	BarClass* _klass_;
	_klass_ = BAR_GET_CLASS (self);
	if (_klass_->foo_finish) {
		_klass_->foo_finish (self, _res_, error);
	}
}

static void
bar_real_foo (Bar* self,
              GError** error)
{
}

void
bar_foo (Bar* self,
         GError** error)
{
	BarClass* _klass_;
	g_return_if_fail (IS_BAR (self));
	_klass_ = BAR_GET_CLASS (self);
	if (_klass_->foo) {
		_klass_->foo (self, error);
	}
}

Bar*
bar_construct (GType object_type)
{
	Bar * self = NULL;
	self = (Bar*) g_object_new (object_type, NULL);
	return self;
}

Bar*
bar_new (void)
{
	return bar_construct (TYPE_BAR);
}

static void
bar_class_init (BarClass * klass,
                gpointer klass_data)
{
	bar_parent_class = g_type_class_peek_parent (klass);
	((BarClass *) klass)->foo_async = (void (*) (Bar*, GAsyncReadyCallback, gpointer)) bar_real_foo_async;
	((BarClass *) klass)->foo_finish = (void (*) (Bar*, GAsyncResult*, GError**)) bar_real_foo_finish;
	((BarClass *) klass)->foo = (void (*) (Bar*, GError**)) bar_real_foo;
}

static void
bar_ifoo_interface_init (IFooIface * iface,
                         gpointer iface_data)
{
	bar_ifoo_parent_iface = g_type_interface_peek_parent (iface);
	iface->foo_async = (void (*) (IFoo*, GAsyncReadyCallback, gpointer)) bar_foo_async;
	iface->foo_finish = (void (*) (IFoo*, GAsyncResult*, GError**)) bar_foo_finish;
	iface->foo = (void (*) (IFoo*, GError**)) bar_foo;
}

static void
bar_instance_init (Bar * self,
                   gpointer klass)
{
}

static GType
bar_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (BarClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) bar_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Bar), 0, (GInstanceInitFunc) bar_instance_init, NULL };
	static const GInterfaceInfo ifoo_info = { (GInterfaceInitFunc) bar_ifoo_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType bar_type_id;
	bar_type_id = g_type_register_static (G_TYPE_OBJECT, "Bar", &g_define_type_info, 0);
	g_type_add_interface_static (bar_type_id, TYPE_IFOO, &ifoo_info);
	return bar_type_id;
}

GType
bar_get_type (void)
{
	static volatile gsize bar_type_id__once = 0;
	if (g_once_init_enter (&bar_type_id__once)) {
		GType bar_type_id;
		bar_type_id = bar_get_type_once ();
		g_once_init_leave (&bar_type_id__once, bar_type_id);
	}
	return bar_type_id__once;
}

static void
sub_bar_real_foo_async_data_free (gpointer _data)
{
	SubBarFooAsyncData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (SubBarFooAsyncData, _data_);
}

static void
sub_bar_real_foo_async (Bar* base,
                        GAsyncReadyCallback _callback_,
                        gpointer _user_data_)
{
	SubBar * self;
	SubBarFooAsyncData* _data_;
	SubBar* _tmp0_;
	self = G_TYPE_CHECK_INSTANCE_CAST (base, TYPE_SUB_BAR, SubBar);
	_data_ = g_slice_new0 (SubBarFooAsyncData);
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, _callback_, _user_data_);
	g_task_set_source_tag (_data_->_async_result, sub_bar_real_foo_async);
	g_task_set_task_data (_data_->_async_result, _data_, sub_bar_real_foo_async_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	sub_bar_real_foo_async_co (_data_);
}

static void
sub_bar_foo_finish (Bar* base,
                    GAsyncResult* _res_,
                    GError** error)
{
	SubBarFooAsyncData* _data_;
	g_return_if_fail (g_task_is_valid (_res_, G_OBJECT (base)));
	g_return_if_fail (g_async_result_is_tagged (_res_, sub_bar_real_foo_async));
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static gboolean
sub_bar_real_foo_async_co (SubBarFooAsyncData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static void
sub_bar_real_foo (Bar* base,
                  GError** error)
{
	SubBar * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (base, TYPE_SUB_BAR, SubBar);
}

SubBar*
sub_bar_construct (GType object_type)
{
	SubBar * self = NULL;
	self = (SubBar*) bar_construct (object_type);
	return self;
}

SubBar*
sub_bar_new (void)
{
	return sub_bar_construct (TYPE_SUB_BAR);
}

static void
sub_bar_class_init (SubBarClass * klass,
                    gpointer klass_data)
{
	sub_bar_parent_class = g_type_class_peek_parent (klass);
	((BarClass *) klass)->foo_async = (void (*) (Bar*, GAsyncReadyCallback, gpointer)) sub_bar_real_foo_async;
	((BarClass *) klass)->foo_finish = (void (*) (Bar*, GAsyncResult*, GError**)) sub_bar_foo_finish;
	((BarClass *) klass)->foo = (void (*) (Bar*, GError**)) sub_bar_real_foo;
}

static void
sub_bar_instance_init (SubBar * self,
                       gpointer klass)
{
}

static GType
sub_bar_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (SubBarClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) sub_bar_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SubBar), 0, (GInstanceInitFunc) sub_bar_instance_init, NULL };
	GType sub_bar_type_id;
	sub_bar_type_id = g_type_register_static (TYPE_BAR, "SubBar", &g_define_type_info, 0);
	return sub_bar_type_id;
}

GType
sub_bar_get_type (void)
{
	static volatile gsize sub_bar_type_id__once = 0;
	if (g_once_init_enter (&sub_bar_type_id__once)) {
		GType sub_bar_type_id;
		sub_bar_type_id = sub_bar_get_type_once ();
		g_once_init_leave (&sub_bar_type_id__once, sub_bar_type_id);
	}
	return sub_bar_type_id__once;
}

void
afoo_foo_async (AFoo* self,
                GAsyncReadyCallback _callback_,
                gpointer _user_data_)
{
	AFooClass* _klass_;
	_klass_ = AFOO_GET_CLASS (self);
	if (_klass_->foo_async) {
		_klass_->foo_async (self, _callback_, _user_data_);
	}
}

void
afoo_foo_finish (AFoo* self,
                 GAsyncResult* _res_,
                 GError** error)
{
	AFooClass* _klass_;
	_klass_ = AFOO_GET_CLASS (self);
	if (_klass_->foo_finish) {
		_klass_->foo_finish (self, _res_, error);
	}
}

static void
afoo_real_foo (AFoo* self,
               GError** error)
{
	g_critical ("Type `%s' does not implement abstract method `afoo_foo'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}

void
afoo_foo (AFoo* self,
          GError** error)
{
	AFooClass* _klass_;
	g_return_if_fail (IS_AFOO (self));
	_klass_ = AFOO_GET_CLASS (self);
	if (_klass_->foo) {
		_klass_->foo (self, error);
	}
}

AFoo*
afoo_construct (GType object_type)
{
	AFoo * self = NULL;
	self = (AFoo*) g_object_new (object_type, NULL);
	return self;
}

static void
afoo_class_init (AFooClass * klass,
                 gpointer klass_data)
{
	afoo_parent_class = g_type_class_peek_parent (klass);
	((AFooClass *) klass)->foo = (void (*) (AFoo*, GError**)) afoo_real_foo;
}

static void
afoo_instance_init (AFoo * self,
                    gpointer klass)
{
}

static GType
afoo_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (AFooClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) afoo_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AFoo), 0, (GInstanceInitFunc) afoo_instance_init, NULL };
	GType afoo_type_id;
	afoo_type_id = g_type_register_static (G_TYPE_OBJECT, "AFoo", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
	return afoo_type_id;
}

GType
afoo_get_type (void)
{
	static volatile gsize afoo_type_id__once = 0;
	if (g_once_init_enter (&afoo_type_id__once)) {
		GType afoo_type_id;
		afoo_type_id = afoo_get_type_once ();
		g_once_init_leave (&afoo_type_id__once, afoo_type_id);
	}
	return afoo_type_id__once;
}

static void
baz_real_foo_async_data_free (gpointer _data)
{
	BazFooAsyncData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (BazFooAsyncData, _data_);
}

static void
baz_real_foo_async (AFoo* base,
                    GAsyncReadyCallback _callback_,
                    gpointer _user_data_)
{
	Baz * self;
	BazFooAsyncData* _data_;
	Baz* _tmp0_;
	self = G_TYPE_CHECK_INSTANCE_CAST (base, TYPE_BAZ, Baz);
	_data_ = g_slice_new0 (BazFooAsyncData);
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, _callback_, _user_data_);
	g_task_set_source_tag (_data_->_async_result, baz_real_foo_async);
	g_task_set_task_data (_data_->_async_result, _data_, baz_real_foo_async_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	baz_real_foo_async_co (_data_);
}

static void
baz_foo_finish (AFoo* base,
                GAsyncResult* _res_,
                GError** error)
{
	BazFooAsyncData* _data_;
	g_return_if_fail (g_task_is_valid (_res_, G_OBJECT (base)));
	g_return_if_fail (g_async_result_is_tagged (_res_, baz_real_foo_async));
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static gboolean
baz_real_foo_async_co (BazFooAsyncData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static void
baz_real_foo (AFoo* base,
              GError** error)
{
	Baz * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (base, TYPE_BAZ, Baz);
}

Baz*
baz_construct (GType object_type)
{
	Baz * self = NULL;
	self = (Baz*) afoo_construct (object_type);
	return self;
}

Baz*
baz_new (void)
{
	return baz_construct (TYPE_BAZ);
}

static void
baz_class_init (BazClass * klass,
                gpointer klass_data)
{
	baz_parent_class = g_type_class_peek_parent (klass);
	((AFooClass *) klass)->foo_async = (void (*) (AFoo*, GAsyncReadyCallback, gpointer)) baz_real_foo_async;
	((AFooClass *) klass)->foo_finish = (void (*) (AFoo*, GAsyncResult*, GError**)) baz_foo_finish;
	((AFooClass *) klass)->foo = (void (*) (AFoo*, GError**)) baz_real_foo;
}

static void
baz_instance_init (Baz * self,
                   gpointer klass)
{
}

static GType
baz_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (BazClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) baz_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Baz), 0, (GInstanceInitFunc) baz_instance_init, NULL };
	GType baz_type_id;
	baz_type_id = g_type_register_static (TYPE_AFOO, "Baz", &g_define_type_info, 0);
	return baz_type_id;
}

GType
baz_get_type (void)
{
	static volatile gsize baz_type_id__once = 0;
	if (g_once_init_enter (&baz_type_id__once)) {
		GType baz_type_id;
		baz_type_id = baz_get_type_once ();
		g_once_init_leave (&baz_type_id__once, baz_type_id);
	}
	return baz_type_id__once;
}

static void
sub_baz_real_foo_async_data_free (gpointer _data)
{
	SubBazFooAsyncData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (SubBazFooAsyncData, _data_);
}

static void
sub_baz_real_foo_async (AFoo* base,
                        GAsyncReadyCallback _callback_,
                        gpointer _user_data_)
{
	SubBaz * self;
	SubBazFooAsyncData* _data_;
	SubBaz* _tmp0_;
	self = G_TYPE_CHECK_INSTANCE_CAST (base, TYPE_SUB_BAZ, SubBaz);
	_data_ = g_slice_new0 (SubBazFooAsyncData);
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, _callback_, _user_data_);
	g_task_set_source_tag (_data_->_async_result, sub_baz_real_foo_async);
	g_task_set_task_data (_data_->_async_result, _data_, sub_baz_real_foo_async_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	sub_baz_real_foo_async_co (_data_);
}

static void
sub_baz_foo_finish (AFoo* base,
                    GAsyncResult* _res_,
                    GError** error)
{
	SubBazFooAsyncData* _data_;
	g_return_if_fail (g_task_is_valid (_res_, G_OBJECT (base)));
	g_return_if_fail (g_async_result_is_tagged (_res_, sub_baz_real_foo_async));
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static gboolean
sub_baz_real_foo_async_co (SubBazFooAsyncData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static void
sub_baz_real_foo (AFoo* base,
                  GError** error)
{
	SubBaz * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (base, TYPE_SUB_BAZ, SubBaz);
}

SubBaz*
sub_baz_construct (GType object_type)
{
	SubBaz * self = NULL;
	self = (SubBaz*) baz_construct (object_type);
	return self;
}

SubBaz*
sub_baz_new (void)
{
	return sub_baz_construct (TYPE_SUB_BAZ);
}

static void
sub_baz_class_init (SubBazClass * klass,
                    gpointer klass_data)
{
	sub_baz_parent_class = g_type_class_peek_parent (klass);
	((AFooClass *) klass)->foo_async = (void (*) (AFoo*, GAsyncReadyCallback, gpointer)) sub_baz_real_foo_async;
	((AFooClass *) klass)->foo_finish = (void (*) (AFoo*, GAsyncResult*, GError**)) sub_baz_foo_finish;
	((AFooClass *) klass)->foo = (void (*) (AFoo*, GError**)) sub_baz_real_foo;
}

static void
sub_baz_instance_init (SubBaz * self,
                       gpointer klass)
{
}

static GType
sub_baz_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (SubBazClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) sub_baz_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SubBaz), 0, (GInstanceInitFunc) sub_baz_instance_init, NULL };
	GType sub_baz_type_id;
	sub_baz_type_id = g_type_register_static (TYPE_BAZ, "SubBaz", &g_define_type_info, 0);
	return sub_baz_type_id;
}

GType
sub_baz_get_type (void)
{
	static volatile gsize sub_baz_type_id__once = 0;
	if (g_once_init_enter (&sub_baz_type_id__once)) {
		GType sub_baz_type_id;
		sub_baz_type_id = sub_baz_get_type_once ();
		g_once_init_leave (&sub_baz_type_id__once, sub_baz_type_id);
	}
	return sub_baz_type_id__once;
}

static void
run_data_free (gpointer _data)
{
	RunData* _data_;
	_data_ = _data;
	g_slice_free (RunData, _data_);
}

void
run (GAsyncReadyCallback _callback_,
     gpointer _user_data_)
{
	RunData* _data_;
	_data_ = g_slice_new0 (RunData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_source_tag (_data_->_async_result, run);
	g_task_set_task_data (_data_->_async_result, _data_, run_data_free);
	run_co (_data_);
}

void
run_finish (GAsyncResult* _res_)
{
	RunData* _data_;
	g_return_if_fail (G_IS_TASK (_res_));
	g_return_if_fail (g_async_result_is_tagged (_res_, run));
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static void
run_ready (GObject* source_object,
           GAsyncResult* _res_,
           gpointer _user_data_)
{
	RunData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	run_co (_data_);
}

static gboolean
run_co (RunData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		case 3:
		goto _state_3;
		case 4:
		goto _state_4;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = bar_new ();
	_data_->bar = _data_->_tmp0_;
	_data_->_tmp1_ = _data_->bar;
	bar_foo (_data_->_tmp1_, NULL);
	_data_->_tmp2_ = _data_->bar;
	_data_->_state_ = 1;
	bar_foo_async (_data_->_tmp2_, run_ready, _data_);
	return FALSE;
	_state_1:
	bar_foo_finish (_data_->_tmp2_, _data_->_res_, NULL);
	_data_->_tmp3_ = sub_bar_new ();
	_data_->subbar = _data_->_tmp3_;
	_data_->_tmp4_ = _data_->subbar;
	bar_foo (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp4_, TYPE_BAR, Bar), NULL);
	_data_->_tmp5_ = _data_->subbar;
	_data_->_state_ = 2;
	bar_foo_async (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp5_, TYPE_BAR, Bar), run_ready, _data_);
	return FALSE;
	_state_2:
	bar_foo_finish (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp5_, TYPE_BAR, Bar), _data_->_res_, NULL);
	_data_->_tmp6_ = baz_new ();
	_data_->baz = _data_->_tmp6_;
	_data_->_tmp7_ = _data_->baz;
	afoo_foo (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp7_, TYPE_AFOO, AFoo), &_data_->_inner_error0_);
	if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
		_g_object_unref0 (_data_->baz);
		_g_object_unref0 (_data_->subbar);
		_g_object_unref0 (_data_->bar);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
		g_clear_error (&_data_->_inner_error0_);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp8_ = _data_->bar;
	_data_->_state_ = 3;
	bar_foo_async (_data_->_tmp8_, run_ready, _data_);
	return FALSE;
	_state_3:
	bar_foo_finish (_data_->_tmp8_, _data_->_res_, NULL);
	_data_->_tmp9_ = sub_baz_new ();
	_data_->subbaz = _data_->_tmp9_;
	_data_->_tmp10_ = _data_->subbaz;
	afoo_foo (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp10_, TYPE_AFOO, AFoo), &_data_->_inner_error0_);
	if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
		_g_object_unref0 (_data_->subbaz);
		_g_object_unref0 (_data_->baz);
		_g_object_unref0 (_data_->subbar);
		_g_object_unref0 (_data_->bar);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
		g_clear_error (&_data_->_inner_error0_);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp11_ = _data_->subbaz;
	_data_->_state_ = 4;
	afoo_foo_async (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp11_, TYPE_AFOO, AFoo), run_ready, _data_);
	return FALSE;
	_state_4:
	afoo_foo_finish (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp11_, TYPE_AFOO, AFoo), _data_->_res_, &_data_->_inner_error0_);
	if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
		_g_object_unref0 (_data_->subbaz);
		_g_object_unref0 (_data_->baz);
		_g_object_unref0 (_data_->subbar);
		_g_object_unref0 (_data_->bar);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
		g_clear_error (&_data_->_inner_error0_);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_g_object_unref0 (_data_->subbaz);
	_g_object_unref0 (_data_->baz);
	_g_object_unref0 (_data_->subbar);
	_g_object_unref0 (_data_->bar);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static void
_vala_main (void)
{
	run (NULL, NULL);
}

int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}

