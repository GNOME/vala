/* asynchronous_bug646945.c generated by valac, the Vala compiler
 * generated from asynchronous_bug646945.vala, do not modify */

#include <glib-object.h>
#include <gio/gio.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_FOO (foo_get_type ())
#define FOO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FOO, Foo))
#define FOO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FOO, FooClass))
#define IS_FOO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FOO))
#define IS_FOO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FOO))
#define FOO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FOO, FooClass))

typedef struct _Foo Foo;
typedef struct _FooClass FooClass;
typedef struct _FooPrivate FooPrivate;
enum  {
	FOO_0_PROPERTY,
	FOO_NUM_PROPERTIES
};
static GParamSpec* foo_properties[FOO_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _FooMethod1Data FooMethod1Data;

#define TYPE_BAR (bar_get_type ())
#define BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BAR, Bar))
#define IS_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BAR))
#define BAR_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_BAR, BarIface))

typedef struct _Bar Bar;
typedef struct _BarIface BarIface;
typedef struct _BarMethod2Data BarMethod2Data;

#define TYPE_BAZ (baz_get_type ())
#define BAZ(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BAZ, Baz))
#define BAZ_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BAZ, BazClass))
#define IS_BAZ(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BAZ))
#define IS_BAZ_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BAZ))
#define BAZ_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BAZ, BazClass))

typedef struct _Baz Baz;
typedef struct _BazClass BazClass;
typedef struct _BazPrivate BazPrivate;
enum  {
	BAZ_0_PROPERTY,
	BAZ_NUM_PROPERTIES
};
static GParamSpec* baz_properties[BAZ_NUM_PROPERTIES];
typedef struct _BazMethod1Data BazMethod1Data;
typedef struct _BazMethod2Data BazMethod2Data;

struct _Foo {
	GObject parent_instance;
	FooPrivate * priv;
};

struct _FooClass {
	GObjectClass parent_class;
	void (*method1) (Foo* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*method1_finish) (Foo* self, GAsyncResult* _res_);
};

struct _FooMethod1Data {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	Foo* self;
};

struct _BarIface {
	GTypeInterface parent_iface;
	void (*method2) (Bar* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*method2_finish) (Bar* self, GAsyncResult* _res_);
};

struct _BarMethod2Data {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	Bar* self;
};

struct _Baz {
	Foo parent_instance;
	BazPrivate * priv;
};

struct _BazClass {
	FooClass parent_class;
};

struct _BazMethod1Data {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	Baz* self;
};

struct _BazMethod2Data {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	Baz* self;
};

static gpointer foo_parent_class = NULL;
static gpointer baz_parent_class = NULL;
static BarIface * baz_bar_parent_iface = NULL;

VALA_EXTERN GType foo_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Foo, g_object_unref)
VALA_EXTERN void foo_method1 (Foo* self,
                  GAsyncReadyCallback _callback_,
                  gpointer _user_data_);
VALA_EXTERN void foo_method1_finish (Foo* self,
                         GAsyncResult* _res_);
static void foo_real_method1_data_free (gpointer _data);
static void foo_real_method1 (Foo* self,
                       GAsyncReadyCallback _callback_,
                       gpointer _user_data_);
static gboolean foo_real_method1_co (FooMethod1Data* _data_);
VALA_EXTERN Foo* foo_new (void);
VALA_EXTERN Foo* foo_construct (GType object_type);
static GType foo_get_type_once (void);
VALA_EXTERN GType bar_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Bar, g_object_unref)
static void bar_real_method2_data_free (gpointer _data);
static void bar_real_method2 (Bar* self,
                       GAsyncReadyCallback _callback_,
                       gpointer _user_data_);
VALA_EXTERN void bar_method2 (Bar* self,
                  GAsyncReadyCallback _callback_,
                  gpointer _user_data_);
VALA_EXTERN void bar_method2_finish (Bar* self,
                         GAsyncResult* _res_);
static gboolean bar_real_method2_co (BarMethod2Data* _data_);
static GType bar_get_type_once (void);
VALA_EXTERN GType baz_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Baz, g_object_unref)
static void baz_real_method1_data_free (gpointer _data);
static void baz_real_method1 (Foo* base,
                       GAsyncReadyCallback _callback_,
                       gpointer _user_data_);
static gboolean baz_real_method1_co (BazMethod1Data* _data_);
static void baz_real_method2_data_free (gpointer _data);
static void baz_real_method2 (Bar* base,
                       GAsyncReadyCallback _callback_,
                       gpointer _user_data_);
static gboolean baz_real_method2_co (BazMethod2Data* _data_);
VALA_EXTERN Baz* baz_new (void);
VALA_EXTERN Baz* baz_construct (GType object_type);
static GType baz_get_type_once (void);
static void _vala_main (void);

static void
foo_real_method1_data_free (gpointer _data)
{
	FooMethod1Data* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (FooMethod1Data, _data_);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static void
foo_real_method1 (Foo* self,
                  GAsyncReadyCallback _callback_,
                  gpointer _user_data_)
{
	FooMethod1Data* _data_;
	Foo* _tmp0_;
	_data_ = g_slice_new0 (FooMethod1Data);
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, _callback_, _user_data_);
	g_task_set_source_tag (_data_->_async_result, foo_real_method1);
	g_task_set_task_data (_data_->_async_result, _data_, foo_real_method1_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	foo_real_method1_co (_data_);
}

static void
foo_real_method1_finish (Foo* self,
                         GAsyncResult* _res_)
{
	FooMethod1Data* _data_;
	g_return_if_fail (g_task_is_valid (_res_, G_OBJECT (self)));
	g_return_if_fail (g_async_result_is_tagged (_res_, foo_real_method1));
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static gboolean
foo_real_method1_co (FooMethod1Data* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

void
foo_method1 (Foo* self,
             GAsyncReadyCallback _callback_,
             gpointer _user_data_)
{
	FooClass* _klass_;
	_klass_ = FOO_GET_CLASS (self);
	if (_klass_->method1) {
		_klass_->method1 (self, _callback_, _user_data_);
	}
}

void
foo_method1_finish (Foo* self,
                    GAsyncResult* _res_)
{
	FooClass* _klass_;
	_klass_ = FOO_GET_CLASS (self);
	if (_klass_->method1_finish) {
		_klass_->method1_finish (self, _res_);
	}
}

Foo*
foo_construct (GType object_type)
{
	Foo * self = NULL;
	self = (Foo*) g_object_new (object_type, NULL);
	return self;
}

Foo*
foo_new (void)
{
	return foo_construct (TYPE_FOO);
}

static void
foo_class_init (FooClass * klass,
                gpointer klass_data)
{
	foo_parent_class = g_type_class_peek_parent (klass);
	((FooClass *) klass)->method1 = (void (*) (Foo*, GAsyncReadyCallback, gpointer)) foo_real_method1;
	((FooClass *) klass)->method1_finish = (void (*) (Foo*, GAsyncResult*)) foo_real_method1_finish;
}

static void
foo_instance_init (Foo * self,
                   gpointer klass)
{
}

static GType
foo_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FooClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) foo_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Foo), 0, (GInstanceInitFunc) foo_instance_init, NULL };
	GType foo_type_id;
	foo_type_id = g_type_register_static (G_TYPE_OBJECT, "Foo", &g_define_type_info, 0);
	return foo_type_id;
}

GType
foo_get_type (void)
{
	static volatile gsize foo_type_id__once = 0;
	if (g_once_init_enter (&foo_type_id__once)) {
		GType foo_type_id;
		foo_type_id = foo_get_type_once ();
		g_once_init_leave (&foo_type_id__once, foo_type_id);
	}
	return foo_type_id__once;
}

static void
bar_real_method2_data_free (gpointer _data)
{
	BarMethod2Data* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (BarMethod2Data, _data_);
}

static void
bar_real_method2 (Bar* self,
                  GAsyncReadyCallback _callback_,
                  gpointer _user_data_)
{
	BarMethod2Data* _data_;
	Bar* _tmp0_;
	_data_ = g_slice_new0 (BarMethod2Data);
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, _callback_, _user_data_);
	g_task_set_source_tag (_data_->_async_result, bar_real_method2);
	g_task_set_task_data (_data_->_async_result, _data_, bar_real_method2_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	bar_real_method2_co (_data_);
}

static void
bar_real_method2_finish (Bar* self,
                         GAsyncResult* _res_)
{
	BarMethod2Data* _data_;
	g_return_if_fail (g_task_is_valid (_res_, G_OBJECT (self)));
	g_return_if_fail (g_async_result_is_tagged (_res_, bar_real_method2));
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static gboolean
bar_real_method2_co (BarMethod2Data* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

void
bar_method2 (Bar* self,
             GAsyncReadyCallback _callback_,
             gpointer _user_data_)
{
	BarIface* _iface_;
	_iface_ = BAR_GET_INTERFACE (self);
	if (_iface_->method2) {
		_iface_->method2 (self, _callback_, _user_data_);
	}
}

void
bar_method2_finish (Bar* self,
                    GAsyncResult* _res_)
{
	BarIface* _iface_;
	_iface_ = BAR_GET_INTERFACE (self);
	if (_iface_->method2_finish) {
		_iface_->method2_finish (self, _res_);
	}
}

static void
bar_default_init (BarIface * iface,
                  gpointer iface_data)
{
	iface->method2 = bar_real_method2;
	iface->method2_finish = bar_real_method2_finish;
}

static GType
bar_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (BarIface), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) bar_default_init, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
	GType bar_type_id;
	bar_type_id = g_type_register_static (G_TYPE_INTERFACE, "Bar", &g_define_type_info, 0);
	g_type_interface_add_prerequisite (bar_type_id, G_TYPE_OBJECT);
	return bar_type_id;
}

GType
bar_get_type (void)
{
	static volatile gsize bar_type_id__once = 0;
	if (g_once_init_enter (&bar_type_id__once)) {
		GType bar_type_id;
		bar_type_id = bar_get_type_once ();
		g_once_init_leave (&bar_type_id__once, bar_type_id);
	}
	return bar_type_id__once;
}

static void
baz_real_method1_data_free (gpointer _data)
{
	BazMethod1Data* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (BazMethod1Data, _data_);
}

static void
baz_real_method1 (Foo* base,
                  GAsyncReadyCallback _callback_,
                  gpointer _user_data_)
{
	Baz * self;
	BazMethod1Data* _data_;
	Baz* _tmp0_;
	self = G_TYPE_CHECK_INSTANCE_CAST (base, TYPE_BAZ, Baz);
	_data_ = g_slice_new0 (BazMethod1Data);
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, _callback_, _user_data_);
	g_task_set_source_tag (_data_->_async_result, baz_real_method1);
	g_task_set_task_data (_data_->_async_result, _data_, baz_real_method1_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	baz_real_method1_co (_data_);
}

static void
baz_method1_finish (Foo* base,
                    GAsyncResult* _res_)
{
	BazMethod1Data* _data_;
	g_return_if_fail (g_task_is_valid (_res_, G_OBJECT (base)));
	g_return_if_fail (g_async_result_is_tagged (_res_, baz_real_method1));
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static gboolean
baz_real_method1_co (BazMethod1Data* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	baz_real_method1_co (_data_);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static void
baz_real_method2_data_free (gpointer _data)
{
	BazMethod2Data* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (BazMethod2Data, _data_);
}

static void
baz_real_method2 (Bar* base,
                  GAsyncReadyCallback _callback_,
                  gpointer _user_data_)
{
	Baz * self;
	BazMethod2Data* _data_;
	Baz* _tmp0_;
	self = G_TYPE_CHECK_INSTANCE_CAST (base, TYPE_BAZ, Baz);
	_data_ = g_slice_new0 (BazMethod2Data);
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, _callback_, _user_data_);
	g_task_set_source_tag (_data_->_async_result, baz_real_method2);
	g_task_set_task_data (_data_->_async_result, _data_, baz_real_method2_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	baz_real_method2_co (_data_);
}

static void
baz_method2_finish (Bar* base,
                    GAsyncResult* _res_)
{
	BazMethod2Data* _data_;
	g_return_if_fail (g_task_is_valid (_res_, G_OBJECT (base)));
	g_return_if_fail (g_async_result_is_tagged (_res_, baz_real_method2));
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static gboolean
baz_real_method2_co (BazMethod2Data* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	baz_real_method2_co (_data_);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

Baz*
baz_construct (GType object_type)
{
	Baz * self = NULL;
	self = (Baz*) foo_construct (object_type);
	return self;
}

Baz*
baz_new (void)
{
	return baz_construct (TYPE_BAZ);
}

static void
baz_class_init (BazClass * klass,
                gpointer klass_data)
{
	baz_parent_class = g_type_class_peek_parent (klass);
	((FooClass *) klass)->method1 = (void (*) (Foo*, GAsyncReadyCallback, gpointer)) baz_real_method1;
	((FooClass *) klass)->method1_finish = (void (*) (Foo*, GAsyncResult*)) baz_method1_finish;
}

static void
baz_bar_interface_init (BarIface * iface,
                        gpointer iface_data)
{
	baz_bar_parent_iface = g_type_interface_peek_parent (iface);
	iface->method2 = (void (*) (Bar*, GAsyncReadyCallback, gpointer)) baz_real_method2;
	iface->method2_finish = (void (*) (Bar*, GAsyncResult*)) baz_method2_finish;
}

static void
baz_instance_init (Baz * self,
                   gpointer klass)
{
}

static GType
baz_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (BazClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) baz_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Baz), 0, (GInstanceInitFunc) baz_instance_init, NULL };
	static const GInterfaceInfo bar_info = { (GInterfaceInitFunc) baz_bar_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType baz_type_id;
	baz_type_id = g_type_register_static (TYPE_FOO, "Baz", &g_define_type_info, 0);
	g_type_add_interface_static (baz_type_id, TYPE_BAR, &bar_info);
	return baz_type_id;
}

GType
baz_get_type (void)
{
	static volatile gsize baz_type_id__once = 0;
	if (g_once_init_enter (&baz_type_id__once)) {
		GType baz_type_id;
		baz_type_id = baz_get_type_once ();
		g_once_init_leave (&baz_type_id__once, baz_type_id);
	}
	return baz_type_id__once;
}

static void
_vala_main (void)
{
}

int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}

