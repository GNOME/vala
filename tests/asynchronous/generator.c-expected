/* asynchronous_generator.c generated by valac, the Vala compiler
 * generated from asynchronous_generator.vala, do not modify */

/* This is based on Luca Bruno's Generator. It illustrates using async methods*/
/* to emulate a generator style of iterator coding. Note that this runs fine*/
/* without a main loop.*/

#include <glib-object.h>
#include <gio/gio.h>
#include <glib.h>
#include <gobject/gvaluecollector.h>
#include <stdlib.h>
#include <string.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_GENERATOR (generator_get_type ())
#define GENERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GENERATOR, Generator))
#define GENERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GENERATOR, GeneratorClass))
#define IS_GENERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GENERATOR))
#define IS_GENERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GENERATOR))
#define GENERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GENERATOR, GeneratorClass))

typedef struct _Generator Generator;
typedef struct _GeneratorClass GeneratorClass;
typedef struct _GeneratorPrivate GeneratorPrivate;
#define _generator_unref0(var) ((var == NULL) ? NULL : (var = (generator_unref (var), NULL)))
typedef struct _GeneratorHelperData GeneratorHelperData;
typedef struct _GeneratorFeedData GeneratorFeedData;
typedef struct _ParamSpecGenerator ParamSpecGenerator;

#define TYPE_INT_GENERATOR (int_generator_get_type ())
#define INT_GENERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_INT_GENERATOR, IntGenerator))
#define INT_GENERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_INT_GENERATOR, IntGeneratorClass))
#define IS_INT_GENERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_INT_GENERATOR))
#define IS_INT_GENERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_INT_GENERATOR))
#define INT_GENERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_INT_GENERATOR, IntGeneratorClass))

typedef struct _IntGenerator IntGenerator;
typedef struct _IntGeneratorClass IntGeneratorClass;
typedef struct _IntGeneratorPrivate IntGeneratorPrivate;
typedef struct _IntGeneratorGenerateData IntGeneratorGenerateData;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _Generator {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GeneratorPrivate * priv;
};

struct _GeneratorClass {
	GTypeClass parent_class;
	void (*finalize) (Generator *self);
	void (*generate) (Generator* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*generate_finish) (Generator* self, GAsyncResult* _res_);
};

struct _GeneratorPrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
	gboolean consumed;
	gconstpointer value;
	GSourceFunc callback;
	gpointer callback_target;
	GDestroyNotify callback_target_destroy_notify;
};

struct _GeneratorHelperData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	Generator* self;
};

struct _GeneratorFeedData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	Generator* self;
	gpointer value;
};

struct _ParamSpecGenerator {
	GParamSpec parent_instance;
};

struct _IntGenerator {
	Generator parent_instance;
	IntGeneratorPrivate * priv;
};

struct _IntGeneratorClass {
	GeneratorClass parent_class;
};

struct _IntGeneratorGenerateData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	IntGenerator* self;
	gint i;
	gboolean _tmp0_;
	gint _tmp1_;
};

static gint Generator_private_offset;
static gpointer generator_parent_class = NULL;
static gpointer int_generator_parent_class = NULL;

VALA_EXTERN gpointer generator_ref (gpointer instance);
VALA_EXTERN void generator_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_generator (const gchar* name,
                                  const gchar* nick,
                                  const gchar* blurb,
                                  GType object_type,
                                  GParamFlags flags);
VALA_EXTERN void value_set_generator (GValue* value,
                          gpointer v_object);
VALA_EXTERN void value_take_generator (GValue* value,
                           gpointer v_object);
VALA_EXTERN gpointer value_get_generator (const GValue* value);
VALA_EXTERN GType generator_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Generator, generator_unref)
VALA_EXTERN Generator* generator_construct (GType object_type,
                                GType g_type,
                                GBoxedCopyFunc g_dup_func,
                                GDestroyNotify g_destroy_func);
static void generator_helper (Generator* self,
                       GAsyncReadyCallback _callback_,
                       gpointer _user_data_);
static void generator_helper_finish (Generator* self,
                              GAsyncResult* _res_);
static void generator_helper_data_free (gpointer _data);
static gboolean generator_helper_co (GeneratorHelperData* _data_);
VALA_EXTERN void generator_generate (Generator* self,
                         GAsyncReadyCallback _callback_,
                         gpointer _user_data_);
VALA_EXTERN void generator_generate_finish (Generator* self,
                                GAsyncResult* _res_);
static void generator_helper_ready (GObject* source_object,
                             GAsyncResult* _res_,
                             gpointer _user_data_);
static void generator_feed_data_free (gpointer _data);
VALA_EXTERN void generator_feed (Generator* self,
                     gconstpointer value,
                     GAsyncReadyCallback _callback_,
                     gpointer _user_data_);
VALA_EXTERN void generator_feed_finish (Generator* self,
                            GAsyncResult* _res_);
static gboolean generator_feed_co (GeneratorFeedData* _data_);
static gboolean _generator_feed_co_gsource_func (gpointer self);
VALA_EXTERN gboolean generator_next (Generator* self);
VALA_EXTERN gpointer generator_get (Generator* self);
VALA_EXTERN Generator* generator_iterator (Generator* self);
static void generator_finalize (Generator * obj);
static GType generator_get_type_once (void);
VALA_EXTERN GType int_generator_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (IntGenerator, generator_unref)
static void int_generator_real_generate_data_free (gpointer _data);
static void int_generator_real_generate (Generator* base,
                                  GAsyncReadyCallback _callback_,
                                  gpointer _user_data_);
static gboolean int_generator_real_generate_co (IntGeneratorGenerateData* _data_);
static void int_generator_generate_ready (GObject* source_object,
                                   GAsyncResult* _res_,
                                   gpointer _user_data_);
VALA_EXTERN IntGenerator* int_generator_new (void);
VALA_EXTERN IntGenerator* int_generator_construct (GType object_type);
static GType int_generator_get_type_once (void);
static void _vala_main (void);

static inline gpointer
generator_get_instance_private (Generator* self)
{
	return G_STRUCT_MEMBER_P (self, Generator_private_offset);
}

Generator*
generator_construct (GType object_type,
                     GType g_type,
                     GBoxedCopyFunc g_dup_func,
                     GDestroyNotify g_destroy_func)
{
	Generator* self = NULL;
	self = (Generator*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	generator_helper (self, NULL, NULL);
	return self;
}

static void
generator_helper_data_free (gpointer _data)
{
	GeneratorHelperData* _data_;
	_data_ = _data;
	_generator_unref0 (_data_->self);
	g_slice_free (GeneratorHelperData, _data_);
}

static gpointer
_generator_ref0 (gpointer self)
{
	return self ? generator_ref (self) : NULL;
}

static void
generator_helper (Generator* self,
                  GAsyncReadyCallback _callback_,
                  gpointer _user_data_)
{
	GeneratorHelperData* _data_;
	Generator* _tmp0_;
	g_return_if_fail (IS_GENERATOR (self));
	_data_ = g_slice_new0 (GeneratorHelperData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_source_tag (_data_->_async_result, generator_helper);
	g_task_set_task_data (_data_->_async_result, _data_, generator_helper_data_free);
	_tmp0_ = _generator_ref0 (self);
	_data_->self = _tmp0_;
	generator_helper_co (_data_);
}

static void
generator_helper_finish (Generator* self,
                         GAsyncResult* _res_)
{
	GeneratorHelperData* _data_;
	g_return_if_fail (G_IS_TASK (_res_));
	g_return_if_fail (g_async_result_is_tagged (_res_, generator_helper));
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static void
generator_helper_ready (GObject* source_object,
                        GAsyncResult* _res_,
                        gpointer _user_data_)
{
	GeneratorHelperData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	generator_helper_co (_data_);
}

static gboolean
generator_helper_co (GeneratorHelperData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_state_ = 1;
	generator_generate (_data_->self, generator_helper_ready, _data_);
	return FALSE;
	_state_1:
	generator_generate_finish (_data_->self, _data_->_res_);
	_data_->self->priv->consumed = TRUE;
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

void
generator_generate (Generator* self,
                    GAsyncReadyCallback _callback_,
                    gpointer _user_data_)
{
	GeneratorClass* _klass_;
	_klass_ = GENERATOR_GET_CLASS (self);
	if (_klass_->generate) {
		_klass_->generate (self, _callback_, _user_data_);
	}
}

void
generator_generate_finish (Generator* self,
                           GAsyncResult* _res_)
{
	GeneratorClass* _klass_;
	_klass_ = GENERATOR_GET_CLASS (self);
	if (_klass_->generate_finish) {
		_klass_->generate_finish (self, _res_);
	}
}

static void
generator_feed_data_free (gpointer _data)
{
	GeneratorFeedData* _data_;
	_data_ = _data;
	((_data_->value == NULL) || (_data_->self->priv->g_destroy_func == NULL)) ? NULL : (_data_->value = (_data_->self->priv->g_destroy_func (_data_->value), NULL));
	_generator_unref0 (_data_->self);
	g_slice_free (GeneratorFeedData, _data_);
}

void
generator_feed (Generator* self,
                gconstpointer value,
                GAsyncReadyCallback _callback_,
                gpointer _user_data_)
{
	GeneratorFeedData* _data_;
	Generator* _tmp0_;
	gpointer _tmp1_;
	g_return_if_fail (IS_GENERATOR (self));
	_data_ = g_slice_new0 (GeneratorFeedData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_source_tag (_data_->_async_result, generator_feed);
	g_task_set_task_data (_data_->_async_result, _data_, generator_feed_data_free);
	_tmp0_ = _generator_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = ((value != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) value) : ((gpointer) value);
	((_data_->value == NULL) || (_data_->self->priv->g_destroy_func == NULL)) ? NULL : (_data_->value = (_data_->self->priv->g_destroy_func (_data_->value), NULL));
	_data_->value = _tmp1_;
	generator_feed_co (_data_);
}

void
generator_feed_finish (Generator* self,
                       GAsyncResult* _res_)
{
	GeneratorFeedData* _data_;
	g_return_if_fail (G_IS_TASK (_res_));
	g_return_if_fail (g_async_result_is_tagged (_res_, generator_feed));
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static gboolean
_generator_feed_co_gsource_func (gpointer self)
{
	gboolean result;
	result = generator_feed_co (self);
	return result;
}

static gboolean
generator_feed_co (GeneratorFeedData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->self->priv->value = _data_->value;
	(_data_->self->priv->callback_target_destroy_notify == NULL) ? NULL : (_data_->self->priv->callback_target_destroy_notify (_data_->self->priv->callback_target), NULL);
	_data_->self->priv->callback = NULL;
	_data_->self->priv->callback_target = NULL;
	_data_->self->priv->callback_target_destroy_notify = NULL;
	_data_->self->priv->callback = _generator_feed_co_gsource_func;
	_data_->self->priv->callback_target = _data_;
	_data_->self->priv->callback_target_destroy_notify = NULL;
	_data_->_state_ = 1;
	return FALSE;
	_state_1:
	;
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

gboolean
generator_next (Generator* self)
{
	gboolean result;
	g_return_val_if_fail (IS_GENERATOR (self), FALSE);
	result = !self->priv->consumed;
	return result;
}

gpointer
generator_get (Generator* self)
{
	gpointer _result_ = NULL;
	gconstpointer _tmp0_;
	gpointer _tmp1_;
	GSourceFunc _tmp2_;
	gpointer _tmp2__target;
	gpointer result;
	g_return_val_if_fail (IS_GENERATOR (self), NULL);
	_tmp0_ = self->priv->value;
	_tmp1_ = ((_tmp0_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp0_) : ((gpointer) _tmp0_);
	_result_ = _tmp1_;
	_tmp2_ = self->priv->callback;
	_tmp2__target = self->priv->callback_target;
	_tmp2_ (_tmp2__target);
	result = _result_;
	return result;
}

Generator*
generator_iterator (Generator* self)
{
	Generator* _tmp0_;
	Generator* result;
	g_return_val_if_fail (IS_GENERATOR (self), NULL);
	_tmp0_ = _generator_ref0 (self);
	result = _tmp0_;
	return result;
}

static void
value_generator_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_generator_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		generator_unref (value->data[0].v_pointer);
	}
}

static void
value_generator_copy_value (const GValue* src_value,
                            GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = generator_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_generator_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_generator_collect_value (GValue* value,
                               guint n_collect_values,
                               GTypeCValue* collect_values,
                               guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		Generator * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = generator_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_generator_lcopy_value (const GValue* value,
                             guint n_collect_values,
                             GTypeCValue* collect_values,
                             guint collect_flags)
{
	Generator ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = generator_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_generator (const gchar* name,
                      const gchar* nick,
                      const gchar* blurb,
                      GType object_type,
                      GParamFlags flags)
{
	ParamSpecGenerator* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_GENERATOR), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_generator (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GENERATOR), NULL);
	return value->data[0].v_pointer;
}

void
value_set_generator (GValue* value,
                     gpointer v_object)
{
	Generator * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GENERATOR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GENERATOR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		generator_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		generator_unref (old);
	}
}

void
value_take_generator (GValue* value,
                      gpointer v_object)
{
	Generator * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GENERATOR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GENERATOR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		generator_unref (old);
	}
}

static void
generator_class_init (GeneratorClass * klass,
                      gpointer klass_data)
{
	generator_parent_class = g_type_class_peek_parent (klass);
	((GeneratorClass *) klass)->finalize = generator_finalize;
	g_type_class_adjust_private_offset (klass, &Generator_private_offset);
}

static void
generator_instance_init (Generator * self,
                         gpointer klass)
{
	self->priv = generator_get_instance_private (self);
	self->ref_count = 1;
}

static void
generator_finalize (Generator * obj)
{
	Generator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_GENERATOR, Generator);
	g_signal_handlers_destroy (self);
	(self->priv->callback_target_destroy_notify == NULL) ? NULL : (self->priv->callback_target_destroy_notify (self->priv->callback_target), NULL);
	self->priv->callback = NULL;
	self->priv->callback_target = NULL;
	self->priv->callback_target_destroy_notify = NULL;
}

static GType
generator_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_generator_init, value_generator_free_value, value_generator_copy_value, value_generator_peek_pointer, "p", value_generator_collect_value, "p", value_generator_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (GeneratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) generator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Generator), 0, (GInstanceInitFunc) generator_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType generator_type_id;
	generator_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Generator", &g_define_type_info, &g_define_type_fundamental_info, G_TYPE_FLAG_ABSTRACT);
	Generator_private_offset = g_type_add_instance_private (generator_type_id, sizeof (GeneratorPrivate));
	return generator_type_id;
}

GType
generator_get_type (void)
{
	static volatile gsize generator_type_id__once = 0;
	if (g_once_init_enter (&generator_type_id__once)) {
		GType generator_type_id;
		generator_type_id = generator_get_type_once ();
		g_once_init_leave (&generator_type_id__once, generator_type_id);
	}
	return generator_type_id__once;
}

gpointer
generator_ref (gpointer instance)
{
	Generator * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
generator_unref (gpointer instance)
{
	Generator * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GENERATOR_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static void
int_generator_real_generate_data_free (gpointer _data)
{
	IntGeneratorGenerateData* _data_;
	_data_ = _data;
	_generator_unref0 (_data_->self);
	g_slice_free (IntGeneratorGenerateData, _data_);
}

static void
int_generator_real_generate (Generator* base,
                             GAsyncReadyCallback _callback_,
                             gpointer _user_data_)
{
	IntGenerator * self;
	IntGeneratorGenerateData* _data_;
	IntGenerator* _tmp0_;
	self = G_TYPE_CHECK_INSTANCE_CAST (base, TYPE_INT_GENERATOR, IntGenerator);
	_data_ = g_slice_new0 (IntGeneratorGenerateData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_source_tag (_data_->_async_result, int_generator_real_generate);
	g_task_set_task_data (_data_->_async_result, _data_, int_generator_real_generate_data_free);
	_tmp0_ = _generator_ref0 (self);
	_data_->self = _tmp0_;
	int_generator_real_generate_co (_data_);
}

static void
int_generator_generate_finish (Generator* base,
                               GAsyncResult* _res_)
{
	IntGeneratorGenerateData* _data_;
	g_return_if_fail (G_IS_TASK (_res_));
	g_return_if_fail (g_async_result_is_tagged (_res_, int_generator_real_generate));
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static void
int_generator_generate_ready (GObject* source_object,
                              GAsyncResult* _res_,
                              gpointer _user_data_)
{
	IntGeneratorGenerateData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	int_generator_real_generate_co (_data_);
}

static gboolean
int_generator_real_generate_co (IntGeneratorGenerateData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	{
		_data_->i = 0;
		{
			_data_->_tmp0_ = TRUE;
			while (TRUE) {
				if (!_data_->_tmp0_) {
					_data_->_tmp1_ = _data_->i;
					_data_->i = _data_->_tmp1_ + 1;
				}
				_data_->_tmp0_ = FALSE;
				if (!(_data_->i < 10)) {
					break;
				}
				if ((_data_->i % 2) == 0) {
					_data_->_state_ = 1;
					generator_feed (G_TYPE_CHECK_INSTANCE_CAST (_data_->self, TYPE_GENERATOR, Generator), (gpointer) ((gintptr) _data_->i), int_generator_generate_ready, _data_);
					return FALSE;
					_state_1:
					generator_feed_finish (G_TYPE_CHECK_INSTANCE_CAST (_data_->self, TYPE_GENERATOR, Generator), _data_->_res_);
				}
			}
		}
	}
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

IntGenerator*
int_generator_construct (GType object_type)
{
	IntGenerator* self = NULL;
	self = (IntGenerator*) generator_construct (object_type, G_TYPE_INT, NULL, NULL);
	return self;
}

IntGenerator*
int_generator_new (void)
{
	return int_generator_construct (TYPE_INT_GENERATOR);
}

static void
int_generator_class_init (IntGeneratorClass * klass,
                          gpointer klass_data)
{
	int_generator_parent_class = g_type_class_peek_parent (klass);
	((GeneratorClass *) klass)->generate = (void (*) (Generator*, GAsyncReadyCallback, gpointer)) int_generator_real_generate;
	((GeneratorClass *) klass)->generate_finish = (void (*) (Generator*, GAsyncResult*)) int_generator_generate_finish;
}

static void
int_generator_instance_init (IntGenerator * self,
                             gpointer klass)
{
}

static GType
int_generator_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (IntGeneratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) int_generator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IntGenerator), 0, (GInstanceInitFunc) int_generator_instance_init, NULL };
	GType int_generator_type_id;
	int_generator_type_id = g_type_register_static (TYPE_GENERATOR, "IntGenerator", &g_define_type_info, 0);
	return int_generator_type_id;
}

GType
int_generator_get_type (void)
{
	static volatile gsize int_generator_type_id__once = 0;
	if (g_once_init_enter (&int_generator_type_id__once)) {
		GType int_generator_type_id;
		int_generator_type_id = int_generator_get_type_once ();
		g_once_init_leave (&int_generator_type_id__once, int_generator_type_id);
	}
	return int_generator_type_id__once;
}

static void
_vala_main (void)
{
	IntGenerator* gen = NULL;
	IntGenerator* _tmp0_;
	gchar* _result_ = NULL;
	gchar* _tmp1_;
	const gchar* _tmp11_;
	_tmp0_ = int_generator_new ();
	gen = _tmp0_;
	_tmp1_ = g_strdup ("");
	_result_ = _tmp1_;
	{
		Generator* _item_it = NULL;
		IntGenerator* _tmp2_;
		Generator* _tmp3_;
		_tmp2_ = gen;
		_tmp3_ = generator_iterator (G_TYPE_CHECK_INSTANCE_CAST (_tmp2_, TYPE_GENERATOR, Generator));
		_item_it = _tmp3_;
		while (TRUE) {
			Generator* _tmp4_;
			gint item = 0;
			Generator* _tmp5_;
			gpointer _tmp6_;
			const gchar* _tmp7_;
			gchar* _tmp8_;
			gchar* _tmp9_;
			gchar* _tmp10_;
			_tmp4_ = _item_it;
			if (!generator_next (_tmp4_)) {
				break;
			}
			_tmp5_ = _item_it;
			_tmp6_ = generator_get (_tmp5_);
			item = (gint) ((gintptr) _tmp6_);
			_tmp7_ = _result_;
			_tmp8_ = g_strdup_printf ("%i ", item);
			_tmp9_ = _tmp8_;
			_tmp10_ = g_strconcat (_tmp7_, _tmp9_, NULL);
			_g_free0 (_result_);
			_result_ = _tmp10_;
			_g_free0 (_tmp9_);
		}
		_generator_unref0 (_item_it);
	}
	_tmp11_ = _result_;
	_vala_assert (g_strcmp0 (_tmp11_, "0 2 4 6 8 ") == 0, "result == \"0 2 4 6 8 \"");
	_g_free0 (_result_);
	_generator_unref0 (gen);
}

int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}

