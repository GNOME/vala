/* annotations_deprecated.c generated by valac, the Vala compiler
 * generated from annotations_deprecated.vala, do not modify */

#include <glib.h>
#include <glib-object.h>
#include <string.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

typedef void (*FooDelegate) (gpointer user_data) G_GNUC_DEPRECATED ;

#define TYPE_FOO_STRUCT (foo_struct_get_type ())
typedef struct _FooStruct FooStruct;

#define TYPE_FOOCLASS (fooclass_get_type ())
#define FOOCLASS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FOOCLASS, FooClass))
#define FOOCLASS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FOOCLASS, FooClassClass))
#define IS_FOOCLASS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FOOCLASS))
#define IS_FOOCLASS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FOOCLASS))
#define FOOCLASS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FOOCLASS, FooClassClass))

typedef struct _FooClass FooClass;
typedef struct _FooClassClass FooClassClass;
typedef struct _FooClassPrivate FooClassPrivate;
enum  {
	FOOCLASS_0_PROPERTY,
	FOOCLASS_BAR_PROPERTY,
	FOOCLASS_NUM_PROPERTIES
};
static GParamSpec* fooclass_properties[FOOCLASS_NUM_PROPERTIES];

#define TYPE_AFOO (afoo_get_type ())
#define AFOO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_AFOO, AFoo))
#define AFOO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_AFOO, AFooClass))
#define IS_AFOO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_AFOO))
#define IS_AFOO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_AFOO))
#define AFOO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_AFOO, AFooClass))

typedef struct _AFoo AFoo;
typedef struct _AFooClass AFooClass;
typedef struct _AFooPrivate AFooPrivate;
enum  {
	AFOO_0_PROPERTY,
	AFOO_NUM_PROPERTIES
};
static GParamSpec* afoo_properties[AFOO_NUM_PROPERTIES];

#define TYPE_IFOO (ifoo_get_type ())
#define IFOO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IFOO, IFoo))
#define IS_IFOO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IFOO))
#define IFOO_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IFOO, IFooIface))

typedef struct _IFoo IFoo;
typedef struct _IFooIface IFooIface;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef enum  {
	FOO_ENUM_BAR = 0,
	FOO_ENUM_FOO,
	FOO_ENUM_BAZ
} FooEnum G_GNUC_DEPRECATED ;

#define TYPE_FOO_ENUM (foo_enum_get_type ())
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _FooStruct {
	gint bar G_GNUC_DEPRECATED ;
} G_GNUC_DEPRECATED ;

struct _FooClass {
	GObject parent_instance;
	FooClassPrivate * priv;
	gint baz G_GNUC_DEPRECATED ;
};

struct _FooClassClass {
	GObjectClass parent_class;
	gint (*foov) (FooClass* self) G_GNUC_DEPRECATED ;
};

struct _FooClassPrivate {
	gint _bar;
};

struct _AFoo {
	GObject parent_instance;
	AFooPrivate * priv;
};

struct _AFooClass {
	GObjectClass parent_class;
	gint (*fooa) (AFoo* self) G_GNUC_DEPRECATED ;
};

struct _IFooIface {
	GTypeInterface parent_iface;
	void (*fooa) (IFoo* self) G_GNUC_DEPRECATED ;
};

VALA_EXTERN gint bar;
gint bar = 42;
static gint FooClass_private_offset;
static gpointer fooclass_parent_class = NULL;
VALA_EXTERN gint fooclass_manam;
gint fooclass_manam = 42;
static gpointer afoo_parent_class = NULL;

VALA_EXTERN void baz (void) G_GNUC_DEPRECATED ;
VALA_EXTERN GType foo_struct_get_type (void) G_GNUC_CONST ;
VALA_EXTERN FooStruct* foo_struct_dup (const FooStruct* self);
VALA_EXTERN void foo_struct_free (FooStruct* self);
VALA_EXTERN void test_struct_field (void);
VALA_EXTERN GType fooclass_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FooClass, g_object_unref)
VALA_EXTERN gint fooclass_foov (FooClass* self) G_GNUC_DEPRECATED ;
VALA_EXTERN gint fooclass_foo (FooClass* self) G_GNUC_DEPRECATED ;
static gint fooclass_real_foov (FooClass* self) G_GNUC_DEPRECATED ;
VALA_EXTERN FooClass* fooclass_new (void);
VALA_EXTERN FooClass* fooclass_construct (GType object_type);
VALA_EXTERN gint fooclass_get_bar (FooClass* self) G_GNUC_DEPRECATED ;
VALA_EXTERN void fooclass_set_bar (FooClass* self,
                       gint value) G_GNUC_DEPRECATED ;
static void fooclass_finalize (GObject * obj);
static GType fooclass_get_type_once (void);
static void _vala_fooclass_get_property (GObject * object,
                                  guint property_id,
                                  GValue * value,
                                  GParamSpec * pspec);
static void _vala_fooclass_set_property (GObject * object,
                                  guint property_id,
                                  const GValue * value,
                                  GParamSpec * pspec);
VALA_EXTERN GType afoo_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (AFoo, g_object_unref)
VALA_EXTERN gint afoo_fooa (AFoo* self) G_GNUC_DEPRECATED ;
VALA_EXTERN gint afoo_foo (AFoo* self) G_GNUC_DEPRECATED ;
static gint afoo_real_fooa (AFoo* self) G_GNUC_DEPRECATED ;
VALA_EXTERN AFoo* afoo_construct (GType object_type);
static GType afoo_get_type_once (void);
VALA_EXTERN GType ifoo_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (IFoo, g_object_unref)
VALA_EXTERN gint ifoo_foo (IFoo* self) G_GNUC_DEPRECATED ;
VALA_EXTERN void ifoo_fooa (IFoo* self) G_GNUC_DEPRECATED ;
static GType ifoo_get_type_once (void);
VALA_EXTERN void test_class_property (void);
VALA_EXTERN GType foo_enum_get_type (void) G_GNUC_CONST ;
VALA_EXTERN void test_enum (void);
static void _vala_main (void);

void
baz (void)
{
}

FooStruct*
foo_struct_dup (const FooStruct* self)
{
	FooStruct* dup;
	dup = g_new0 (FooStruct, 1);
	memcpy (dup, self, sizeof (FooStruct));
	return dup;
}

void
foo_struct_free (FooStruct* self)
{
	g_free (self);
}

static GType
foo_struct_get_type_once (void)
{
	GType foo_struct_type_id;
	foo_struct_type_id = g_boxed_type_register_static ("FooStruct", (GBoxedCopyFunc) foo_struct_dup, (GBoxedFreeFunc) foo_struct_free);
	return foo_struct_type_id;
}

GType
foo_struct_get_type (void)
{
	static volatile gsize foo_struct_type_id__once = 0;
	if (g_once_init_enter (&foo_struct_type_id__once)) {
		GType foo_struct_type_id;
		foo_struct_type_id = foo_struct_get_type_once ();
		g_once_init_leave (&foo_struct_type_id__once, foo_struct_type_id);
	}
	return foo_struct_type_id__once;
}

void
test_struct_field (void)
{
	FooStruct foo = {0};
	FooStruct _tmp0_ = {0};
	gint i = 0;
	FooStruct _tmp1_;
	FooStruct _tmp2_;
	_tmp0_.bar = 42;
	foo = _tmp0_;
	_tmp1_ = foo;
	i = _tmp1_.bar;
	foo.bar = i;
	_tmp2_ = foo;
	_vala_assert (_tmp2_.bar == 42, "foo.bar == 42");
}

static inline gpointer
fooclass_get_instance_private (FooClass* self)
{
	return G_STRUCT_MEMBER_P (self, FooClass_private_offset);
}

gint
fooclass_foo (FooClass* self)
{
	gint result;
	g_return_val_if_fail (IS_FOOCLASS (self), 0);
	result = 42;
	return result;
}

static gint
fooclass_real_foov (FooClass* self)
{
	gint result;
	result = 42;
	return result;
}

gint
fooclass_foov (FooClass* self)
{
	FooClassClass* _klass_;
	g_return_val_if_fail (IS_FOOCLASS (self), 0);
	_klass_ = FOOCLASS_GET_CLASS (self);
	if (_klass_->foov) {
		return _klass_->foov (self);
	}
	return -1;
}

FooClass*
fooclass_construct (GType object_type)
{
	FooClass * self = NULL;
	self = (FooClass*) g_object_new (object_type, NULL);
	return self;
}

FooClass*
fooclass_new (void)
{
	return fooclass_construct (TYPE_FOOCLASS);
}

gint
fooclass_get_bar (FooClass* self)
{
	gint result;
	g_return_val_if_fail (IS_FOOCLASS (self), 0);
	result = self->priv->_bar;
	return result;
}

void
fooclass_set_bar (FooClass* self,
                  gint value)
{
	gint old_value;
	g_return_if_fail (IS_FOOCLASS (self));
	old_value = fooclass_get_bar (self);
	if (old_value != value) {
		self->priv->_bar = value;
		g_object_notify_by_pspec ((GObject *) self, fooclass_properties[FOOCLASS_BAR_PROPERTY]);
	}
}

static void
fooclass_class_init (FooClassClass * klass,
                     gpointer klass_data)
{
	fooclass_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &FooClass_private_offset);
	((FooClassClass *) klass)->foov = (gint (*) (FooClass*)) fooclass_real_foov;
	G_OBJECT_CLASS (klass)->get_property = _vala_fooclass_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_fooclass_set_property;
	G_OBJECT_CLASS (klass)->finalize = fooclass_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOOCLASS_BAR_PROPERTY, fooclass_properties[FOOCLASS_BAR_PROPERTY] = g_param_spec_int ("bar", "bar", "bar", G_MININT, G_MAXINT, 42, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_DEPRECATED));
}

static void
fooclass_instance_init (FooClass * self,
                        gpointer klass)
{
	self->priv = fooclass_get_instance_private (self);
	self->priv->_bar = 42;
}

static void
fooclass_finalize (GObject * obj)
{
	FooClass * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FOOCLASS, FooClass);
	G_OBJECT_CLASS (fooclass_parent_class)->finalize (obj);
}

static GType
fooclass_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FooClassClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fooclass_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FooClass), 0, (GInstanceInitFunc) fooclass_instance_init, NULL };
	GType fooclass_type_id;
	fooclass_type_id = g_type_register_static (G_TYPE_OBJECT, "FooClass", &g_define_type_info, 0);
	FooClass_private_offset = g_type_add_instance_private (fooclass_type_id, sizeof (FooClassPrivate));
	return fooclass_type_id;
}

GType
fooclass_get_type (void)
{
	static volatile gsize fooclass_type_id__once = 0;
	if (g_once_init_enter (&fooclass_type_id__once)) {
		GType fooclass_type_id;
		fooclass_type_id = fooclass_get_type_once ();
		g_once_init_leave (&fooclass_type_id__once, fooclass_type_id);
	}
	return fooclass_type_id__once;
}

static void
_vala_fooclass_get_property (GObject * object,
                             guint property_id,
                             GValue * value,
                             GParamSpec * pspec)
{
	FooClass * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_FOOCLASS, FooClass);
	switch (property_id) {
		case FOOCLASS_BAR_PROPERTY:
G_GNUC_BEGIN_IGNORE_DEPRECATIONS
		g_value_set_int (value, fooclass_get_bar (self));
G_GNUC_END_IGNORE_DEPRECATIONS
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_fooclass_set_property (GObject * object,
                             guint property_id,
                             const GValue * value,
                             GParamSpec * pspec)
{
	FooClass * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_FOOCLASS, FooClass);
	switch (property_id) {
		case FOOCLASS_BAR_PROPERTY:
G_GNUC_BEGIN_IGNORE_DEPRECATIONS
		fooclass_set_bar (self, g_value_get_int (value));
G_GNUC_END_IGNORE_DEPRECATIONS
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

gint
afoo_foo (AFoo* self)
{
	gint result;
	g_return_val_if_fail (IS_AFOO (self), 0);
	result = 42;
	return result;
}

static gint
afoo_real_fooa (AFoo* self)
{
	gint _tmp0_ = 0;
	g_critical ("Type `%s' does not implement abstract method `afoo_fooa'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return _tmp0_;
}

gint
afoo_fooa (AFoo* self)
{
	AFooClass* _klass_;
	g_return_val_if_fail (IS_AFOO (self), 0);
	_klass_ = AFOO_GET_CLASS (self);
	if (_klass_->fooa) {
		return _klass_->fooa (self);
	}
	return -1;
}

AFoo*
afoo_construct (GType object_type)
{
	AFoo * self = NULL;
	self = (AFoo*) g_object_new (object_type, NULL);
	return self;
}

static void
afoo_class_init (AFooClass * klass,
                 gpointer klass_data)
{
	afoo_parent_class = g_type_class_peek_parent (klass);
	((AFooClass *) klass)->fooa = (gint (*) (AFoo*)) afoo_real_fooa;
}

static void
afoo_instance_init (AFoo * self,
                    gpointer klass)
{
}

static GType
afoo_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (AFooClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) afoo_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AFoo), 0, (GInstanceInitFunc) afoo_instance_init, NULL };
	GType afoo_type_id;
	afoo_type_id = g_type_register_static (G_TYPE_OBJECT, "AFoo", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
	return afoo_type_id;
}

GType
afoo_get_type (void)
{
	static volatile gsize afoo_type_id__once = 0;
	if (g_once_init_enter (&afoo_type_id__once)) {
		GType afoo_type_id;
		afoo_type_id = afoo_get_type_once ();
		g_once_init_leave (&afoo_type_id__once, afoo_type_id);
	}
	return afoo_type_id__once;
}

gint
ifoo_foo (IFoo* self)
{
	gint result;
	result = 42;
	return result;
}

void
ifoo_fooa (IFoo* self)
{
	IFooIface* _iface_;
	g_return_if_fail (IS_IFOO (self));
	_iface_ = IFOO_GET_INTERFACE (self);
	if (_iface_->fooa) {
		_iface_->fooa (self);
	}
}

static void
ifoo_default_init (IFooIface * iface,
                   gpointer iface_data)
{
}

static GType
ifoo_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (IFooIface), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ifoo_default_init, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
	GType ifoo_type_id;
	ifoo_type_id = g_type_register_static (G_TYPE_INTERFACE, "IFoo", &g_define_type_info, 0);
	g_type_interface_add_prerequisite (ifoo_type_id, G_TYPE_OBJECT);
	return ifoo_type_id;
}

GType
ifoo_get_type (void)
{
	static volatile gsize ifoo_type_id__once = 0;
	if (g_once_init_enter (&ifoo_type_id__once)) {
		GType ifoo_type_id;
		ifoo_type_id = ifoo_get_type_once ();
		g_once_init_leave (&ifoo_type_id__once, ifoo_type_id);
	}
	return ifoo_type_id__once;
}

void
test_class_property (void)
{
	FooClass* foo = NULL;
	FooClass* _tmp0_;
	gint i = 0;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	_tmp0_ = fooclass_new ();
	foo = _tmp0_;
	_tmp1_ = fooclass_get_bar (foo);
	_tmp2_ = _tmp1_;
	i = _tmp2_;
	fooclass_set_bar (foo, i);
	_tmp3_ = fooclass_get_bar (foo);
	_tmp4_ = _tmp3_;
	_vala_assert (_tmp4_ == 42, "foo.bar == 42");
	_g_object_unref0 (foo);
}

static GType
foo_enum_get_type_once (void)
{
	static const GEnumValue values[] = {{FOO_ENUM_BAR, "FOO_ENUM_BAR", "bar"}, {FOO_ENUM_FOO, "FOO_ENUM_FOO", "foo"}, {FOO_ENUM_BAZ, "FOO_ENUM_BAZ", "baz"}, {0, NULL, NULL}};
	GType foo_enum_type_id;
	foo_enum_type_id = g_enum_register_static ("FooEnum", values);
	return foo_enum_type_id;
}

GType
foo_enum_get_type (void)
{
	static volatile gsize foo_enum_type_id__once = 0;
	if (g_once_init_enter (&foo_enum_type_id__once)) {
		GType foo_enum_type_id;
		foo_enum_type_id = foo_enum_get_type_once ();
		g_once_init_leave (&foo_enum_type_id__once, foo_enum_type_id);
	}
	return foo_enum_type_id__once;
}

void
test_enum (void)
{
	FooEnum foo = 0;
	foo = FOO_ENUM_BAR;
	_vala_assert (foo == 0, "foo == 0");
}

static void
_vala_main (void)
{
	test_class_property ();
	test_struct_field ();
	test_enum ();
}

int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}

