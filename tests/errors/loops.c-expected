/* errors_loops.c generated by valac, the Vala compiler
 * generated from errors_loops.vala, do not modify */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_FOO_ERROR (foo_error_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))

typedef enum  {
	FOO_ERROR_FAIL
} FooError;
#define FOO_ERROR foo_error_quark ()

VALA_EXTERN GQuark foo_error_quark (void);
VALA_EXTERN GType foo_error_get_type (void) G_GNUC_CONST ;
VALA_EXTERN gchar** get_array (gint* result_length1,
                   GError** error);
VALA_EXTERN gboolean get_bool (GError** error);
VALA_EXTERN gint get_int (GError** error);
VALA_EXTERN void error_in_for (void);
VALA_EXTERN void error_in_foreach (void);
VALA_EXTERN void error_in_do (void);
VALA_EXTERN void error_in_while (void);
static void _vala_main (void);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);

GQuark
foo_error_quark (void)
{
	return g_quark_from_static_string ("foo-error-quark");
}

static GType
foo_error_get_type_once (void)
{
	static const GEnumValue values[] = {{FOO_ERROR_FAIL, "FOO_ERROR_FAIL", "fail"}, {0, NULL, NULL}};
	GType foo_error_type_id;
	foo_error_type_id = g_enum_register_static ("FooError", values);
	return foo_error_type_id;
}

GType
foo_error_get_type (void)
{
	static volatile gsize foo_error_type_id__once = 0;
	if (g_once_init_enter (&foo_error_type_id__once)) {
		GType foo_error_type_id;
		foo_error_type_id = foo_error_get_type_once ();
		g_once_init_leave (&foo_error_type_id__once, foo_error_type_id);
	}
	return foo_error_type_id__once;
}

gchar**
get_array (gint* result_length1,
           GError** error)
{
	GError* _tmp0_;
	GError* _inner_error0_ = NULL;
	_tmp0_ = g_error_new_literal (FOO_ERROR, FOO_ERROR_FAIL, "foo");
	_inner_error0_ = _tmp0_;
	g_propagate_error (error, _inner_error0_);
	return NULL;
}

gboolean
get_bool (GError** error)
{
	GError* _tmp0_;
	gboolean _tmp1_ = FALSE;
	GError* _inner_error0_ = NULL;
	_tmp0_ = g_error_new_literal (FOO_ERROR, FOO_ERROR_FAIL, "foo");
	_inner_error0_ = _tmp0_;
	g_propagate_error (error, _inner_error0_);
	return _tmp1_;
}

gint
get_int (GError** error)
{
	GError* _tmp0_;
	gint _tmp1_ = -1;
	GError* _inner_error0_ = NULL;
	_tmp0_ = g_error_new_literal (FOO_ERROR, FOO_ERROR_FAIL, "foo");
	_inner_error0_ = _tmp0_;
	g_propagate_error (error, _inner_error0_);
	return _tmp1_;
}

void
error_in_for (void)
{
	GError* _inner_error0_ = NULL;
	{
		{
			gint i = 0;
			i = get_int (&_inner_error0_);
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				goto __catch0_g_error;
			}
			{
				gboolean _tmp0_ = FALSE;
				_tmp0_ = TRUE;
				while (TRUE) {
					if (!_tmp0_) {
						gint _tmp1_;
						_tmp1_ = i;
						i = _tmp1_ + 1;
					}
					_tmp0_ = FALSE;
					if (!(i < 2)) {
						break;
					}
					g_assert_not_reached ();
				}
			}
		}
		g_assert_not_reached ();
	}
	goto __finally0;
	__catch0_g_error:
	{
		g_clear_error (&_inner_error0_);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	{
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp2_ = FALSE;
				_tmp2_ = TRUE;
				while (TRUE) {
					gboolean _tmp4_ = FALSE;
					if (!_tmp2_) {
						gint _tmp3_;
						_tmp3_ = i;
						i = _tmp3_ + 1;
					}
					_tmp2_ = FALSE;
					_tmp4_ = get_bool (&_inner_error0_);
					if (G_UNLIKELY (_inner_error0_ != NULL)) {
						goto __catch1_g_error;
					}
					if (!_tmp4_) {
						break;
					}
					g_assert_not_reached ();
				}
			}
		}
		g_assert_not_reached ();
	}
	goto __finally1;
	__catch1_g_error:
	{
		g_clear_error (&_inner_error0_);
	}
	__finally1:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	{
		gboolean reached = FALSE;
		reached = FALSE;
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp5_ = FALSE;
				_tmp5_ = TRUE;
				while (TRUE) {
					if (!_tmp5_) {
						gint _tmp6_ = 0;
						_tmp6_ = get_int (&_inner_error0_);
						if (G_UNLIKELY (_inner_error0_ != NULL)) {
							goto __catch2_g_error;
						}
						i += _tmp6_;
					}
					_tmp5_ = FALSE;
					if (!(i < 2)) {
						break;
					}
					if (reached) {
						g_assert_not_reached ();
					} else {
						reached = TRUE;
					}
				}
			}
		}
		g_assert_not_reached ();
	}
	goto __finally2;
	__catch2_g_error:
	{
		g_clear_error (&_inner_error0_);
	}
	__finally2:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	{
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp7_ = FALSE;
				_tmp7_ = TRUE;
				while (TRUE) {
					GError* _tmp9_;
					if (!_tmp7_) {
						gint _tmp8_;
						_tmp8_ = i;
						i = _tmp8_ + 1;
					}
					_tmp7_ = FALSE;
					if (!(i < 2)) {
						break;
					}
					_tmp9_ = g_error_new_literal (FOO_ERROR, FOO_ERROR_FAIL, "foo");
					_inner_error0_ = _tmp9_;
					goto __catch3_g_error;
				}
			}
		}
		g_assert_not_reached ();
	}
	goto __finally3;
	__catch3_g_error:
	{
		g_clear_error (&_inner_error0_);
	}
	__finally3:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

void
error_in_foreach (void)
{
	GError* _inner_error0_ = NULL;
	{
		gchar** _tmp0_ = NULL;
		gint _tmp1_ = 0;
		gchar** _tmp2_;
		gint _tmp0__length1;
		gint __tmp0__size_;
		_tmp2_ = get_array (&_tmp1_, &_inner_error0_);
		_tmp0_ = _tmp2_;
		_tmp0__length1 = _tmp1_;
		__tmp0__size_ = _tmp0__length1;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		{
			gchar** s_collection = NULL;
			gint s_collection_length1 = 0;
			gint _s_collection_size_ = 0;
			gint s_it = 0;
			s_collection = _tmp0_;
			s_collection_length1 = _tmp0__length1;
			for (s_it = 0; s_it < s_collection_length1; s_it = s_it + 1) {
				gchar* _tmp3_;
				gchar* s = NULL;
				_tmp3_ = g_strdup (s_collection[s_it]);
				s = _tmp3_;
				{
					g_assert_not_reached ();
					_g_free0 (s);
				}
			}
		}
		g_assert_not_reached ();
		_tmp0_ = (_vala_array_free (_tmp0_, _tmp0__length1, (GDestroyNotify) g_free), NULL);
	}
	goto __finally0;
	__catch0_g_error:
	{
		g_clear_error (&_inner_error0_);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	{
		gchar** array = NULL;
		gchar* _tmp4_;
		gchar** _tmp5_;
		gint array_length1;
		gint _array_size_;
		_tmp4_ = g_strdup ("bar");
		_tmp5_ = g_new0 (gchar*, 1 + 1);
		_tmp5_[0] = _tmp4_;
		array = _tmp5_;
		array_length1 = 1;
		_array_size_ = array_length1;
		{
			gchar** s_collection = NULL;
			gint s_collection_length1 = 0;
			gint _s_collection_size_ = 0;
			gint s_it = 0;
			s_collection = array;
			s_collection_length1 = array_length1;
			for (s_it = 0; s_it < s_collection_length1; s_it = s_it + 1) {
				gchar* _tmp6_;
				gchar* s = NULL;
				_tmp6_ = g_strdup (s_collection[s_it]);
				s = _tmp6_;
				{
					GError* _tmp7_;
					_tmp7_ = g_error_new_literal (FOO_ERROR, FOO_ERROR_FAIL, "foo");
					_inner_error0_ = _tmp7_;
					_g_free0 (s);
					array = (_vala_array_free (array, array_length1, (GDestroyNotify) g_free), NULL);
					goto __catch1_g_error;
				}
			}
		}
		g_assert_not_reached ();
		array = (_vala_array_free (array, array_length1, (GDestroyNotify) g_free), NULL);
	}
	goto __finally1;
	__catch1_g_error:
	{
		g_clear_error (&_inner_error0_);
	}
	__finally1:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

void
error_in_do (void)
{
	GError* _inner_error0_ = NULL;
	{
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					gboolean _tmp1_ = FALSE;
					_tmp1_ = get_bool (&_inner_error0_);
					if (G_UNLIKELY (_inner_error0_ != NULL)) {
						goto __catch0_g_error;
					}
					if (!_tmp1_) {
						break;
					}
				}
				_tmp0_ = FALSE;
			}
		}
		g_assert_not_reached ();
	}
	goto __finally0;
	__catch0_g_error:
	{
		g_clear_error (&_inner_error0_);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	{
		while (TRUE) {
			GError* _tmp2_;
			_tmp2_ = g_error_new_literal (FOO_ERROR, FOO_ERROR_FAIL, "foo");
			_inner_error0_ = _tmp2_;
			goto __catch1_g_error;
		}
		g_assert_not_reached ();
	}
	goto __finally1;
	__catch1_g_error:
	{
		g_clear_error (&_inner_error0_);
	}
	__finally1:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

void
error_in_while (void)
{
	GError* _inner_error0_ = NULL;
	{
		while (TRUE) {
			gboolean _tmp0_ = FALSE;
			_tmp0_ = get_bool (&_inner_error0_);
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				goto __catch0_g_error;
			}
			if (!_tmp0_) {
				break;
			}
			g_assert_not_reached ();
		}
		g_assert_not_reached ();
	}
	goto __finally0;
	__catch0_g_error:
	{
		g_clear_error (&_inner_error0_);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	{
		while (TRUE) {
			GError* _tmp1_;
			_tmp1_ = g_error_new_literal (FOO_ERROR, FOO_ERROR_FAIL, "foo");
			_inner_error0_ = _tmp1_;
			goto __catch1_g_error;
		}
		g_assert_not_reached ();
	}
	goto __finally1;
	__catch1_g_error:
	{
		g_clear_error (&_inner_error0_);
	}
	__finally1:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

static void
_vala_main (void)
{
	error_in_for ();
	error_in_foreach ();
	error_in_do ();
	error_in_while ();
}

int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

