/* methods_iterator.c generated by valac, the Vala compiler
 * generated from methods_iterator.vala, do not modify */

#include <glib-object.h>
#include <gobject/gvaluecollector.h>
#include <glib.h>
#include <stdlib.h>
#include <string.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_FOO (foo_get_type ())
#define FOO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FOO, Foo))
#define FOO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FOO, FooClass))
#define IS_FOO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FOO))
#define IS_FOO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FOO))
#define FOO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FOO, FooClass))

typedef struct _Foo Foo;
typedef struct _FooClass FooClass;
typedef struct _FooPrivate FooPrivate;
typedef struct _ParamSpecFoo ParamSpecFoo;

#define TYPE_FOO_ITERATOR (foo_iterator_get_type ())
#define FOO_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FOO_ITERATOR, FooIterator))
#define FOO_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FOO_ITERATOR, FooIteratorClass))
#define IS_FOO_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FOO_ITERATOR))
#define IS_FOO_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FOO_ITERATOR))
#define FOO_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FOO_ITERATOR, FooIteratorClass))

typedef struct _FooIterator FooIterator;
typedef struct _FooIteratorClass FooIteratorClass;
typedef struct _FooIteratorPrivate FooIteratorPrivate;
typedef struct _ParamSpecFooIterator ParamSpecFooIterator;

#define TYPE_FOO_COLLECTION (foo_collection_get_type ())
#define FOO_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FOO_COLLECTION, FooCollection))
#define FOO_COLLECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FOO_COLLECTION, FooCollectionClass))
#define IS_FOO_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FOO_COLLECTION))
#define IS_FOO_COLLECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FOO_COLLECTION))
#define FOO_COLLECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FOO_COLLECTION, FooCollectionClass))

typedef struct _FooCollection FooCollection;
typedef struct _FooCollectionClass FooCollectionClass;
typedef struct _FooCollectionPrivate FooCollectionPrivate;
typedef struct _ParamSpecFooCollection ParamSpecFooCollection;

#define TYPE_FOO_ITERATOR2 (foo_iterator2_get_type ())
#define FOO_ITERATOR2(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FOO_ITERATOR2, FooIterator2))
#define FOO_ITERATOR2_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FOO_ITERATOR2, FooIterator2Class))
#define IS_FOO_ITERATOR2(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FOO_ITERATOR2))
#define IS_FOO_ITERATOR2_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FOO_ITERATOR2))
#define FOO_ITERATOR2_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FOO_ITERATOR2, FooIterator2Class))

typedef struct _FooIterator2 FooIterator2;
typedef struct _FooIterator2Class FooIterator2Class;
typedef struct _FooIterator2Private FooIterator2Private;
typedef struct _ParamSpecFooIterator2 ParamSpecFooIterator2;

#define TYPE_FOO_COLLECTION2 (foo_collection2_get_type ())
#define FOO_COLLECTION2(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FOO_COLLECTION2, FooCollection2))
#define FOO_COLLECTION2_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FOO_COLLECTION2, FooCollection2Class))
#define IS_FOO_COLLECTION2(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FOO_COLLECTION2))
#define IS_FOO_COLLECTION2_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FOO_COLLECTION2))
#define FOO_COLLECTION2_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FOO_COLLECTION2, FooCollection2Class))

typedef struct _FooCollection2 FooCollection2;
typedef struct _FooCollection2Class FooCollection2Class;
typedef struct _FooCollection2Private FooCollection2Private;
typedef struct _ParamSpecFooCollection2 ParamSpecFooCollection2;

#define TYPE_FOO_COLLECTION3 (foo_collection3_get_type ())
#define FOO_COLLECTION3(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FOO_COLLECTION3, FooCollection3))
#define FOO_COLLECTION3_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FOO_COLLECTION3, FooCollection3Class))
#define IS_FOO_COLLECTION3(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FOO_COLLECTION3))
#define IS_FOO_COLLECTION3_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FOO_COLLECTION3))
#define FOO_COLLECTION3_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FOO_COLLECTION3, FooCollection3Class))

typedef struct _FooCollection3 FooCollection3;
typedef struct _FooCollection3Class FooCollection3Class;
typedef struct _FooCollection3Private FooCollection3Private;
typedef struct _ParamSpecFooCollection3 ParamSpecFooCollection3;

#define TYPE_FOO_ENTRY4 (foo_entry4_get_type ())
#define FOO_ENTRY4(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FOO_ENTRY4, FooEntry4))
#define FOO_ENTRY4_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FOO_ENTRY4, FooEntry4Class))
#define IS_FOO_ENTRY4(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FOO_ENTRY4))
#define IS_FOO_ENTRY4_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FOO_ENTRY4))
#define FOO_ENTRY4_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FOO_ENTRY4, FooEntry4Class))

typedef struct _FooEntry4 FooEntry4;
typedef struct _FooEntry4Class FooEntry4Class;
typedef struct _FooEntry4Private FooEntry4Private;
typedef struct _ParamSpecFooEntry4 ParamSpecFooEntry4;

#define TYPE_FOO_ITERATOR4 (foo_iterator4_get_type ())
#define FOO_ITERATOR4(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FOO_ITERATOR4, FooIterator4))
#define FOO_ITERATOR4_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FOO_ITERATOR4, FooIterator4Class))
#define IS_FOO_ITERATOR4(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FOO_ITERATOR4))
#define IS_FOO_ITERATOR4_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FOO_ITERATOR4))
#define FOO_ITERATOR4_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FOO_ITERATOR4, FooIterator4Class))

typedef struct _FooIterator4 FooIterator4;
typedef struct _FooIterator4Class FooIterator4Class;
typedef struct _FooIterator4Private FooIterator4Private;
typedef struct _ParamSpecFooIterator4 ParamSpecFooIterator4;

#define TYPE_FOO_COLLECTION4 (foo_collection4_get_type ())
#define FOO_COLLECTION4(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FOO_COLLECTION4, FooCollection4))
#define FOO_COLLECTION4_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FOO_COLLECTION4, FooCollection4Class))
#define IS_FOO_COLLECTION4(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FOO_COLLECTION4))
#define IS_FOO_COLLECTION4_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FOO_COLLECTION4))
#define FOO_COLLECTION4_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FOO_COLLECTION4, FooCollection4Class))

typedef struct _FooCollection4 FooCollection4;
typedef struct _FooCollection4Class FooCollection4Class;
typedef struct _FooCollection4Private FooCollection4Private;
typedef struct _ParamSpecFooCollection4 ParamSpecFooCollection4;
#define _foo_unref0(var) ((var == NULL) ? NULL : (var = (foo_unref (var), NULL)))
#define _foo_iterator_unref0(var) ((var == NULL) ? NULL : (var = (foo_iterator_unref (var), NULL)))
#define _foo_iterator2_unref0(var) ((var == NULL) ? NULL : (var = (foo_iterator2_unref (var), NULL)))
#define _foo_entry4_unref0(var) ((var == NULL) ? NULL : (var = (foo_entry4_unref (var), NULL)))
#define _foo_iterator4_unref0(var) ((var == NULL) ? NULL : (var = (foo_iterator4_unref (var), NULL)))
#define _foo_collection4_unref0(var) ((var == NULL) ? NULL : (var = (foo_collection4_unref (var), NULL)))
#define _foo_collection3_unref0(var) ((var == NULL) ? NULL : (var = (foo_collection3_unref (var), NULL)))
#define _foo_collection2_unref0(var) ((var == NULL) ? NULL : (var = (foo_collection2_unref (var), NULL)))
#define _foo_collection_unref0(var) ((var == NULL) ? NULL : (var = (foo_collection_unref (var), NULL)))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _Foo {
	GTypeInstance parent_instance;
	volatile int ref_count;
	FooPrivate * priv;
};

struct _FooClass {
	GTypeClass parent_class;
	void (*finalize) (Foo *self);
};

struct _ParamSpecFoo {
	GParamSpec parent_instance;
};

struct _FooIterator {
	GTypeInstance parent_instance;
	volatile int ref_count;
	FooIteratorPrivate * priv;
};

struct _FooIteratorClass {
	GTypeClass parent_class;
	void (*finalize) (FooIterator *self);
};

struct _FooIteratorPrivate {
	gboolean called;
};

struct _ParamSpecFooIterator {
	GParamSpec parent_instance;
};

struct _FooCollection {
	GTypeInstance parent_instance;
	volatile int ref_count;
	FooCollectionPrivate * priv;
};

struct _FooCollectionClass {
	GTypeClass parent_class;
	void (*finalize) (FooCollection *self);
};

struct _ParamSpecFooCollection {
	GParamSpec parent_instance;
};

struct _FooIterator2 {
	GTypeInstance parent_instance;
	volatile int ref_count;
	FooIterator2Private * priv;
};

struct _FooIterator2Class {
	GTypeClass parent_class;
	void (*finalize) (FooIterator2 *self);
};

struct _FooIterator2Private {
	gboolean called;
};

struct _ParamSpecFooIterator2 {
	GParamSpec parent_instance;
};

struct _FooCollection2 {
	GTypeInstance parent_instance;
	volatile int ref_count;
	FooCollection2Private * priv;
};

struct _FooCollection2Class {
	GTypeClass parent_class;
	void (*finalize) (FooCollection2 *self);
};

struct _ParamSpecFooCollection2 {
	GParamSpec parent_instance;
};

struct _FooCollection3 {
	GTypeInstance parent_instance;
	volatile int ref_count;
	FooCollection3Private * priv;
};

struct _FooCollection3Class {
	GTypeClass parent_class;
	void (*finalize) (FooCollection3 *self);
};

struct _ParamSpecFooCollection3 {
	GParamSpec parent_instance;
};

struct _FooEntry4 {
	GTypeInstance parent_instance;
	volatile int ref_count;
	FooEntry4Private * priv;
};

struct _FooEntry4Class {
	GTypeClass parent_class;
	void (*finalize) (FooEntry4 *self);
};

struct _FooEntry4Private {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
	gpointer _key;
	gpointer _value;
};

struct _ParamSpecFooEntry4 {
	GParamSpec parent_instance;
};

struct _FooIterator4 {
	GTypeInstance parent_instance;
	volatile int ref_count;
	FooIterator4Private * priv;
};

struct _FooIterator4Class {
	GTypeClass parent_class;
	void (*finalize) (FooIterator4 *self);
};

struct _FooIterator4Private {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
	gboolean called;
};

struct _ParamSpecFooIterator4 {
	GParamSpec parent_instance;
};

struct _FooCollection4 {
	GTypeInstance parent_instance;
	volatile int ref_count;
	FooCollection4Private * priv;
};

struct _FooCollection4Class {
	GTypeClass parent_class;
	void (*finalize) (FooCollection4 *self);
};

struct _FooCollection4Private {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
};

struct _ParamSpecFooCollection4 {
	GParamSpec parent_instance;
};

static gpointer foo_parent_class = NULL;
static gint FooIterator_private_offset;
static gpointer foo_iterator_parent_class = NULL;
VALA_EXTERN Foo* foo_instance;
static gpointer foo_collection_parent_class = NULL;
static gint FooIterator2_private_offset;
static gpointer foo_iterator2_parent_class = NULL;
static gpointer foo_collection2_parent_class = NULL;
static gpointer foo_collection3_parent_class = NULL;
static gint FooEntry4_private_offset;
static gpointer foo_entry4_parent_class = NULL;
static gint FooIterator4_private_offset;
static gpointer foo_iterator4_parent_class = NULL;
static gint FooCollection4_private_offset;
static gpointer foo_collection4_parent_class = NULL;
Foo* foo_instance = NULL;

VALA_EXTERN gpointer foo_ref (gpointer instance);
VALA_EXTERN void foo_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_foo (const gchar* name,
                            const gchar* nick,
                            const gchar* blurb,
                            GType object_type,
                            GParamFlags flags);
VALA_EXTERN void value_set_foo (GValue* value,
                    gpointer v_object);
VALA_EXTERN void value_take_foo (GValue* value,
                     gpointer v_object);
VALA_EXTERN gpointer value_get_foo (const GValue* value);
VALA_EXTERN GType foo_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Foo, foo_unref)
VALA_EXTERN Foo* foo_new (void);
VALA_EXTERN Foo* foo_construct (GType object_type);
static void foo_finalize (Foo * obj);
static GType foo_get_type_once (void);
VALA_EXTERN gpointer foo_iterator_ref (gpointer instance);
VALA_EXTERN void foo_iterator_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_foo_iterator (const gchar* name,
                                     const gchar* nick,
                                     const gchar* blurb,
                                     GType object_type,
                                     GParamFlags flags);
VALA_EXTERN void value_set_foo_iterator (GValue* value,
                             gpointer v_object);
VALA_EXTERN void value_take_foo_iterator (GValue* value,
                              gpointer v_object);
VALA_EXTERN gpointer value_get_foo_iterator (const GValue* value);
VALA_EXTERN GType foo_iterator_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FooIterator, foo_iterator_unref)
VALA_EXTERN gboolean foo_iterator_next (FooIterator* self);
VALA_EXTERN Foo* foo_iterator_get (FooIterator* self);
VALA_EXTERN FooIterator* foo_iterator_new (void);
VALA_EXTERN FooIterator* foo_iterator_construct (GType object_type);
static void foo_iterator_finalize (FooIterator * obj);
static GType foo_iterator_get_type_once (void);
VALA_EXTERN gpointer foo_collection_ref (gpointer instance);
VALA_EXTERN void foo_collection_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_foo_collection (const gchar* name,
                                       const gchar* nick,
                                       const gchar* blurb,
                                       GType object_type,
                                       GParamFlags flags);
VALA_EXTERN void value_set_foo_collection (GValue* value,
                               gpointer v_object);
VALA_EXTERN void value_take_foo_collection (GValue* value,
                                gpointer v_object);
VALA_EXTERN gpointer value_get_foo_collection (const GValue* value);
VALA_EXTERN GType foo_collection_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FooCollection, foo_collection_unref)
VALA_EXTERN FooIterator* foo_collection_iterator (FooCollection* self);
VALA_EXTERN FooCollection* foo_collection_new (void);
VALA_EXTERN FooCollection* foo_collection_construct (GType object_type);
static void foo_collection_finalize (FooCollection * obj);
static GType foo_collection_get_type_once (void);
VALA_EXTERN gpointer foo_iterator2_ref (gpointer instance);
VALA_EXTERN void foo_iterator2_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_foo_iterator2 (const gchar* name,
                                      const gchar* nick,
                                      const gchar* blurb,
                                      GType object_type,
                                      GParamFlags flags);
VALA_EXTERN void value_set_foo_iterator2 (GValue* value,
                              gpointer v_object);
VALA_EXTERN void value_take_foo_iterator2 (GValue* value,
                               gpointer v_object);
VALA_EXTERN gpointer value_get_foo_iterator2 (const GValue* value);
VALA_EXTERN GType foo_iterator2_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FooIterator2, foo_iterator2_unref)
VALA_EXTERN Foo* foo_iterator2_next_value (FooIterator2* self);
VALA_EXTERN FooIterator2* foo_iterator2_new (void);
VALA_EXTERN FooIterator2* foo_iterator2_construct (GType object_type);
static void foo_iterator2_finalize (FooIterator2 * obj);
static GType foo_iterator2_get_type_once (void);
VALA_EXTERN gpointer foo_collection2_ref (gpointer instance);
VALA_EXTERN void foo_collection2_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_foo_collection2 (const gchar* name,
                                        const gchar* nick,
                                        const gchar* blurb,
                                        GType object_type,
                                        GParamFlags flags);
VALA_EXTERN void value_set_foo_collection2 (GValue* value,
                                gpointer v_object);
VALA_EXTERN void value_take_foo_collection2 (GValue* value,
                                 gpointer v_object);
VALA_EXTERN gpointer value_get_foo_collection2 (const GValue* value);
VALA_EXTERN GType foo_collection2_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FooCollection2, foo_collection2_unref)
VALA_EXTERN FooIterator2* foo_collection2_iterator (FooCollection2* self);
VALA_EXTERN FooCollection2* foo_collection2_new (void);
VALA_EXTERN FooCollection2* foo_collection2_construct (GType object_type);
static void foo_collection2_finalize (FooCollection2 * obj);
static GType foo_collection2_get_type_once (void);
VALA_EXTERN gpointer foo_collection3_ref (gpointer instance);
VALA_EXTERN void foo_collection3_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_foo_collection3 (const gchar* name,
                                        const gchar* nick,
                                        const gchar* blurb,
                                        GType object_type,
                                        GParamFlags flags);
VALA_EXTERN void value_set_foo_collection3 (GValue* value,
                                gpointer v_object);
VALA_EXTERN void value_take_foo_collection3 (GValue* value,
                                 gpointer v_object);
VALA_EXTERN gpointer value_get_foo_collection3 (const GValue* value);
VALA_EXTERN GType foo_collection3_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FooCollection3, foo_collection3_unref)
VALA_EXTERN Foo* foo_collection3_get (FooCollection3* self,
                          gint index);
VALA_EXTERN FooCollection3* foo_collection3_new (void);
VALA_EXTERN FooCollection3* foo_collection3_construct (GType object_type);
VALA_EXTERN gint foo_collection3_get_size (FooCollection3* self);
static void foo_collection3_finalize (FooCollection3 * obj);
static GType foo_collection3_get_type_once (void);
VALA_EXTERN gpointer foo_entry4_ref (gpointer instance);
VALA_EXTERN void foo_entry4_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_foo_entry4 (const gchar* name,
                                   const gchar* nick,
                                   const gchar* blurb,
                                   GType object_type,
                                   GParamFlags flags);
VALA_EXTERN void value_set_foo_entry4 (GValue* value,
                           gpointer v_object);
VALA_EXTERN void value_take_foo_entry4 (GValue* value,
                            gpointer v_object);
VALA_EXTERN gpointer value_get_foo_entry4 (const GValue* value);
VALA_EXTERN GType foo_entry4_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FooEntry4, foo_entry4_unref)
VALA_EXTERN FooEntry4* foo_entry4_new (GType k_type,
                           GBoxedCopyFunc k_dup_func,
                           GDestroyNotify k_destroy_func,
                           GType v_type,
                           GBoxedCopyFunc v_dup_func,
                           GDestroyNotify v_destroy_func,
                           gconstpointer _key,
                           gconstpointer _value);
VALA_EXTERN FooEntry4* foo_entry4_construct (GType object_type,
                                 GType k_type,
                                 GBoxedCopyFunc k_dup_func,
                                 GDestroyNotify k_destroy_func,
                                 GType v_type,
                                 GBoxedCopyFunc v_dup_func,
                                 GDestroyNotify v_destroy_func,
                                 gconstpointer _key,
                                 gconstpointer _value);
static void foo_entry4_set_key (FooEntry4* self,
                         gconstpointer value);
static void foo_entry4_set_value (FooEntry4* self,
                           gconstpointer value);
VALA_EXTERN gconstpointer foo_entry4_get_key (FooEntry4* self);
VALA_EXTERN gconstpointer foo_entry4_get_value (FooEntry4* self);
static void foo_entry4_finalize (FooEntry4 * obj);
static GType foo_entry4_get_type_once (void);
VALA_EXTERN gpointer foo_iterator4_ref (gpointer instance);
VALA_EXTERN void foo_iterator4_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_foo_iterator4 (const gchar* name,
                                      const gchar* nick,
                                      const gchar* blurb,
                                      GType object_type,
                                      GParamFlags flags);
VALA_EXTERN void value_set_foo_iterator4 (GValue* value,
                              gpointer v_object);
VALA_EXTERN void value_take_foo_iterator4 (GValue* value,
                               gpointer v_object);
VALA_EXTERN gpointer value_get_foo_iterator4 (const GValue* value);
VALA_EXTERN GType foo_iterator4_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FooIterator4, foo_iterator4_unref)
VALA_EXTERN gboolean foo_iterator4_next (FooIterator4* self);
VALA_EXTERN gpointer foo_iterator4_get (FooIterator4* self);
VALA_EXTERN FooIterator4* foo_iterator4_new (GType g_type,
                                 GBoxedCopyFunc g_dup_func,
                                 GDestroyNotify g_destroy_func);
VALA_EXTERN FooIterator4* foo_iterator4_construct (GType object_type,
                                       GType g_type,
                                       GBoxedCopyFunc g_dup_func,
                                       GDestroyNotify g_destroy_func);
static void foo_iterator4_finalize (FooIterator4 * obj);
static GType foo_iterator4_get_type_once (void);
VALA_EXTERN gpointer foo_collection4_ref (gpointer instance);
VALA_EXTERN void foo_collection4_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_foo_collection4 (const gchar* name,
                                        const gchar* nick,
                                        const gchar* blurb,
                                        GType object_type,
                                        GParamFlags flags);
VALA_EXTERN void value_set_foo_collection4 (GValue* value,
                                gpointer v_object);
VALA_EXTERN void value_take_foo_collection4 (GValue* value,
                                 gpointer v_object);
VALA_EXTERN gpointer value_get_foo_collection4 (const GValue* value);
VALA_EXTERN GType foo_collection4_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FooCollection4, foo_collection4_unref)
VALA_EXTERN gpointer foo_collection4_get (FooCollection4* self,
                              gconstpointer key);
VALA_EXTERN FooIterator4* foo_collection4_iterator (FooCollection4* self);
VALA_EXTERN FooCollection4* foo_collection4_new (GType k_type,
                                     GBoxedCopyFunc k_dup_func,
                                     GDestroyNotify k_destroy_func,
                                     GType v_type,
                                     GBoxedCopyFunc v_dup_func,
                                     GDestroyNotify v_destroy_func);
VALA_EXTERN FooCollection4* foo_collection4_construct (GType object_type,
                                           GType k_type,
                                           GBoxedCopyFunc k_dup_func,
                                           GDestroyNotify k_destroy_func,
                                           GType v_type,
                                           GBoxedCopyFunc v_dup_func,
                                           GDestroyNotify v_destroy_func);
VALA_EXTERN gint foo_collection4_get_size (FooCollection4* self);
static void foo_collection4_finalize (FooCollection4 * obj);
static GType foo_collection4_get_type_once (void);
static void _vala_main (void);
static void _foo_unref0_ (gpointer var);
static inline void _g_slist_free__foo_unref0_ (GSList* self);
static inline void _g_list_free__foo_unref0_ (GList* self);

Foo*
foo_construct (GType object_type)
{
	Foo* self = NULL;
	self = (Foo*) g_type_create_instance (object_type);
	return self;
}

Foo*
foo_new (void)
{
	return foo_construct (TYPE_FOO);
}

static void
value_foo_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_foo_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		foo_unref (value->data[0].v_pointer);
	}
}

static void
value_foo_copy_value (const GValue* src_value,
                      GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = foo_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_foo_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_foo_collect_value (GValue* value,
                         guint n_collect_values,
                         GTypeCValue* collect_values,
                         guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		Foo * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = foo_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_foo_lcopy_value (const GValue* value,
                       guint n_collect_values,
                       GTypeCValue* collect_values,
                       guint collect_flags)
{
	Foo ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = foo_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_foo (const gchar* name,
                const gchar* nick,
                const gchar* blurb,
                GType object_type,
                GParamFlags flags)
{
	ParamSpecFoo* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_FOO), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_foo (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO), NULL);
	return value->data[0].v_pointer;
}

void
value_set_foo (GValue* value,
               gpointer v_object)
{
	Foo * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FOO));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		foo_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		foo_unref (old);
	}
}

void
value_take_foo (GValue* value,
                gpointer v_object)
{
	Foo * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FOO));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		foo_unref (old);
	}
}

static void
foo_class_init (FooClass * klass,
                gpointer klass_data)
{
	foo_parent_class = g_type_class_peek_parent (klass);
	((FooClass *) klass)->finalize = foo_finalize;
}

static void
foo_instance_init (Foo * self,
                   gpointer klass)
{
	self->ref_count = 1;
}

static void
foo_finalize (Foo * obj)
{
	Foo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FOO, Foo);
	g_signal_handlers_destroy (self);
}

static GType
foo_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_foo_init, value_foo_free_value, value_foo_copy_value, value_foo_peek_pointer, "p", value_foo_collect_value, "p", value_foo_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (FooClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) foo_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Foo), 0, (GInstanceInitFunc) foo_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType foo_type_id;
	foo_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Foo", &g_define_type_info, &g_define_type_fundamental_info, 0);
	return foo_type_id;
}

GType
foo_get_type (void)
{
	static volatile gsize foo_type_id__once = 0;
	if (g_once_init_enter (&foo_type_id__once)) {
		GType foo_type_id;
		foo_type_id = foo_get_type_once ();
		g_once_init_leave (&foo_type_id__once, foo_type_id);
	}
	return foo_type_id__once;
}

gpointer
foo_ref (gpointer instance)
{
	Foo * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
foo_unref (gpointer instance)
{
	Foo * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		FOO_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static inline gpointer
foo_iterator_get_instance_private (FooIterator* self)
{
	return G_STRUCT_MEMBER_P (self, FooIterator_private_offset);
}

gboolean
foo_iterator_next (FooIterator* self)
{
	gboolean result;
	g_return_val_if_fail (IS_FOO_ITERATOR (self), FALSE);
	result = !self->priv->called;
	return result;
}

static gpointer
_foo_ref0 (gpointer self)
{
	return self ? foo_ref (self) : NULL;
}

Foo*
foo_iterator_get (FooIterator* self)
{
	Foo* _tmp0_;
	Foo* _tmp1_;
	Foo* result;
	g_return_val_if_fail (IS_FOO_ITERATOR (self), NULL);
	_vala_assert (!self->priv->called, "!called");
	self->priv->called = TRUE;
	_tmp0_ = foo_instance;
	_tmp1_ = _foo_ref0 (_tmp0_);
	result = _tmp1_;
	return result;
}

FooIterator*
foo_iterator_construct (GType object_type)
{
	FooIterator* self = NULL;
	self = (FooIterator*) g_type_create_instance (object_type);
	return self;
}

FooIterator*
foo_iterator_new (void)
{
	return foo_iterator_construct (TYPE_FOO_ITERATOR);
}

static void
value_foo_iterator_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_foo_iterator_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		foo_iterator_unref (value->data[0].v_pointer);
	}
}

static void
value_foo_iterator_copy_value (const GValue* src_value,
                               GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = foo_iterator_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_foo_iterator_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_foo_iterator_collect_value (GValue* value,
                                  guint n_collect_values,
                                  GTypeCValue* collect_values,
                                  guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		FooIterator * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = foo_iterator_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_foo_iterator_lcopy_value (const GValue* value,
                                guint n_collect_values,
                                GTypeCValue* collect_values,
                                guint collect_flags)
{
	FooIterator ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = foo_iterator_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_foo_iterator (const gchar* name,
                         const gchar* nick,
                         const gchar* blurb,
                         GType object_type,
                         GParamFlags flags)
{
	ParamSpecFooIterator* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_FOO_ITERATOR), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_foo_iterator (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_ITERATOR), NULL);
	return value->data[0].v_pointer;
}

void
value_set_foo_iterator (GValue* value,
                        gpointer v_object)
{
	FooIterator * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_ITERATOR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FOO_ITERATOR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		foo_iterator_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		foo_iterator_unref (old);
	}
}

void
value_take_foo_iterator (GValue* value,
                         gpointer v_object)
{
	FooIterator * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_ITERATOR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FOO_ITERATOR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		foo_iterator_unref (old);
	}
}

static void
foo_iterator_class_init (FooIteratorClass * klass,
                         gpointer klass_data)
{
	foo_iterator_parent_class = g_type_class_peek_parent (klass);
	((FooIteratorClass *) klass)->finalize = foo_iterator_finalize;
	g_type_class_adjust_private_offset (klass, &FooIterator_private_offset);
}

static void
foo_iterator_instance_init (FooIterator * self,
                            gpointer klass)
{
	self->priv = foo_iterator_get_instance_private (self);
	self->priv->called = FALSE;
	self->ref_count = 1;
}

static void
foo_iterator_finalize (FooIterator * obj)
{
	FooIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FOO_ITERATOR, FooIterator);
	g_signal_handlers_destroy (self);
}

static GType
foo_iterator_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_foo_iterator_init, value_foo_iterator_free_value, value_foo_iterator_copy_value, value_foo_iterator_peek_pointer, "p", value_foo_iterator_collect_value, "p", value_foo_iterator_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (FooIteratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) foo_iterator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FooIterator), 0, (GInstanceInitFunc) foo_iterator_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType foo_iterator_type_id;
	foo_iterator_type_id = g_type_register_fundamental (g_type_fundamental_next (), "FooIterator", &g_define_type_info, &g_define_type_fundamental_info, 0);
	FooIterator_private_offset = g_type_add_instance_private (foo_iterator_type_id, sizeof (FooIteratorPrivate));
	return foo_iterator_type_id;
}

GType
foo_iterator_get_type (void)
{
	static volatile gsize foo_iterator_type_id__once = 0;
	if (g_once_init_enter (&foo_iterator_type_id__once)) {
		GType foo_iterator_type_id;
		foo_iterator_type_id = foo_iterator_get_type_once ();
		g_once_init_leave (&foo_iterator_type_id__once, foo_iterator_type_id);
	}
	return foo_iterator_type_id__once;
}

gpointer
foo_iterator_ref (gpointer instance)
{
	FooIterator * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
foo_iterator_unref (gpointer instance)
{
	FooIterator * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		FOO_ITERATOR_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

FooIterator*
foo_collection_iterator (FooCollection* self)
{
	FooIterator* _tmp0_;
	FooIterator* result;
	g_return_val_if_fail (IS_FOO_COLLECTION (self), NULL);
	_tmp0_ = foo_iterator_new ();
	result = _tmp0_;
	return result;
}

FooCollection*
foo_collection_construct (GType object_type)
{
	FooCollection* self = NULL;
	self = (FooCollection*) g_type_create_instance (object_type);
	return self;
}

FooCollection*
foo_collection_new (void)
{
	return foo_collection_construct (TYPE_FOO_COLLECTION);
}

static void
value_foo_collection_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_foo_collection_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		foo_collection_unref (value->data[0].v_pointer);
	}
}

static void
value_foo_collection_copy_value (const GValue* src_value,
                                 GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = foo_collection_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_foo_collection_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_foo_collection_collect_value (GValue* value,
                                    guint n_collect_values,
                                    GTypeCValue* collect_values,
                                    guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		FooCollection * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = foo_collection_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_foo_collection_lcopy_value (const GValue* value,
                                  guint n_collect_values,
                                  GTypeCValue* collect_values,
                                  guint collect_flags)
{
	FooCollection ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = foo_collection_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_foo_collection (const gchar* name,
                           const gchar* nick,
                           const gchar* blurb,
                           GType object_type,
                           GParamFlags flags)
{
	ParamSpecFooCollection* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_FOO_COLLECTION), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_foo_collection (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_COLLECTION), NULL);
	return value->data[0].v_pointer;
}

void
value_set_foo_collection (GValue* value,
                          gpointer v_object)
{
	FooCollection * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_COLLECTION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FOO_COLLECTION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		foo_collection_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		foo_collection_unref (old);
	}
}

void
value_take_foo_collection (GValue* value,
                           gpointer v_object)
{
	FooCollection * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_COLLECTION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FOO_COLLECTION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		foo_collection_unref (old);
	}
}

static void
foo_collection_class_init (FooCollectionClass * klass,
                           gpointer klass_data)
{
	foo_collection_parent_class = g_type_class_peek_parent (klass);
	((FooCollectionClass *) klass)->finalize = foo_collection_finalize;
}

static void
foo_collection_instance_init (FooCollection * self,
                              gpointer klass)
{
	self->ref_count = 1;
}

static void
foo_collection_finalize (FooCollection * obj)
{
	FooCollection * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FOO_COLLECTION, FooCollection);
	g_signal_handlers_destroy (self);
}

static GType
foo_collection_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_foo_collection_init, value_foo_collection_free_value, value_foo_collection_copy_value, value_foo_collection_peek_pointer, "p", value_foo_collection_collect_value, "p", value_foo_collection_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (FooCollectionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) foo_collection_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FooCollection), 0, (GInstanceInitFunc) foo_collection_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType foo_collection_type_id;
	foo_collection_type_id = g_type_register_fundamental (g_type_fundamental_next (), "FooCollection", &g_define_type_info, &g_define_type_fundamental_info, 0);
	return foo_collection_type_id;
}

GType
foo_collection_get_type (void)
{
	static volatile gsize foo_collection_type_id__once = 0;
	if (g_once_init_enter (&foo_collection_type_id__once)) {
		GType foo_collection_type_id;
		foo_collection_type_id = foo_collection_get_type_once ();
		g_once_init_leave (&foo_collection_type_id__once, foo_collection_type_id);
	}
	return foo_collection_type_id__once;
}

gpointer
foo_collection_ref (gpointer instance)
{
	FooCollection * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
foo_collection_unref (gpointer instance)
{
	FooCollection * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		FOO_COLLECTION_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static inline gpointer
foo_iterator2_get_instance_private (FooIterator2* self)
{
	return G_STRUCT_MEMBER_P (self, FooIterator2_private_offset);
}

Foo*
foo_iterator2_next_value (FooIterator2* self)
{
	Foo* _tmp0_;
	Foo* _tmp1_;
	Foo* result;
	g_return_val_if_fail (IS_FOO_ITERATOR2 (self), NULL);
	if (self->priv->called) {
		result = NULL;
		return result;
	}
	self->priv->called = TRUE;
	_tmp0_ = foo_instance;
	_tmp1_ = _foo_ref0 (_tmp0_);
	result = _tmp1_;
	return result;
}

FooIterator2*
foo_iterator2_construct (GType object_type)
{
	FooIterator2* self = NULL;
	self = (FooIterator2*) g_type_create_instance (object_type);
	return self;
}

FooIterator2*
foo_iterator2_new (void)
{
	return foo_iterator2_construct (TYPE_FOO_ITERATOR2);
}

static void
value_foo_iterator2_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_foo_iterator2_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		foo_iterator2_unref (value->data[0].v_pointer);
	}
}

static void
value_foo_iterator2_copy_value (const GValue* src_value,
                                GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = foo_iterator2_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_foo_iterator2_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_foo_iterator2_collect_value (GValue* value,
                                   guint n_collect_values,
                                   GTypeCValue* collect_values,
                                   guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		FooIterator2 * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = foo_iterator2_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_foo_iterator2_lcopy_value (const GValue* value,
                                 guint n_collect_values,
                                 GTypeCValue* collect_values,
                                 guint collect_flags)
{
	FooIterator2 ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = foo_iterator2_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_foo_iterator2 (const gchar* name,
                          const gchar* nick,
                          const gchar* blurb,
                          GType object_type,
                          GParamFlags flags)
{
	ParamSpecFooIterator2* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_FOO_ITERATOR2), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_foo_iterator2 (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_ITERATOR2), NULL);
	return value->data[0].v_pointer;
}

void
value_set_foo_iterator2 (GValue* value,
                         gpointer v_object)
{
	FooIterator2 * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_ITERATOR2));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FOO_ITERATOR2));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		foo_iterator2_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		foo_iterator2_unref (old);
	}
}

void
value_take_foo_iterator2 (GValue* value,
                          gpointer v_object)
{
	FooIterator2 * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_ITERATOR2));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FOO_ITERATOR2));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		foo_iterator2_unref (old);
	}
}

static void
foo_iterator2_class_init (FooIterator2Class * klass,
                          gpointer klass_data)
{
	foo_iterator2_parent_class = g_type_class_peek_parent (klass);
	((FooIterator2Class *) klass)->finalize = foo_iterator2_finalize;
	g_type_class_adjust_private_offset (klass, &FooIterator2_private_offset);
}

static void
foo_iterator2_instance_init (FooIterator2 * self,
                             gpointer klass)
{
	self->priv = foo_iterator2_get_instance_private (self);
	self->priv->called = FALSE;
	self->ref_count = 1;
}

static void
foo_iterator2_finalize (FooIterator2 * obj)
{
	FooIterator2 * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FOO_ITERATOR2, FooIterator2);
	g_signal_handlers_destroy (self);
}

static GType
foo_iterator2_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_foo_iterator2_init, value_foo_iterator2_free_value, value_foo_iterator2_copy_value, value_foo_iterator2_peek_pointer, "p", value_foo_iterator2_collect_value, "p", value_foo_iterator2_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (FooIterator2Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) foo_iterator2_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FooIterator2), 0, (GInstanceInitFunc) foo_iterator2_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType foo_iterator2_type_id;
	foo_iterator2_type_id = g_type_register_fundamental (g_type_fundamental_next (), "FooIterator2", &g_define_type_info, &g_define_type_fundamental_info, 0);
	FooIterator2_private_offset = g_type_add_instance_private (foo_iterator2_type_id, sizeof (FooIterator2Private));
	return foo_iterator2_type_id;
}

GType
foo_iterator2_get_type (void)
{
	static volatile gsize foo_iterator2_type_id__once = 0;
	if (g_once_init_enter (&foo_iterator2_type_id__once)) {
		GType foo_iterator2_type_id;
		foo_iterator2_type_id = foo_iterator2_get_type_once ();
		g_once_init_leave (&foo_iterator2_type_id__once, foo_iterator2_type_id);
	}
	return foo_iterator2_type_id__once;
}

gpointer
foo_iterator2_ref (gpointer instance)
{
	FooIterator2 * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
foo_iterator2_unref (gpointer instance)
{
	FooIterator2 * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		FOO_ITERATOR2_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

FooIterator2*
foo_collection2_iterator (FooCollection2* self)
{
	FooIterator2* _tmp0_;
	FooIterator2* result;
	g_return_val_if_fail (IS_FOO_COLLECTION2 (self), NULL);
	_tmp0_ = foo_iterator2_new ();
	result = _tmp0_;
	return result;
}

FooCollection2*
foo_collection2_construct (GType object_type)
{
	FooCollection2* self = NULL;
	self = (FooCollection2*) g_type_create_instance (object_type);
	return self;
}

FooCollection2*
foo_collection2_new (void)
{
	return foo_collection2_construct (TYPE_FOO_COLLECTION2);
}

static void
value_foo_collection2_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_foo_collection2_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		foo_collection2_unref (value->data[0].v_pointer);
	}
}

static void
value_foo_collection2_copy_value (const GValue* src_value,
                                  GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = foo_collection2_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_foo_collection2_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_foo_collection2_collect_value (GValue* value,
                                     guint n_collect_values,
                                     GTypeCValue* collect_values,
                                     guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		FooCollection2 * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = foo_collection2_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_foo_collection2_lcopy_value (const GValue* value,
                                   guint n_collect_values,
                                   GTypeCValue* collect_values,
                                   guint collect_flags)
{
	FooCollection2 ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = foo_collection2_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_foo_collection2 (const gchar* name,
                            const gchar* nick,
                            const gchar* blurb,
                            GType object_type,
                            GParamFlags flags)
{
	ParamSpecFooCollection2* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_FOO_COLLECTION2), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_foo_collection2 (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_COLLECTION2), NULL);
	return value->data[0].v_pointer;
}

void
value_set_foo_collection2 (GValue* value,
                           gpointer v_object)
{
	FooCollection2 * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_COLLECTION2));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FOO_COLLECTION2));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		foo_collection2_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		foo_collection2_unref (old);
	}
}

void
value_take_foo_collection2 (GValue* value,
                            gpointer v_object)
{
	FooCollection2 * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_COLLECTION2));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FOO_COLLECTION2));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		foo_collection2_unref (old);
	}
}

static void
foo_collection2_class_init (FooCollection2Class * klass,
                            gpointer klass_data)
{
	foo_collection2_parent_class = g_type_class_peek_parent (klass);
	((FooCollection2Class *) klass)->finalize = foo_collection2_finalize;
}

static void
foo_collection2_instance_init (FooCollection2 * self,
                               gpointer klass)
{
	self->ref_count = 1;
}

static void
foo_collection2_finalize (FooCollection2 * obj)
{
	FooCollection2 * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FOO_COLLECTION2, FooCollection2);
	g_signal_handlers_destroy (self);
}

static GType
foo_collection2_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_foo_collection2_init, value_foo_collection2_free_value, value_foo_collection2_copy_value, value_foo_collection2_peek_pointer, "p", value_foo_collection2_collect_value, "p", value_foo_collection2_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (FooCollection2Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) foo_collection2_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FooCollection2), 0, (GInstanceInitFunc) foo_collection2_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType foo_collection2_type_id;
	foo_collection2_type_id = g_type_register_fundamental (g_type_fundamental_next (), "FooCollection2", &g_define_type_info, &g_define_type_fundamental_info, 0);
	return foo_collection2_type_id;
}

GType
foo_collection2_get_type (void)
{
	static volatile gsize foo_collection2_type_id__once = 0;
	if (g_once_init_enter (&foo_collection2_type_id__once)) {
		GType foo_collection2_type_id;
		foo_collection2_type_id = foo_collection2_get_type_once ();
		g_once_init_leave (&foo_collection2_type_id__once, foo_collection2_type_id);
	}
	return foo_collection2_type_id__once;
}

gpointer
foo_collection2_ref (gpointer instance)
{
	FooCollection2 * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
foo_collection2_unref (gpointer instance)
{
	FooCollection2 * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		FOO_COLLECTION2_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

Foo*
foo_collection3_get (FooCollection3* self,
                     gint index)
{
	Foo* _tmp0_;
	Foo* _tmp1_;
	Foo* result;
	g_return_val_if_fail (IS_FOO_COLLECTION3 (self), NULL);
	_vala_assert (index == 0, "index == 0");
	_tmp0_ = foo_instance;
	_tmp1_ = _foo_ref0 (_tmp0_);
	result = _tmp1_;
	return result;
}

FooCollection3*
foo_collection3_construct (GType object_type)
{
	FooCollection3* self = NULL;
	self = (FooCollection3*) g_type_create_instance (object_type);
	return self;
}

FooCollection3*
foo_collection3_new (void)
{
	return foo_collection3_construct (TYPE_FOO_COLLECTION3);
}

gint
foo_collection3_get_size (FooCollection3* self)
{
	gint result;
	g_return_val_if_fail (IS_FOO_COLLECTION3 (self), 0);
	result = 1;
	return result;
}

static void
value_foo_collection3_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_foo_collection3_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		foo_collection3_unref (value->data[0].v_pointer);
	}
}

static void
value_foo_collection3_copy_value (const GValue* src_value,
                                  GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = foo_collection3_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_foo_collection3_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_foo_collection3_collect_value (GValue* value,
                                     guint n_collect_values,
                                     GTypeCValue* collect_values,
                                     guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		FooCollection3 * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = foo_collection3_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_foo_collection3_lcopy_value (const GValue* value,
                                   guint n_collect_values,
                                   GTypeCValue* collect_values,
                                   guint collect_flags)
{
	FooCollection3 ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = foo_collection3_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_foo_collection3 (const gchar* name,
                            const gchar* nick,
                            const gchar* blurb,
                            GType object_type,
                            GParamFlags flags)
{
	ParamSpecFooCollection3* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_FOO_COLLECTION3), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_foo_collection3 (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_COLLECTION3), NULL);
	return value->data[0].v_pointer;
}

void
value_set_foo_collection3 (GValue* value,
                           gpointer v_object)
{
	FooCollection3 * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_COLLECTION3));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FOO_COLLECTION3));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		foo_collection3_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		foo_collection3_unref (old);
	}
}

void
value_take_foo_collection3 (GValue* value,
                            gpointer v_object)
{
	FooCollection3 * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_COLLECTION3));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FOO_COLLECTION3));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		foo_collection3_unref (old);
	}
}

static void
foo_collection3_class_init (FooCollection3Class * klass,
                            gpointer klass_data)
{
	foo_collection3_parent_class = g_type_class_peek_parent (klass);
	((FooCollection3Class *) klass)->finalize = foo_collection3_finalize;
}

static void
foo_collection3_instance_init (FooCollection3 * self,
                               gpointer klass)
{
	self->ref_count = 1;
}

static void
foo_collection3_finalize (FooCollection3 * obj)
{
	FooCollection3 * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FOO_COLLECTION3, FooCollection3);
	g_signal_handlers_destroy (self);
}

static GType
foo_collection3_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_foo_collection3_init, value_foo_collection3_free_value, value_foo_collection3_copy_value, value_foo_collection3_peek_pointer, "p", value_foo_collection3_collect_value, "p", value_foo_collection3_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (FooCollection3Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) foo_collection3_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FooCollection3), 0, (GInstanceInitFunc) foo_collection3_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType foo_collection3_type_id;
	foo_collection3_type_id = g_type_register_fundamental (g_type_fundamental_next (), "FooCollection3", &g_define_type_info, &g_define_type_fundamental_info, 0);
	return foo_collection3_type_id;
}

GType
foo_collection3_get_type (void)
{
	static volatile gsize foo_collection3_type_id__once = 0;
	if (g_once_init_enter (&foo_collection3_type_id__once)) {
		GType foo_collection3_type_id;
		foo_collection3_type_id = foo_collection3_get_type_once ();
		g_once_init_leave (&foo_collection3_type_id__once, foo_collection3_type_id);
	}
	return foo_collection3_type_id__once;
}

gpointer
foo_collection3_ref (gpointer instance)
{
	FooCollection3 * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
foo_collection3_unref (gpointer instance)
{
	FooCollection3 * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		FOO_COLLECTION3_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static inline gpointer
foo_entry4_get_instance_private (FooEntry4* self)
{
	return G_STRUCT_MEMBER_P (self, FooEntry4_private_offset);
}

FooEntry4*
foo_entry4_construct (GType object_type,
                      GType k_type,
                      GBoxedCopyFunc k_dup_func,
                      GDestroyNotify k_destroy_func,
                      GType v_type,
                      GBoxedCopyFunc v_dup_func,
                      GDestroyNotify v_destroy_func,
                      gconstpointer _key,
                      gconstpointer _value)
{
	FooEntry4* self = NULL;
	self = (FooEntry4*) g_type_create_instance (object_type);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	foo_entry4_set_key (self, _key);
	foo_entry4_set_value (self, _value);
	return self;
}

FooEntry4*
foo_entry4_new (GType k_type,
                GBoxedCopyFunc k_dup_func,
                GDestroyNotify k_destroy_func,
                GType v_type,
                GBoxedCopyFunc v_dup_func,
                GDestroyNotify v_destroy_func,
                gconstpointer _key,
                gconstpointer _value)
{
	return foo_entry4_construct (TYPE_FOO_ENTRY4, k_type, k_dup_func, k_destroy_func, v_type, v_dup_func, v_destroy_func, _key, _value);
}

gconstpointer
foo_entry4_get_key (FooEntry4* self)
{
	gconstpointer result;
	gconstpointer _tmp0_;
	g_return_val_if_fail (IS_FOO_ENTRY4 (self), NULL);
	_tmp0_ = self->priv->_key;
	result = _tmp0_;
	return result;
}

static void
foo_entry4_set_key (FooEntry4* self,
                    gconstpointer value)
{
	gpointer _tmp0_;
	g_return_if_fail (IS_FOO_ENTRY4 (self));
	_tmp0_ = ((value != NULL) && (self->priv->k_dup_func != NULL)) ? self->priv->k_dup_func ((gpointer) value) : ((gpointer) value);
	((self->priv->_key == NULL) || (self->priv->k_destroy_func == NULL)) ? NULL : (self->priv->_key = (self->priv->k_destroy_func (self->priv->_key), NULL));
	self->priv->_key = _tmp0_;
}

gconstpointer
foo_entry4_get_value (FooEntry4* self)
{
	gconstpointer result;
	gconstpointer _tmp0_;
	g_return_val_if_fail (IS_FOO_ENTRY4 (self), NULL);
	_tmp0_ = self->priv->_value;
	result = _tmp0_;
	return result;
}

static void
foo_entry4_set_value (FooEntry4* self,
                      gconstpointer value)
{
	gpointer _tmp0_;
	g_return_if_fail (IS_FOO_ENTRY4 (self));
	_tmp0_ = ((value != NULL) && (self->priv->v_dup_func != NULL)) ? self->priv->v_dup_func ((gpointer) value) : ((gpointer) value);
	((self->priv->_value == NULL) || (self->priv->v_destroy_func == NULL)) ? NULL : (self->priv->_value = (self->priv->v_destroy_func (self->priv->_value), NULL));
	self->priv->_value = _tmp0_;
}

static void
value_foo_entry4_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_foo_entry4_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		foo_entry4_unref (value->data[0].v_pointer);
	}
}

static void
value_foo_entry4_copy_value (const GValue* src_value,
                             GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = foo_entry4_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_foo_entry4_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_foo_entry4_collect_value (GValue* value,
                                guint n_collect_values,
                                GTypeCValue* collect_values,
                                guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		FooEntry4 * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = foo_entry4_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_foo_entry4_lcopy_value (const GValue* value,
                              guint n_collect_values,
                              GTypeCValue* collect_values,
                              guint collect_flags)
{
	FooEntry4 ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = foo_entry4_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_foo_entry4 (const gchar* name,
                       const gchar* nick,
                       const gchar* blurb,
                       GType object_type,
                       GParamFlags flags)
{
	ParamSpecFooEntry4* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_FOO_ENTRY4), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_foo_entry4 (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_ENTRY4), NULL);
	return value->data[0].v_pointer;
}

void
value_set_foo_entry4 (GValue* value,
                      gpointer v_object)
{
	FooEntry4 * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_ENTRY4));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FOO_ENTRY4));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		foo_entry4_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		foo_entry4_unref (old);
	}
}

void
value_take_foo_entry4 (GValue* value,
                       gpointer v_object)
{
	FooEntry4 * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_ENTRY4));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FOO_ENTRY4));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		foo_entry4_unref (old);
	}
}

static void
foo_entry4_class_init (FooEntry4Class * klass,
                       gpointer klass_data)
{
	foo_entry4_parent_class = g_type_class_peek_parent (klass);
	((FooEntry4Class *) klass)->finalize = foo_entry4_finalize;
	g_type_class_adjust_private_offset (klass, &FooEntry4_private_offset);
}

static void
foo_entry4_instance_init (FooEntry4 * self,
                          gpointer klass)
{
	self->priv = foo_entry4_get_instance_private (self);
	self->ref_count = 1;
}

static void
foo_entry4_finalize (FooEntry4 * obj)
{
	FooEntry4 * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FOO_ENTRY4, FooEntry4);
	g_signal_handlers_destroy (self);
	((self->priv->_key == NULL) || (self->priv->k_destroy_func == NULL)) ? NULL : (self->priv->_key = (self->priv->k_destroy_func (self->priv->_key), NULL));
	((self->priv->_value == NULL) || (self->priv->v_destroy_func == NULL)) ? NULL : (self->priv->_value = (self->priv->v_destroy_func (self->priv->_value), NULL));
}

static GType
foo_entry4_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_foo_entry4_init, value_foo_entry4_free_value, value_foo_entry4_copy_value, value_foo_entry4_peek_pointer, "p", value_foo_entry4_collect_value, "p", value_foo_entry4_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (FooEntry4Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) foo_entry4_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FooEntry4), 0, (GInstanceInitFunc) foo_entry4_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType foo_entry4_type_id;
	foo_entry4_type_id = g_type_register_fundamental (g_type_fundamental_next (), "FooEntry4", &g_define_type_info, &g_define_type_fundamental_info, 0);
	FooEntry4_private_offset = g_type_add_instance_private (foo_entry4_type_id, sizeof (FooEntry4Private));
	return foo_entry4_type_id;
}

GType
foo_entry4_get_type (void)
{
	static volatile gsize foo_entry4_type_id__once = 0;
	if (g_once_init_enter (&foo_entry4_type_id__once)) {
		GType foo_entry4_type_id;
		foo_entry4_type_id = foo_entry4_get_type_once ();
		g_once_init_leave (&foo_entry4_type_id__once, foo_entry4_type_id);
	}
	return foo_entry4_type_id__once;
}

gpointer
foo_entry4_ref (gpointer instance)
{
	FooEntry4 * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
foo_entry4_unref (gpointer instance)
{
	FooEntry4 * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		FOO_ENTRY4_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static inline gpointer
foo_iterator4_get_instance_private (FooIterator4* self)
{
	return G_STRUCT_MEMBER_P (self, FooIterator4_private_offset);
}

gboolean
foo_iterator4_next (FooIterator4* self)
{
	gboolean result;
	g_return_val_if_fail (IS_FOO_ITERATOR4 (self), FALSE);
	result = !self->priv->called;
	return result;
}

gpointer
foo_iterator4_get (FooIterator4* self)
{
	Foo* _tmp0_;
	FooEntry4* _tmp1_;
	gpointer result;
	g_return_val_if_fail (IS_FOO_ITERATOR4 (self), NULL);
	_vala_assert (!self->priv->called, "!called");
	self->priv->called = TRUE;
	_tmp0_ = foo_instance;
	_tmp1_ = foo_entry4_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, TYPE_FOO, (GBoxedCopyFunc) foo_ref, (GDestroyNotify) foo_unref, "foo", _tmp0_);
	result = _tmp1_;
	return result;
}

FooIterator4*
foo_iterator4_construct (GType object_type,
                         GType g_type,
                         GBoxedCopyFunc g_dup_func,
                         GDestroyNotify g_destroy_func)
{
	FooIterator4* self = NULL;
	self = (FooIterator4*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	return self;
}

FooIterator4*
foo_iterator4_new (GType g_type,
                   GBoxedCopyFunc g_dup_func,
                   GDestroyNotify g_destroy_func)
{
	return foo_iterator4_construct (TYPE_FOO_ITERATOR4, g_type, g_dup_func, g_destroy_func);
}

static void
value_foo_iterator4_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_foo_iterator4_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		foo_iterator4_unref (value->data[0].v_pointer);
	}
}

static void
value_foo_iterator4_copy_value (const GValue* src_value,
                                GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = foo_iterator4_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_foo_iterator4_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_foo_iterator4_collect_value (GValue* value,
                                   guint n_collect_values,
                                   GTypeCValue* collect_values,
                                   guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		FooIterator4 * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = foo_iterator4_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_foo_iterator4_lcopy_value (const GValue* value,
                                 guint n_collect_values,
                                 GTypeCValue* collect_values,
                                 guint collect_flags)
{
	FooIterator4 ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = foo_iterator4_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_foo_iterator4 (const gchar* name,
                          const gchar* nick,
                          const gchar* blurb,
                          GType object_type,
                          GParamFlags flags)
{
	ParamSpecFooIterator4* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_FOO_ITERATOR4), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_foo_iterator4 (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_ITERATOR4), NULL);
	return value->data[0].v_pointer;
}

void
value_set_foo_iterator4 (GValue* value,
                         gpointer v_object)
{
	FooIterator4 * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_ITERATOR4));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FOO_ITERATOR4));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		foo_iterator4_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		foo_iterator4_unref (old);
	}
}

void
value_take_foo_iterator4 (GValue* value,
                          gpointer v_object)
{
	FooIterator4 * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_ITERATOR4));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FOO_ITERATOR4));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		foo_iterator4_unref (old);
	}
}

static void
foo_iterator4_class_init (FooIterator4Class * klass,
                          gpointer klass_data)
{
	foo_iterator4_parent_class = g_type_class_peek_parent (klass);
	((FooIterator4Class *) klass)->finalize = foo_iterator4_finalize;
	g_type_class_adjust_private_offset (klass, &FooIterator4_private_offset);
}

static void
foo_iterator4_instance_init (FooIterator4 * self,
                             gpointer klass)
{
	self->priv = foo_iterator4_get_instance_private (self);
	self->priv->called = FALSE;
	self->ref_count = 1;
}

static void
foo_iterator4_finalize (FooIterator4 * obj)
{
	FooIterator4 * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FOO_ITERATOR4, FooIterator4);
	g_signal_handlers_destroy (self);
}

static GType
foo_iterator4_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_foo_iterator4_init, value_foo_iterator4_free_value, value_foo_iterator4_copy_value, value_foo_iterator4_peek_pointer, "p", value_foo_iterator4_collect_value, "p", value_foo_iterator4_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (FooIterator4Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) foo_iterator4_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FooIterator4), 0, (GInstanceInitFunc) foo_iterator4_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType foo_iterator4_type_id;
	foo_iterator4_type_id = g_type_register_fundamental (g_type_fundamental_next (), "FooIterator4", &g_define_type_info, &g_define_type_fundamental_info, 0);
	FooIterator4_private_offset = g_type_add_instance_private (foo_iterator4_type_id, sizeof (FooIterator4Private));
	return foo_iterator4_type_id;
}

GType
foo_iterator4_get_type (void)
{
	static volatile gsize foo_iterator4_type_id__once = 0;
	if (g_once_init_enter (&foo_iterator4_type_id__once)) {
		GType foo_iterator4_type_id;
		foo_iterator4_type_id = foo_iterator4_get_type_once ();
		g_once_init_leave (&foo_iterator4_type_id__once, foo_iterator4_type_id);
	}
	return foo_iterator4_type_id__once;
}

gpointer
foo_iterator4_ref (gpointer instance)
{
	FooIterator4 * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
foo_iterator4_unref (gpointer instance)
{
	FooIterator4 * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		FOO_ITERATOR4_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static inline gpointer
foo_collection4_get_instance_private (FooCollection4* self)
{
	return G_STRUCT_MEMBER_P (self, FooCollection4_private_offset);
}

gpointer
foo_collection4_get (FooCollection4* self,
                     gconstpointer key)
{
	Foo* _tmp0_;
	gpointer _tmp1_;
	gpointer result;
	g_return_val_if_fail (IS_FOO_COLLECTION4 (self), NULL);
	_vala_assert (g_strcmp0 (key, "foo") == 0, "key == \"foo\"");
	_tmp0_ = foo_instance;
	_tmp1_ = ((_tmp0_ != NULL) && (self->priv->v_dup_func != NULL)) ? self->priv->v_dup_func ((gpointer) _tmp0_) : ((gpointer) _tmp0_);
	result = _tmp1_;
	return result;
}

FooIterator4*
foo_collection4_iterator (FooCollection4* self)
{
	FooIterator4* _tmp0_;
	FooIterator4* result;
	g_return_val_if_fail (IS_FOO_COLLECTION4 (self), NULL);
	_tmp0_ = foo_iterator4_new (TYPE_FOO_ENTRY4, (GBoxedCopyFunc) foo_entry4_ref, (GDestroyNotify) foo_entry4_unref);
	result = _tmp0_;
	return result;
}

FooCollection4*
foo_collection4_construct (GType object_type,
                           GType k_type,
                           GBoxedCopyFunc k_dup_func,
                           GDestroyNotify k_destroy_func,
                           GType v_type,
                           GBoxedCopyFunc v_dup_func,
                           GDestroyNotify v_destroy_func)
{
	FooCollection4* self = NULL;
	self = (FooCollection4*) g_type_create_instance (object_type);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	return self;
}

FooCollection4*
foo_collection4_new (GType k_type,
                     GBoxedCopyFunc k_dup_func,
                     GDestroyNotify k_destroy_func,
                     GType v_type,
                     GBoxedCopyFunc v_dup_func,
                     GDestroyNotify v_destroy_func)
{
	return foo_collection4_construct (TYPE_FOO_COLLECTION4, k_type, k_dup_func, k_destroy_func, v_type, v_dup_func, v_destroy_func);
}

gint
foo_collection4_get_size (FooCollection4* self)
{
	gint result;
	g_return_val_if_fail (IS_FOO_COLLECTION4 (self), 0);
	result = 1;
	return result;
}

static void
value_foo_collection4_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_foo_collection4_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		foo_collection4_unref (value->data[0].v_pointer);
	}
}

static void
value_foo_collection4_copy_value (const GValue* src_value,
                                  GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = foo_collection4_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_foo_collection4_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_foo_collection4_collect_value (GValue* value,
                                     guint n_collect_values,
                                     GTypeCValue* collect_values,
                                     guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		FooCollection4 * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = foo_collection4_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_foo_collection4_lcopy_value (const GValue* value,
                                   guint n_collect_values,
                                   GTypeCValue* collect_values,
                                   guint collect_flags)
{
	FooCollection4 ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = foo_collection4_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_foo_collection4 (const gchar* name,
                            const gchar* nick,
                            const gchar* blurb,
                            GType object_type,
                            GParamFlags flags)
{
	ParamSpecFooCollection4* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_FOO_COLLECTION4), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_foo_collection4 (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_COLLECTION4), NULL);
	return value->data[0].v_pointer;
}

void
value_set_foo_collection4 (GValue* value,
                           gpointer v_object)
{
	FooCollection4 * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_COLLECTION4));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FOO_COLLECTION4));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		foo_collection4_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		foo_collection4_unref (old);
	}
}

void
value_take_foo_collection4 (GValue* value,
                            gpointer v_object)
{
	FooCollection4 * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FOO_COLLECTION4));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FOO_COLLECTION4));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		foo_collection4_unref (old);
	}
}

static void
foo_collection4_class_init (FooCollection4Class * klass,
                            gpointer klass_data)
{
	foo_collection4_parent_class = g_type_class_peek_parent (klass);
	((FooCollection4Class *) klass)->finalize = foo_collection4_finalize;
	g_type_class_adjust_private_offset (klass, &FooCollection4_private_offset);
}

static void
foo_collection4_instance_init (FooCollection4 * self,
                               gpointer klass)
{
	self->priv = foo_collection4_get_instance_private (self);
	self->ref_count = 1;
}

static void
foo_collection4_finalize (FooCollection4 * obj)
{
	FooCollection4 * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FOO_COLLECTION4, FooCollection4);
	g_signal_handlers_destroy (self);
}

static GType
foo_collection4_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_foo_collection4_init, value_foo_collection4_free_value, value_foo_collection4_copy_value, value_foo_collection4_peek_pointer, "p", value_foo_collection4_collect_value, "p", value_foo_collection4_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (FooCollection4Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) foo_collection4_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FooCollection4), 0, (GInstanceInitFunc) foo_collection4_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType foo_collection4_type_id;
	foo_collection4_type_id = g_type_register_fundamental (g_type_fundamental_next (), "FooCollection4", &g_define_type_info, &g_define_type_fundamental_info, 0);
	FooCollection4_private_offset = g_type_add_instance_private (foo_collection4_type_id, sizeof (FooCollection4Private));
	return foo_collection4_type_id;
}

GType
foo_collection4_get_type (void)
{
	static volatile gsize foo_collection4_type_id__once = 0;
	if (g_once_init_enter (&foo_collection4_type_id__once)) {
		GType foo_collection4_type_id;
		foo_collection4_type_id = foo_collection4_get_type_once ();
		g_once_init_leave (&foo_collection4_type_id__once, foo_collection4_type_id);
	}
	return foo_collection4_type_id__once;
}

gpointer
foo_collection4_ref (gpointer instance)
{
	FooCollection4 * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
foo_collection4_unref (gpointer instance)
{
	FooCollection4 * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		FOO_COLLECTION4_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static void
_foo_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (foo_unref (var), NULL));
}

static inline void
_g_slist_free__foo_unref0_ (GSList* self)
{
	g_slist_free_full (self, (GDestroyNotify) _foo_unref0_);
}

static inline void
_g_list_free__foo_unref0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _foo_unref0_);
}

static void
_vala_main (void)
{
	Foo* _tmp0_;
	FooCollection* collection = NULL;
	FooCollection* _tmp1_;
	FooCollection2* collection2 = NULL;
	FooCollection2* _tmp9_;
	FooCollection3* collection3 = NULL;
	FooCollection3* _tmp17_;
	FooCollection4* collection4 = NULL;
	FooCollection4* _tmp28_;
	FooCollection4* _tmp41_;
	gpointer _tmp42_;
	Foo* _tmp43_;
	Foo* _tmp44_;
	GList* list = NULL;
	Foo* _tmp45_;
	Foo* _tmp46_;
	GList* _tmp47_;
	GSList* slist = NULL;
	Foo* _tmp51_;
	Foo* _tmp52_;
	GSList* _tmp53_;
	_tmp0_ = foo_new ();
	_foo_unref0 (foo_instance);
	foo_instance = _tmp0_;
	_tmp1_ = foo_collection_new ();
	collection = _tmp1_;
	{
		FooIterator* _foo_it = NULL;
		FooCollection* _tmp2_;
		FooIterator* _tmp3_;
		_tmp2_ = collection;
		_tmp3_ = foo_collection_iterator (_tmp2_);
		_foo_it = _tmp3_;
		while (TRUE) {
			FooIterator* _tmp4_;
			Foo* foo = NULL;
			FooIterator* _tmp5_;
			Foo* _tmp6_;
			Foo* _tmp7_;
			Foo* _tmp8_;
			_tmp4_ = _foo_it;
			if (!foo_iterator_next (_tmp4_)) {
				break;
			}
			_tmp5_ = _foo_it;
			_tmp6_ = foo_iterator_get (_tmp5_);
			foo = _tmp6_;
			_tmp7_ = foo;
			_tmp8_ = foo_instance;
			_vala_assert (_tmp7_ == _tmp8_, "foo == foo_instance");
			_foo_unref0 (foo);
		}
		_foo_iterator_unref0 (_foo_it);
	}
	_tmp9_ = foo_collection2_new ();
	collection2 = _tmp9_;
	{
		FooIterator2* _foo2_it = NULL;
		FooCollection2* _tmp10_;
		FooIterator2* _tmp11_;
		Foo* foo2 = NULL;
		_tmp10_ = collection2;
		_tmp11_ = foo_collection2_iterator (_tmp10_);
		_foo2_it = _tmp11_;
		while (TRUE) {
			FooIterator2* _tmp12_;
			Foo* _tmp13_;
			Foo* _tmp14_;
			Foo* _tmp15_;
			Foo* _tmp16_;
			_tmp12_ = _foo2_it;
			_tmp13_ = foo_iterator2_next_value (_tmp12_);
			_foo_unref0 (foo2);
			foo2 = _tmp13_;
			_tmp14_ = foo2;
			if (!(_tmp14_ != NULL)) {
				break;
			}
			_tmp15_ = foo2;
			_tmp16_ = foo_instance;
			_vala_assert (_tmp15_ == _tmp16_, "foo2 == foo_instance");
		}
		_foo_unref0 (foo2);
		_foo_iterator2_unref0 (_foo2_it);
	}
	_tmp17_ = foo_collection3_new ();
	collection3 = _tmp17_;
	{
		FooCollection3* _foo3_list = NULL;
		FooCollection3* _tmp18_;
		gint _foo3_size = 0;
		FooCollection3* _tmp19_;
		gint _tmp20_;
		gint _tmp21_;
		gint _foo3_index = 0;
		_tmp18_ = collection3;
		_foo3_list = _tmp18_;
		_tmp19_ = _foo3_list;
		_tmp20_ = foo_collection3_get_size (_tmp19_);
		_tmp21_ = _tmp20_;
		_foo3_size = _tmp21_;
		_foo3_index = -1;
		while (TRUE) {
			gint _tmp22_;
			gint _tmp23_;
			Foo* foo3 = NULL;
			FooCollection3* _tmp24_;
			Foo* _tmp25_;
			Foo* _tmp26_;
			Foo* _tmp27_;
			_foo3_index = _foo3_index + 1;
			_tmp22_ = _foo3_index;
			_tmp23_ = _foo3_size;
			if (!(_tmp22_ < _tmp23_)) {
				break;
			}
			_tmp24_ = _foo3_list;
			_tmp25_ = foo_collection3_get (_tmp24_, _foo3_index);
			foo3 = _tmp25_;
			_tmp26_ = foo3;
			_tmp27_ = foo_instance;
			_vala_assert (_tmp26_ == _tmp27_, "foo3 == foo_instance");
			_foo_unref0 (foo3);
		}
	}
	_tmp28_ = foo_collection4_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, TYPE_FOO, (GBoxedCopyFunc) foo_ref, (GDestroyNotify) foo_unref);
	collection4 = _tmp28_;
	{
		FooIterator4* _fooentry4_it = NULL;
		FooCollection4* _tmp29_;
		FooIterator4* _tmp30_;
		_tmp29_ = collection4;
		_tmp30_ = foo_collection4_iterator (_tmp29_);
		_fooentry4_it = _tmp30_;
		while (TRUE) {
			FooIterator4* _tmp31_;
			FooEntry4* fooentry4 = NULL;
			FooIterator4* _tmp32_;
			gpointer _tmp33_;
			FooEntry4* _tmp34_;
			gconstpointer _tmp35_;
			gconstpointer _tmp36_;
			FooEntry4* _tmp37_;
			gconstpointer _tmp38_;
			gconstpointer _tmp39_;
			Foo* _tmp40_;
			_tmp31_ = _fooentry4_it;
			if (!foo_iterator4_next (_tmp31_)) {
				break;
			}
			_tmp32_ = _fooentry4_it;
			_tmp33_ = foo_iterator4_get (_tmp32_);
			fooentry4 = (FooEntry4*) _tmp33_;
			_tmp34_ = fooentry4;
			_tmp35_ = foo_entry4_get_key (_tmp34_);
			_tmp36_ = _tmp35_;
			_vala_assert (g_strcmp0 ((const gchar*) _tmp36_, "foo") == 0, "fooentry4.key == \"foo\"");
			_tmp37_ = fooentry4;
			_tmp38_ = foo_entry4_get_value (_tmp37_);
			_tmp39_ = _tmp38_;
			_tmp40_ = foo_instance;
			_vala_assert (((Foo*) _tmp39_) == _tmp40_, "fooentry4.value == foo_instance");
			_foo_entry4_unref0 (fooentry4);
		}
		_foo_iterator4_unref0 (_fooentry4_it);
	}
	_tmp41_ = collection4;
	_tmp42_ = foo_collection4_get (_tmp41_, "foo");
	_tmp43_ = (Foo*) _tmp42_;
	_tmp44_ = foo_instance;
	_vala_assert (_tmp43_ == _tmp44_, "collection4[\"foo\"] == foo_instance");
	_foo_unref0 (_tmp43_);
	list = NULL;
	_tmp45_ = foo_instance;
	_tmp46_ = _foo_ref0 (_tmp45_);
	list = g_list_append (list, _tmp46_);
	_tmp47_ = list;
	{
		GList* e_collection = NULL;
		GList* e_it = NULL;
		e_collection = _tmp47_;
		for (e_it = e_collection; e_it != NULL; e_it = e_it->next) {
			Foo* _tmp48_;
			Foo* e = NULL;
			_tmp48_ = _foo_ref0 ((Foo*) e_it->data);
			e = _tmp48_;
			{
				Foo* _tmp49_;
				Foo* _tmp50_;
				_tmp49_ = e;
				_tmp50_ = foo_instance;
				_vala_assert (_tmp49_ == _tmp50_, "e == foo_instance");
				_foo_unref0 (e);
			}
		}
	}
	slist = NULL;
	_tmp51_ = foo_instance;
	_tmp52_ = _foo_ref0 (_tmp51_);
	slist = g_slist_append (slist, _tmp52_);
	_tmp53_ = slist;
	{
		GSList* e_collection = NULL;
		GSList* e_it = NULL;
		e_collection = _tmp53_;
		for (e_it = e_collection; e_it != NULL; e_it = e_it->next) {
			Foo* _tmp54_;
			Foo* e = NULL;
			_tmp54_ = _foo_ref0 ((Foo*) e_it->data);
			e = _tmp54_;
			{
				Foo* _tmp55_;
				Foo* _tmp56_;
				_tmp55_ = e;
				_tmp56_ = foo_instance;
				_vala_assert (_tmp55_ == _tmp56_, "e == foo_instance");
				_foo_unref0 (e);
			}
		}
	}
	(slist == NULL) ? NULL : (slist = (_g_slist_free__foo_unref0_ (slist), NULL));
	(list == NULL) ? NULL : (list = (_g_list_free__foo_unref0_ (list), NULL));
	_foo_collection4_unref0 (collection4);
	_foo_collection3_unref0 (collection3);
	_foo_collection2_unref0 (collection2);
	_foo_collection_unref0 (collection);
}

int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}

