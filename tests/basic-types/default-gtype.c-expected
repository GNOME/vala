/* basic_types_default_gtype.c generated by valac, the Vala compiler
 * generated from basic_types_default_gtype.vala, do not modify */

#include <glib-object.h>
#include <glib.h>
#include <string.h>
#include <float.h>
#include <math.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_IFOO (ifoo_get_type ())
#define IFOO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IFOO, IFoo))
#define IS_IFOO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IFOO))
#define IFOO_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IFOO, IFooIface))

typedef struct _IFoo IFoo;
typedef struct _IFooIface IFooIface;
typedef enum  {
	FOO_ENUM_FOO
} FooEnum;

#define TYPE_FOO_ENUM (foo_enum_get_type ())
typedef enum  {
	FOO_FLAG_FOO = 1 << 0
} FooFlag;

#define TYPE_FOO_FLAG (foo_flag_get_type ())

#define TYPE_FOO_ERROR (foo_error_get_type ())

#define TYPE_FOO_STRUCT (foo_struct_get_type ())
typedef struct _FooStruct FooStruct;
typedef enum  {
	BAR_ENUM_BAR
} BarEnum;

typedef enum  {
	BAR_FLAG_BAR = 1 << 0
} BarFlag;

typedef struct _BarStruct BarStruct;
typedef struct _ManamStruct ManamStruct;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _IFooIface {
	GTypeInterface parent_iface;
};

typedef enum  {
	FOO_ERROR_FAIL
} FooError;
#define FOO_ERROR foo_error_quark ()

struct _FooStruct {
	gint i;
};

struct _BarStruct {
	gint i;
};

struct _ManamStruct {
	gint i;
};

VALA_EXTERN GType ifoo_get_type (void) G_GNUC_CONST ;
static GType ifoo_get_type_once (void);
VALA_EXTERN GType foo_enum_get_type (void) G_GNUC_CONST ;
VALA_EXTERN GType foo_flag_get_type (void) G_GNUC_CONST ;
VALA_EXTERN GQuark foo_error_quark (void);
VALA_EXTERN GType foo_error_get_type (void) G_GNUC_CONST ;
VALA_EXTERN GType foo_struct_get_type (void) G_GNUC_CONST ;
VALA_EXTERN FooStruct* foo_struct_dup (const FooStruct* self);
VALA_EXTERN void foo_struct_free (FooStruct* self);
VALA_EXTERN BarStruct* bar_struct_dup (const BarStruct* self);
VALA_EXTERN void bar_struct_free (BarStruct* self);
static void _vala_main (void);

static void
ifoo_default_init (IFooIface * iface,
                   gpointer iface_data)
{
}

static GType
ifoo_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (IFooIface), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ifoo_default_init, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
	GType ifoo_type_id;
	ifoo_type_id = g_type_register_static (G_TYPE_INTERFACE, "IFoo", &g_define_type_info, 0);
	return ifoo_type_id;
}

GType
ifoo_get_type (void)
{
	static volatile gsize ifoo_type_id__once = 0;
	if (g_once_init_enter (&ifoo_type_id__once)) {
		GType ifoo_type_id;
		ifoo_type_id = ifoo_get_type_once ();
		g_once_init_leave (&ifoo_type_id__once, ifoo_type_id);
	}
	return ifoo_type_id__once;
}

static GType
foo_enum_get_type_once (void)
{
	static const GEnumValue values[] = {{FOO_ENUM_FOO, "FOO_ENUM_FOO", "foo"}, {0, NULL, NULL}};
	GType foo_enum_type_id;
	foo_enum_type_id = g_enum_register_static ("FooEnum", values);
	return foo_enum_type_id;
}

GType
foo_enum_get_type (void)
{
	static volatile gsize foo_enum_type_id__once = 0;
	if (g_once_init_enter (&foo_enum_type_id__once)) {
		GType foo_enum_type_id;
		foo_enum_type_id = foo_enum_get_type_once ();
		g_once_init_leave (&foo_enum_type_id__once, foo_enum_type_id);
	}
	return foo_enum_type_id__once;
}

static GType
foo_flag_get_type_once (void)
{
	static const GFlagsValue values[] = {{FOO_FLAG_FOO, "FOO_FLAG_FOO", "foo"}, {0, NULL, NULL}};
	GType foo_flag_type_id;
	foo_flag_type_id = g_flags_register_static ("FooFlag", values);
	return foo_flag_type_id;
}

GType
foo_flag_get_type (void)
{
	static volatile gsize foo_flag_type_id__once = 0;
	if (g_once_init_enter (&foo_flag_type_id__once)) {
		GType foo_flag_type_id;
		foo_flag_type_id = foo_flag_get_type_once ();
		g_once_init_leave (&foo_flag_type_id__once, foo_flag_type_id);
	}
	return foo_flag_type_id__once;
}

GQuark
foo_error_quark (void)
{
	return g_quark_from_static_string ("foo-error-quark");
}

static GType
foo_error_get_type_once (void)
{
	static const GEnumValue values[] = {{FOO_ERROR_FAIL, "FOO_ERROR_FAIL", "fail"}, {0, NULL, NULL}};
	GType foo_error_type_id;
	foo_error_type_id = g_enum_register_static ("FooError", values);
	return foo_error_type_id;
}

GType
foo_error_get_type (void)
{
	static volatile gsize foo_error_type_id__once = 0;
	if (g_once_init_enter (&foo_error_type_id__once)) {
		GType foo_error_type_id;
		foo_error_type_id = foo_error_get_type_once ();
		g_once_init_leave (&foo_error_type_id__once, foo_error_type_id);
	}
	return foo_error_type_id__once;
}

FooStruct*
foo_struct_dup (const FooStruct* self)
{
	FooStruct* dup;
	dup = g_new0 (FooStruct, 1);
	memcpy (dup, self, sizeof (FooStruct));
	return dup;
}

void
foo_struct_free (FooStruct* self)
{
	g_free (self);
}

static GType
foo_struct_get_type_once (void)
{
	GType foo_struct_type_id;
	foo_struct_type_id = g_boxed_type_register_static ("FooStruct", (GBoxedCopyFunc) foo_struct_dup, (GBoxedFreeFunc) foo_struct_free);
	return foo_struct_type_id;
}

GType
foo_struct_get_type (void)
{
	static volatile gsize foo_struct_type_id__once = 0;
	if (g_once_init_enter (&foo_struct_type_id__once)) {
		GType foo_struct_type_id;
		foo_struct_type_id = foo_struct_get_type_once ();
		g_once_init_leave (&foo_struct_type_id__once, foo_struct_type_id);
	}
	return foo_struct_type_id__once;
}

BarStruct*
bar_struct_dup (const BarStruct* self)
{
	BarStruct* dup;
	dup = g_new0 (BarStruct, 1);
	memcpy (dup, self, sizeof (BarStruct));
	return dup;
}

void
bar_struct_free (BarStruct* self)
{
	g_free (self);
}

static void
_vala_main (void)
{
	_vala_assert (G_TYPE_BOOLEAN == G_TYPE_BOOLEAN, "typeof (bool) == GLib.Type.BOOLEAN");
	_vala_assert (g_type_is_a (TYPE_FOO_STRUCT, G_TYPE_BOXED), "typeof (FooStruct).is_a (GLib.Type.BOXED)");
	_vala_assert (G_TYPE_CHAR == G_TYPE_CHAR, "typeof (char) == GLib.Type.CHAR");
	_vala_assert (G_TYPE_DOUBLE == G_TYPE_DOUBLE, "typeof (double) == GLib.Type.DOUBLE");
	_vala_assert (g_type_is_a (TYPE_FOO_ENUM, G_TYPE_ENUM), "typeof (FooEnum).is_a (GLib.Type.ENUM)");
	_vala_assert (G_TYPE_ERROR == G_TYPE_ERROR, "typeof (FooError) == G_TYPE_ERROR");
	_vala_assert (g_type_is_a (TYPE_FOO_FLAG, G_TYPE_FLAGS), "typeof (FooFlag).is_a (GLib.Type.FLAGS)");
	_vala_assert (G_TYPE_FLOAT == G_TYPE_FLOAT, "typeof (float) == GLib.Type.FLOAT");
	_vala_assert (G_TYPE_INT == G_TYPE_INT, "typeof (int) == GLib.Type.INT");
	_vala_assert (G_TYPE_INT64 == G_TYPE_INT64, "typeof (int64) == GLib.Type.INT64");
	_vala_assert (g_type_is_a (TYPE_IFOO, G_TYPE_INTERFACE), "typeof (IFoo).is_a (GLib.Type.INTERFACE)");
	_vala_assert (G_TYPE_INVALID == G_TYPE_INVALID, "typeof (IFoo[]) == GLib.Type.INVALID");
	_vala_assert (G_TYPE_LONG == G_TYPE_LONG, "typeof (long) == GLib.Type.LONG");
	_vala_assert (G_TYPE_NONE == G_TYPE_NONE, "typeof (void) == GLib.Type.NONE");
	_vala_assert (G_TYPE_OBJECT == G_TYPE_OBJECT, "typeof (Object) == GLib.Type.OBJECT");
	_vala_assert (G_TYPE_PARAM == G_TYPE_PARAM, "typeof (ParamSpec) == GLib.Type.PARAM");
	_vala_assert (G_TYPE_POINTER == G_TYPE_POINTER, "typeof (void*) == GLib.Type.POINTER");
	_vala_assert (G_TYPE_STRING == G_TYPE_STRING, "typeof (string) == GLib.Type.STRING");
	_vala_assert (G_TYPE_STRV == G_TYPE_STRV, "typeof (string[]) == G_TYPE_STRV");
	_vala_assert (G_TYPE_UCHAR == G_TYPE_UCHAR, "typeof (uchar) == GLib.Type.UCHAR");
	_vala_assert (G_TYPE_UINT == G_TYPE_UINT, "typeof (uint) == GLib.Type.UINT");
	_vala_assert (G_TYPE_UINT64 == G_TYPE_UINT64, "typeof (uint64) == GLib.Type.UINT64");
	_vala_assert (G_TYPE_ULONG == G_TYPE_ULONG, "typeof (ulong) == GLib.Type.ULONG");
	_vala_assert (G_TYPE_VARIANT == G_TYPE_VARIANT, "typeof (Variant) == GLib.Type.VARIANT");
	_vala_assert (G_TYPE_INT == G_TYPE_INT, "typeof (BarEnum) == GLib.Type.INT");
	_vala_assert (G_TYPE_UINT == G_TYPE_UINT, "typeof (BarFlag) == GLib.Type.UINT");
	_vala_assert (G_TYPE_POINTER == G_TYPE_POINTER, "typeof (BarStruct) == GLib.Type.POINTER");
	_vala_assert (G_TYPE_INVALID == G_TYPE_INVALID, "typeof (ManamStruct) == GLib.Type.INVALID");
}

int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}

