/* basic_types_floats.c generated by valac, the Vala compiler
 * generated from basic_types_floats.vala, do not modify */

#include <glib.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define _g_free0(var) ((var == NULL) ? NULL : (var = (g_free (var), NULL)))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

VALA_EXTERN void test_double (void);
static gdouble* _double_dup (gdouble* self);
static gboolean _double_equal (const gdouble * s1,
                        const gdouble * s2);
VALA_EXTERN void test_float (void);
static gfloat* _float_dup (gfloat* self);
static gboolean _float_equal (const gfloat * s1,
                       const gfloat * s2);
static void _vala_main (void);

static gchar*
double_to_string (gdouble self)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	gint _tmp1__length1;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* result;
	_tmp0_ = g_new0 (gchar, G_ASCII_DTOSTR_BUF_SIZE);
	_tmp1_ = _tmp0_;
	_tmp1__length1 = G_ASCII_DTOSTR_BUF_SIZE;
	_tmp2_ = g_ascii_dtostr (_tmp1_, (gint) G_ASCII_DTOSTR_BUF_SIZE, self);
	_tmp3_ = g_strdup (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp1_ = (g_free (_tmp1_), NULL);
	result = _tmp4_;
	return result;
}

static gdouble
double_parse (const gchar* str)
{
	gdouble result;
	g_return_val_if_fail (str != NULL, -1.0);
	result = g_ascii_strtod (str, NULL);
	return result;
}

static gboolean
double_try_parse (const gchar* str,
                  gdouble* _result_,
                  const gchar** unparsed)
{
	gdouble _vala__result_ = 0.0;
	const gchar* _vala_unparsed = NULL;
	gchar* endptr = NULL;
	gchar* _tmp0_ = NULL;
	gdouble _tmp1_;
	gchar* _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	gboolean result;
	g_return_val_if_fail (str != NULL, FALSE);
	errno = 0;
	_tmp1_ = g_ascii_strtod (str, &_tmp0_);
	endptr = _tmp0_;
	_vala__result_ = _tmp1_;
	_tmp2_ = endptr;
	_tmp3_ = strlen (str);
	_tmp4_ = _tmp3_;
	if (_tmp2_ == (((gchar*) str) + _tmp4_)) {
		_vala_unparsed = "";
		result = errno != ERANGE;
		if (_result_) {
			*_result_ = _vala__result_;
		}
		if (unparsed) {
			*unparsed = _vala_unparsed;
		}
		return result;
	} else {
		gchar* _tmp5_;
		_tmp5_ = endptr;
		_vala_unparsed = (const gchar*) _tmp5_;
		result = FALSE;
		if (_result_) {
			*_result_ = _vala__result_;
		}
		if (unparsed) {
			*unparsed = _vala_unparsed;
		}
		return result;
	}
}

static gdouble*
_double_dup (gdouble* self)
{
	gdouble* dup;
	dup = g_new0 (gdouble, 1);
	memcpy (dup, self, sizeof (gdouble));
	return dup;
}

static gpointer
__double_dup0 (gpointer self)
{
	return self ? _double_dup (self) : NULL;
}

static gboolean
_double_equal (const gdouble * s1,
               const gdouble * s2)
{
	if (s1 == s2) {
		return TRUE;
	}
	if (s1 == NULL) {
		return FALSE;
	}
	if (s2 == NULL) {
		return FALSE;
	}
	return (*s1) == (*s2);
}

void
test_double (void)
{
	gdouble d = 0.0;
	gdouble e = 0.0;
	gchar* s = NULL;
	gchar* _tmp0_;
	const gchar* unparsed = NULL;
	gdouble _tmp1_ = 0.0;
	const gchar* _tmp2_ = NULL;
	gdouble* d2 = NULL;
	gdouble _tmp3_;
	gdouble* _tmp4_;
	gdouble _tmp5_;
	d = 42.;
	_vala_assert (d == 42., "d == 42d");
	d = 23.;
	_vala_assert (d == 23., "d == 23d");
	e = d;
	_vala_assert (e == 23., "e == 23d");
	d = 1.0E-5;
	_vala_assert (d == 0.00001, "d == 0.00001");
	d = 1.0E+4;
	_vala_assert (d == 10000.0, "d == 10000.0");
	d = 42. + 23.;
	_vala_assert (d == 65., "d == 65d");
	d = 42. - 23.;
	_vala_assert (d == 19., "d == 19d");
	d = 42. * 23.;
	_vala_assert (d == 966., "d == 966d");
	d = 42. / 23.;
	_vala_assert (d > 1.8, "d > 1.8");
	_vala_assert (d < 1.9, "d < 1.9");
	d = 42.;
	_vala_assert (d == 42., "d == 42d");
	_vala_assert (d != 50., "d != 50d");
	_vala_assert (d < 42.5, "d < 42.5");
	_vala_assert (!(d < 41.5), "!(d < 41.5)");
	_vala_assert (d <= 42., "d <= 42d");
	_vala_assert (!(d <= 41.5), "!(d <= 41.5)");
	_vala_assert (d >= 42., "d >= 42d");
	_vala_assert (!(d >= 42.5), "!(d >= 42.5)");
	_vala_assert (d > 41.5, "d > 41.5");
	_vala_assert (!(d > 42.5), "!(d > 42.5)");
	_tmp0_ = double_to_string (d);
	s = _tmp0_;
	_vala_assert (g_strcmp0 (s, "42") == 0, "s == \"42\"");
	d = double_parse ("47.11mm");
	_vala_assert (d == 47.11, "d == 47.11");
	double_try_parse ("3.45mm", &_tmp1_, &_tmp2_);
	d = _tmp1_;
	unparsed = _tmp2_;
	_vala_assert (d == 3.45, "d == 3.45");
	_vala_assert (g_strcmp0 (unparsed, "mm") == 0, "unparsed == \"mm\"");
	d = DBL_MIN;
	_vala_assert (d == DBL_MIN, "d == double.MIN");
	_vala_assert (d < DBL_MAX, "d < double.MAX");
	d = DBL_MAX;
	_vala_assert (d == DBL_MAX, "d == double.MAX");
	_vala_assert (d > DBL_MIN, "d > double.MIN");
	_tmp3_ = (gdouble) 10;
	_tmp4_ = __double_dup0 (&_tmp3_);
	d2 = _tmp4_;
	_tmp5_ = (gdouble) 10;
	_vala_assert (_double_equal (d2, &_tmp5_) == TRUE, "d2 == 10");
	_g_free0 (d2);
	_g_free0 (s);
}

static gfloat
float_parse (const gchar* str)
{
	gfloat result;
	g_return_val_if_fail (str != NULL, -1.0F);
	result = strtof (str, NULL);
	return result;
}

static gboolean
float_try_parse (const gchar* str,
                 gfloat* _result_,
                 const gchar** unparsed)
{
	gfloat _vala__result_ = 0.0F;
	const gchar* _vala_unparsed = NULL;
	gchar* endptr = NULL;
	gchar* _tmp0_ = NULL;
	gfloat _tmp1_;
	gchar* _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	gboolean result;
	g_return_val_if_fail (str != NULL, FALSE);
	errno = 0;
	_tmp1_ = strtof (str, &_tmp0_);
	endptr = _tmp0_;
	_vala__result_ = _tmp1_;
	_tmp2_ = endptr;
	_tmp3_ = strlen (str);
	_tmp4_ = _tmp3_;
	if (_tmp2_ == (((gchar*) str) + _tmp4_)) {
		_vala_unparsed = "";
		result = errno != ERANGE;
		if (_result_) {
			*_result_ = _vala__result_;
		}
		if (unparsed) {
			*unparsed = _vala_unparsed;
		}
		return result;
	} else {
		gchar* _tmp5_;
		_tmp5_ = endptr;
		_vala_unparsed = (const gchar*) _tmp5_;
		result = FALSE;
		if (_result_) {
			*_result_ = _vala__result_;
		}
		if (unparsed) {
			*unparsed = _vala_unparsed;
		}
		return result;
	}
}

static gfloat*
_float_dup (gfloat* self)
{
	gfloat* dup;
	dup = g_new0 (gfloat, 1);
	memcpy (dup, self, sizeof (gfloat));
	return dup;
}

static gpointer
__float_dup0 (gpointer self)
{
	return self ? _float_dup (self) : NULL;
}

static gboolean
_float_equal (const gfloat * s1,
              const gfloat * s2)
{
	if (s1 == s2) {
		return TRUE;
	}
	if (s1 == NULL) {
		return FALSE;
	}
	if (s2 == NULL) {
		return FALSE;
	}
	return (*s1) == (*s2);
}

void
test_float (void)
{
	gfloat f = 0.0F;
	gfloat g = 0.0F;
	gchar* s = NULL;
	gchar* _tmp0_;
	const gchar* unparsed = NULL;
	gfloat _tmp1_ = 0.0F;
	const gchar* _tmp2_ = NULL;
	gfloat* f2 = NULL;
	gfloat _tmp3_;
	gfloat* _tmp4_;
	gfloat _tmp5_;
	f = 42.f;
	_vala_assert (f == 42.f, "f == 42f");
	f = 23.f;
	_vala_assert (f == 23.f, "f == 23f");
	g = f;
	_vala_assert (g == 23.f, "g == 23f");
	f = 42.f + 23.f;
	_vala_assert (f == 65.f, "f == 65f");
	f = 42.f - 23.f;
	_vala_assert (f == 19.f, "f == 19f");
	f = 42.f * 23.f;
	_vala_assert (f == 966.f, "f == 966f");
	f = 42.f / 23.f;
	_vala_assert (((gdouble) f) > 1.8, "f > 1.8");
	_vala_assert (((gdouble) f) < 1.9, "f < 1.9");
	f = 42.f;
	_vala_assert (f == 42.f, "f == 42f");
	_vala_assert (f != 50.f, "f != 50f");
	_vala_assert (f < 42.5f, "f < 42.5f");
	_vala_assert (!(f < 41.5f), "!(f < 41.5f)");
	_vala_assert (f <= 42.f, "f <= 42f");
	_vala_assert (!(f <= 41.5f), "!(f <= 41.5f)");
	_vala_assert (f >= 42.f, "f >= 42f");
	_vala_assert (!(f >= 42.5f), "!(f >= 42.5f)");
	_vala_assert (f > 41.5f, "f > 41.5f");
	_vala_assert (!(f > 42.5f), "!(f > 42.5f)");
	_tmp0_ = g_strdup_printf ("%g", f);
	s = _tmp0_;
	_vala_assert (g_strcmp0 (s, "42") == 0, "s == \"42\"");
	f = float_parse ("47.11mm");
	_vala_assert (f == 47.11f, "f == 47.11f");
	float_try_parse ("3.45mm", &_tmp1_, &_tmp2_);
	f = _tmp1_;
	unparsed = _tmp2_;
	_vala_assert (f == 3.45f, "f == 3.45f");
	_vala_assert (g_strcmp0 (unparsed, "mm") == 0, "unparsed == \"mm\"");
	f = FLT_MIN;
	_vala_assert (f == FLT_MIN, "f == float.MIN");
	_vala_assert (f < FLT_MAX, "f < float.MAX");
	f = FLT_MAX;
	_vala_assert (f == FLT_MAX, "f == float.MAX");
	_vala_assert (f > FLT_MIN, "f > float.MIN");
	_tmp3_ = 10.f;
	_tmp4_ = __float_dup0 (&_tmp3_);
	f2 = _tmp4_;
	_tmp5_ = 10.f;
	_vala_assert (_float_equal (f2, &_tmp5_) == TRUE, "f2 == 10f");
	_g_free0 (f2);
	_g_free0 (s);
}

static void
_vala_main (void)
{
	test_double ();
	test_float ();
}

int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}

