/* basic_types_glists.c generated by valac, the Vala compiler
 * generated from basic_types_glists.vala, do not modify */

#include <glib.h>
#include <stdlib.h>
#include <string.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

VALA_EXTERN void test_glist (void);
static void _g_free0_ (gpointer var);
static inline void _g_list_free__g_free0_ (GList* self);
VALA_EXTERN void test_gslist (void);
static inline void _g_slist_free__g_free0_ (GSList* self);
VALA_EXTERN void test_gqueue (void);
static inline void _g_queue_free__g_free0_ (GQueue* self);
VALA_EXTERN void test_gnode (void);
static gboolean _g_node_free_all_node (GNode* node,
                                GDestroyNotify free_func);
static void _g_node_free_all (GNode* self,
                       GDestroyNotify free_func);
static inline void _g_node_destroy__g_free0_ (GNode* self);
static void _vala_main (void);

static inline gboolean
vala_g_list_is_empty (GList* self)
{
	gboolean result;
	result = ((GList*) self) == NULL;
	return result;
}

static void
_g_free0_ (gpointer var)
{
	var = (g_free (var), NULL);
}

static inline void
_g_list_free__g_free0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_free0_);
}

void
test_glist (void)
{
	GList* list = NULL;
	GList* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	GList* _tmp3_;
	GList* _tmp4_;
	gconstpointer _tmp5_;
	GList* list2 = NULL;
	GList* _tmp6_;
	gconstpointer _tmp7_;
	list = NULL;
	_tmp0_ = list;
	_vala_assert (vala_g_list_is_empty (_tmp0_), "list.is_empty ()");
	_tmp1_ = g_strdup ("foo");
	list = g_list_prepend (list, _tmp1_);
	_tmp2_ = g_strdup ("bar");
	list = g_list_prepend (list, _tmp2_);
	_tmp3_ = list;
	_vala_assert (!vala_g_list_is_empty (_tmp3_), "!list.is_empty ()");
	_tmp4_ = list;
	_tmp5_ = g_list_nth_data (_tmp4_, (guint) 1);
	_vala_assert (g_strcmp0 ((const gchar*) _tmp5_, "foo") == 0, "list.nth_data (1) == \"foo\"");
	(list == NULL) ? NULL : (list = (_g_list_free__g_free0_ (list), NULL));
	list = NULL;
	list2 = NULL;
	list2 = g_list_prepend (list2, "foo");
	list2 = g_list_prepend (list2, "bar");
	_tmp6_ = list2;
	_tmp7_ = g_list_nth_data (_tmp6_, (guint) 1);
	_vala_assert (g_strcmp0 ((const gchar*) _tmp7_, "foo") == 0, "list2.nth_data (1) == \"foo\"");
	(list2 == NULL) ? NULL : (list2 = (g_list_free (list2), NULL));
	list2 = NULL;
	(list2 == NULL) ? NULL : (list2 = (g_list_free (list2), NULL));
	(list == NULL) ? NULL : (list = (_g_list_free__g_free0_ (list), NULL));
}

static inline gboolean
vala_g_slist_is_empty (GSList* self)
{
	gboolean result;
	result = ((GSList*) self) == NULL;
	return result;
}

static inline void
_g_slist_free__g_free0_ (GSList* self)
{
	g_slist_free_full (self, (GDestroyNotify) _g_free0_);
}

void
test_gslist (void)
{
	GSList* list = NULL;
	GSList* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	GSList* _tmp3_;
	GSList* _tmp4_;
	gconstpointer _tmp5_;
	GSList* list2 = NULL;
	GSList* _tmp6_;
	gconstpointer _tmp7_;
	list = NULL;
	_tmp0_ = list;
	_vala_assert (vala_g_slist_is_empty (_tmp0_), "list.is_empty ()");
	_tmp1_ = g_strdup ("foo");
	list = g_slist_prepend (list, _tmp1_);
	_tmp2_ = g_strdup ("bar");
	list = g_slist_prepend (list, _tmp2_);
	_tmp3_ = list;
	_vala_assert (!vala_g_slist_is_empty (_tmp3_), "!list.is_empty ()");
	_tmp4_ = list;
	_tmp5_ = g_slist_nth_data (_tmp4_, (guint) 1);
	_vala_assert (g_strcmp0 ((const gchar*) _tmp5_, "foo") == 0, "list.nth_data (1) == \"foo\"");
	(list == NULL) ? NULL : (list = (_g_slist_free__g_free0_ (list), NULL));
	list = NULL;
	list2 = NULL;
	list2 = g_slist_prepend (list2, "foo");
	list2 = g_slist_prepend (list2, "bar");
	_tmp6_ = list2;
	_tmp7_ = g_slist_nth_data (_tmp6_, (guint) 1);
	_vala_assert (g_strcmp0 ((const gchar*) _tmp7_, "foo") == 0, "list2.nth_data (1) == \"foo\"");
	(list2 == NULL) ? NULL : (list2 = (g_slist_free (list2), NULL));
	list2 = NULL;
	(list2 == NULL) ? NULL : (list2 = (g_slist_free (list2), NULL));
	(list == NULL) ? NULL : (list = (_g_slist_free__g_free0_ (list), NULL));
}

static inline void
_g_queue_free__g_free0_ (GQueue* self)
{
	g_queue_free_full (self, (GDestroyNotify) _g_free0_);
}

void
test_gqueue (void)
{
	GQueue* queue = NULL;
	GQueue* _tmp0_;
	GQueue* _tmp1_;
	GQueue* _tmp2_;
	gchar* _tmp3_;
	GQueue* _tmp4_;
	gchar* _tmp5_;
	GQueue* _tmp6_;
	GQueue* _tmp7_;
	gconstpointer _tmp8_;
	GQueue* queue2 = NULL;
	GQueue* _tmp9_;
	GQueue* _tmp10_;
	GQueue* _tmp11_;
	GQueue* _tmp12_;
	gconstpointer _tmp13_;
	_tmp0_ = g_queue_new ();
	queue = _tmp0_;
	_tmp1_ = queue;
	_vala_assert (g_queue_is_empty (_tmp1_), "queue.is_empty ()");
	_tmp2_ = queue;
	_tmp3_ = g_strdup ("foo");
	g_queue_push_head (_tmp2_, _tmp3_);
	_tmp4_ = queue;
	_tmp5_ = g_strdup ("bar");
	g_queue_push_head (_tmp4_, _tmp5_);
	_tmp6_ = queue;
	_vala_assert (!g_queue_is_empty (_tmp6_), "!queue.is_empty ()");
	_tmp7_ = queue;
	_tmp8_ = g_queue_peek_nth (_tmp7_, (guint) 1);
	_vala_assert (g_strcmp0 ((const gchar*) _tmp8_, "foo") == 0, "queue.peek_nth (1) == \"foo\"");
	(queue == NULL) ? NULL : (queue = (_g_queue_free__g_free0_ (queue), NULL));
	queue = NULL;
	_tmp9_ = g_queue_new ();
	queue2 = _tmp9_;
	_tmp10_ = queue2;
	g_queue_push_head (_tmp10_, "foo");
	_tmp11_ = queue2;
	g_queue_push_head (_tmp11_, "bar");
	_tmp12_ = queue2;
	_tmp13_ = g_queue_peek_nth (_tmp12_, (guint) 1);
	_vala_assert (g_strcmp0 ((const gchar*) _tmp13_, "foo") == 0, "queue2.peek_nth (1) == \"foo\"");
	(queue2 == NULL) ? NULL : (queue2 = (g_queue_free (queue2), NULL));
	queue2 = NULL;
	(queue2 == NULL) ? NULL : (queue2 = (g_queue_free (queue2), NULL));
	(queue == NULL) ? NULL : (queue = (_g_queue_free__g_free0_ (queue), NULL));
}

static gboolean
_g_node_free_all_node (GNode* node,
                       GDestroyNotify free_func)
{
	(node->data == NULL) ? NULL : free_func (node->data);
	return FALSE;
}

static void
_g_node_free_all (GNode* self,
                  GDestroyNotify free_func)
{
	(free_func == NULL) ? NULL : g_node_traverse (self, G_POST_ORDER, G_TRAVERSE_ALL, -1, (GNodeTraverseFunc) _g_node_free_all_node, free_func);
	g_node_destroy (self);
}

static inline void
_g_node_destroy__g_free0_ (GNode* self)
{
	_g_node_free_all (self, (GDestroyNotify) _g_free0_);
}

void
test_gnode (void)
{
	GNode* nodes = NULL;
	GNode* _tmp0_;
	GNode* _tmp1_;
	gchar* _tmp2_;
	GNode* _tmp3_;
	gchar* _tmp4_;
	GNode* _tmp5_;
	GNode* _tmp6_;
	gconstpointer _tmp7_;
	GNode* nodes2 = NULL;
	GNode* _tmp8_;
	GNode* _tmp9_;
	GNode* _tmp10_;
	GNode* _tmp11_;
	GNode* _tmp12_;
	gconstpointer _tmp13_;
	_tmp0_ = g_node_new (NULL);
	nodes = _tmp0_;
	_tmp1_ = nodes;
	_tmp2_ = g_strdup ("foo");
	g_node_append_data (_tmp1_, _tmp2_);
	_tmp3_ = nodes;
	_tmp4_ = g_strdup ("bar");
	g_node_append_data (_tmp3_, _tmp4_);
	_tmp5_ = nodes;
	_tmp6_ = g_node_nth_child (_tmp5_, (guint) 1);
	_tmp7_ = _tmp6_->data;
	_vala_assert (g_strcmp0 ((const gchar*) _tmp7_, "bar") == 0, "nodes.nth_child (1).data == \"bar\"");
	(nodes == NULL) ? NULL : (nodes = (_g_node_destroy__g_free0_ (nodes), NULL));
	nodes = NULL;
	_tmp8_ = g_node_new (NULL);
	nodes2 = _tmp8_;
	_tmp9_ = nodes2;
	g_node_append_data (_tmp9_, "foo");
	_tmp10_ = nodes2;
	g_node_append_data (_tmp10_, "bar");
	_tmp11_ = nodes2;
	_tmp12_ = g_node_nth_child (_tmp11_, (guint) 1);
	_tmp13_ = _tmp12_->data;
	_vala_assert (g_strcmp0 ((const gchar*) _tmp13_, "bar") == 0, "nodes2.nth_child (1).data == \"bar\"");
	(nodes2 == NULL) ? NULL : (nodes2 = (g_node_destroy (nodes2), NULL));
	nodes2 = NULL;
	(nodes2 == NULL) ? NULL : (nodes2 = (g_node_destroy (nodes2), NULL));
	(nodes == NULL) ? NULL : (nodes = (_g_node_destroy__g_free0_ (nodes), NULL));
}

static void
_vala_main (void)
{
	test_glist ();
	test_gslist ();
	test_gqueue ();
	test_gnode ();
}

int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}

