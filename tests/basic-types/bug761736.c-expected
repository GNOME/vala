/* basic_types_bug761736.c generated by valac, the Vala compiler
 * generated from basic_types_bug761736.vala, do not modify */

#include <stdlib.h>
#include <string.h>
#include <glib.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

VALA_EXTERN gchar** transfer_none (gint* result_length1);
VALA_EXTERN const gchar** transfer_container (gint* result_length1);
static const gchar** _vala_array_dup1 (const gchar** self,
                                gssize length);
VALA_EXTERN gchar** transfer_full (gint* result_length1);
static gchar** _vala_array_dup2 (gchar** self,
                          gssize length);
static void _vala_main (void);
static const gchar** _vala_array_dup3 (const gchar** self,
                                gssize length);
static gchar** _vala_array_dup4 (gchar** self,
                          gssize length);
static gboolean _vala_string_array_contains (gchar* * stack,
                                      gssize stack_length,
                                      const gchar* needle);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);
static inline gpointer _vala_memdup2 (gconstpointer mem,
                        gsize byte_size);

const gchar* FOO[2] = {"foo", "bar"};

gchar**
transfer_none (gint* result_length1)
{
	gchar** _tmp0_;
	gint _tmp0__length1;
	gchar** result;
	_tmp0_ = FOO;
	_tmp0__length1 = G_N_ELEMENTS (FOO);
	if (result_length1) {
		*result_length1 = _tmp0__length1;
	}
	result = _tmp0_;
	return result;
}

static const gchar**
_vala_array_dup1 (const gchar** self,
                  gssize length)
{
	if (length > 0) {
		return _vala_memdup2 (self, length * sizeof (const gchar*));
	}
	return NULL;
}

const gchar**
transfer_container (gint* result_length1)
{
	const gchar** _tmp0_;
	gint _tmp0__length1;
	const gchar** _tmp1_;
	gint _tmp1__length1;
	const gchar** result;
	_tmp0_ = _vala_array_dup1 (FOO, G_N_ELEMENTS (FOO));
	_tmp0__length1 = G_N_ELEMENTS (FOO);
	_tmp1_ = _tmp0_;
	_tmp1__length1 = _tmp0__length1;
	if (result_length1) {
		*result_length1 = _tmp1__length1;
	}
	result = _tmp1_;
	return result;
}

static gchar**
_vala_array_dup2 (gchar** self,
                  gssize length)
{
	if (length >= 0) {
		gchar** result;
		gssize i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

gchar**
transfer_full (gint* result_length1)
{
	gchar** _tmp0_;
	gint _tmp0__length1;
	gchar** _tmp1_;
	gint _tmp1__length1;
	gchar** result;
	_tmp0_ = _vala_array_dup2 (FOO, G_N_ELEMENTS (FOO));
	_tmp0__length1 = G_N_ELEMENTS (FOO);
	_tmp1_ = _tmp0_;
	_tmp1__length1 = _tmp0__length1;
	if (result_length1) {
		*result_length1 = _tmp1__length1;
	}
	result = _tmp1_;
	return result;
}

static const gchar**
_vala_array_dup3 (const gchar** self,
                  gssize length)
{
	if (length > 0) {
		return _vala_memdup2 (self, length * sizeof (const gchar*));
	}
	return NULL;
}

static gchar**
_vala_array_dup4 (gchar** self,
                  gssize length)
{
	if (length >= 0) {
		gchar** result;
		gssize i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

static gboolean
_vala_string_array_contains (gchar* * stack,
                             gssize stack_length,
                             const gchar* needle)
{
	gssize i;
	for (i = 0; i < stack_length; i++) {
		if (g_strcmp0 (stack[i], needle) == 0) {
			return TRUE;
		}
	}
	return FALSE;
}

static void
_vala_main (void)
{
	const gchar** bar = NULL;
	const gchar** _tmp0_;
	gint _tmp0__length1;
	gint bar_length1;
	gint _bar_size_;
	_tmp0_ = _vala_array_dup3 (FOO, G_N_ELEMENTS (FOO));
	_tmp0__length1 = G_N_ELEMENTS (FOO);
	bar = _tmp0_;
	bar_length1 = _tmp0__length1;
	_bar_size_ = bar_length1;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				gchar** baz = NULL;
				const gchar** _tmp3_;
				gint _tmp3__length1;
				gchar** _tmp4_;
				gint _tmp4__length1;
				gint baz_length1;
				gint _baz_size_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp1_ = FALSE;
				if (!(i < 42)) {
					break;
				}
				_tmp3_ = bar;
				_tmp3__length1 = bar_length1;
				_tmp4_ = (_tmp3_ != NULL) ? _vala_array_dup4 (_tmp3_, _tmp3__length1) : _tmp3_;
				_tmp4__length1 = _tmp3__length1;
				baz = _tmp4_;
				baz_length1 = _tmp4__length1;
				_baz_size_ = baz_length1;
				baz = (_vala_array_free (baz, baz_length1, (GDestroyNotify) g_free), NULL);
			}
		}
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp5_ = FALSE;
			_tmp5_ = TRUE;
			while (TRUE) {
				gchar** a = NULL;
				gint _tmp7_ = 0;
				gchar** _tmp8_;
				gint a_length1;
				gint _a_size_;
				gchar** _tmp9_;
				gint _tmp9__length1;
				gchar** _tmp10_;
				gint _tmp10__length1;
				if (!_tmp5_) {
					gint _tmp6_;
					_tmp6_ = i;
					i = _tmp6_ + 1;
				}
				_tmp5_ = FALSE;
				if (!(i < 42)) {
					break;
				}
				_tmp8_ = transfer_none (&_tmp7_);
				a = _tmp8_;
				a_length1 = _tmp7_;
				_a_size_ = a_length1;
				_tmp9_ = a;
				_tmp9__length1 = a_length1;
				_vala_assert (_vala_string_array_contains (_tmp9_, _tmp9__length1, "foo"), "\"foo\" in a");
				_tmp10_ = a;
				_tmp10__length1 = a_length1;
				_vala_assert (_vala_string_array_contains (_tmp10_, _tmp10__length1, "bar"), "\"bar\" in a");
			}
		}
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp11_ = FALSE;
			_tmp11_ = TRUE;
			while (TRUE) {
				const gchar** a = NULL;
				gint _tmp13_ = 0;
				const gchar** _tmp14_;
				gint a_length1;
				gint _a_size_;
				const gchar** _tmp15_;
				gint _tmp15__length1;
				const gchar** _tmp16_;
				gint _tmp16__length1;
				if (!_tmp11_) {
					gint _tmp12_;
					_tmp12_ = i;
					i = _tmp12_ + 1;
				}
				_tmp11_ = FALSE;
				if (!(i < 42)) {
					break;
				}
				_tmp14_ = transfer_container (&_tmp13_);
				a = _tmp14_;
				a_length1 = _tmp13_;
				_a_size_ = a_length1;
				_tmp15_ = a;
				_tmp15__length1 = a_length1;
				_vala_assert (_vala_string_array_contains (_tmp15_, _tmp15__length1, "foo"), "\"foo\" in a");
				_tmp16_ = a;
				_tmp16__length1 = a_length1;
				_vala_assert (_vala_string_array_contains (_tmp16_, _tmp16__length1, "bar"), "\"bar\" in a");
				a = (g_free (a), NULL);
			}
		}
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp17_ = FALSE;
			_tmp17_ = TRUE;
			while (TRUE) {
				gchar** a = NULL;
				gint _tmp19_ = 0;
				gchar** _tmp20_;
				gint a_length1;
				gint _a_size_;
				gchar** _tmp21_;
				gint _tmp21__length1;
				gchar** _tmp22_;
				gint _tmp22__length1;
				if (!_tmp17_) {
					gint _tmp18_;
					_tmp18_ = i;
					i = _tmp18_ + 1;
				}
				_tmp17_ = FALSE;
				if (!(i < 42)) {
					break;
				}
				_tmp20_ = transfer_full (&_tmp19_);
				a = _tmp20_;
				a_length1 = _tmp19_;
				_a_size_ = a_length1;
				_tmp21_ = a;
				_tmp21__length1 = a_length1;
				_vala_assert (_vala_string_array_contains (_tmp21_, _tmp21__length1, "foo"), "\"foo\" in a");
				_tmp22_ = a;
				_tmp22__length1 = a_length1;
				_vala_assert (_vala_string_array_contains (_tmp22_, _tmp22__length1, "bar"), "\"bar\" in a");
				a = (_vala_array_free (a, a_length1, (GDestroyNotify) g_free), NULL);
			}
		}
	}
	_vala_assert (_vala_string_array_contains (FOO, G_N_ELEMENTS (FOO), "foo"), "\"foo\" in FOO");
	_vala_assert (_vala_string_array_contains (FOO, G_N_ELEMENTS (FOO), "bar"), "\"bar\" in FOO");
	bar = (g_free (bar), NULL);
}

int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static inline gpointer
_vala_memdup2 (gconstpointer mem,
               gsize byte_size)
{
	gpointer new_mem;
	if (mem && byte_size != 0) {
		new_mem = g_malloc (byte_size);
		memcpy (new_mem, mem, byte_size);
	} else {
		new_mem = NULL;
	}
	return new_mem;
}

