/* threads_threadpool.c generated by valac, the Vala compiler
 * generated from threads_threadpool.vala, do not modify */

#include <glib.h>
#include <stdlib.h>
#include <string.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_thread_pool_free0(var) ((var == NULL) ? NULL : (var = (g_thread_pool_free (var, FALSE, TRUE), NULL)))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

VALA_EXTERN gboolean success;
gboolean success = FALSE;

static void _vala_main (void);
static void _vala_lambda0_ (gchar* s);
static void __vala_lambda0__gfunc (gpointer data,
                            gpointer self);

static void
_vala_lambda0_ (gchar* s)
{
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (s != NULL);
	if (g_strcmp0 (s, "foo") == 0) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = g_strcmp0 (s, "bar") == 0;
	}
	_vala_assert (_tmp0_, "s == \"foo\" || s == \"bar\"");
	success = TRUE;
	_g_free0 (s);
}

static void
__vala_lambda0__gfunc (gpointer data,
                       gpointer self)
{
	_vala_lambda0_ ((gchar*) data);
}

static void
_vala_main (void)
{
	GError* _inner_error0_ = NULL;
	{
		GThreadPool* pool = NULL;
		GThreadPool* _tmp0_;
		GThreadPool* _tmp1_;
		gchar* _tmp2_;
		GThreadPool* _tmp3_;
		gchar* _tmp4_;
		_tmp0_ = g_thread_pool_new (__vala_lambda0__gfunc, NULL, 2, TRUE, &_inner_error0_);
		pool = _tmp0_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		_tmp1_ = pool;
		_tmp2_ = g_strdup ("foo");
		g_thread_pool_push (_tmp1_, _tmp2_, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_thread_pool_free0 (pool);
			goto __catch0_g_error;
		}
		_tmp3_ = pool;
		_tmp4_ = g_strdup ("bar");
		g_thread_pool_push (_tmp3_, _tmp4_, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_thread_pool_free0 (pool);
			goto __catch0_g_error;
		}
		_g_thread_pool_free0 (pool);
	}
	goto __finally0;
	__catch0_g_error:
	{
		g_clear_error (&_inner_error0_);
		g_assert_not_reached ();
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_vala_assert (success, "success");
}

int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}

