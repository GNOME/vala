/* objects_signals.c generated by valac, the Vala compiler
 * generated from objects_signals.vala, do not modify */

#include <glib.h>
#include <glib-object.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define MAMAN_TYPE_FOO (maman_foo_get_type ())
#define MAMAN_FOO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_FOO, MamanFoo))
#define MAMAN_FOO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_FOO, MamanFooClass))
#define MAMAN_IS_FOO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_FOO))
#define MAMAN_IS_FOO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_FOO))
#define MAMAN_FOO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_FOO, MamanFooClass))

typedef struct _MamanFoo MamanFoo;
typedef struct _MamanFooClass MamanFooClass;
typedef struct _MamanFooPrivate MamanFooPrivate;
enum  {
	MAMAN_FOO_0_PROPERTY,
	MAMAN_FOO_NUM_PROPERTIES
};
static GParamSpec* maman_foo_properties[MAMAN_FOO_NUM_PROPERTIES];
enum  {
	MAMAN_FOO_ACTIVATED_SIGNAL,
	MAMAN_FOO_NUM_SIGNALS
};
static guint maman_foo_signals[MAMAN_FOO_NUM_SIGNALS] = {0};

#define MAMAN_TYPE_BAR (maman_bar_get_type ())
#define MAMAN_BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_BAR, MamanBar))
#define MAMAN_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_BAR, MamanBarClass))
#define MAMAN_IS_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_BAR))
#define MAMAN_IS_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_BAR))
#define MAMAN_BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_BAR, MamanBarClass))

typedef struct _MamanBar MamanBar;
typedef struct _MamanBarClass MamanBarClass;
typedef struct _MamanBarPrivate MamanBarPrivate;
enum  {
	MAMAN_BAR_0_PROPERTY,
	MAMAN_BAR_NUM_PROPERTIES
};
static GParamSpec* maman_bar_properties[MAMAN_BAR_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define MAMAN_TYPE_USER_FOO (maman_user_foo_get_type ())
#define MAMAN_USER_FOO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_USER_FOO, MamanUserFoo))
#define MAMAN_USER_FOO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_USER_FOO, MamanUserFooClass))
#define MAMAN_IS_USER_FOO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_USER_FOO))
#define MAMAN_IS_USER_FOO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_USER_FOO))
#define MAMAN_USER_FOO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_USER_FOO, MamanUserFooClass))

typedef struct _MamanUserFoo MamanUserFoo;
typedef struct _MamanUserFooClass MamanUserFooClass;
typedef struct _MamanUserFooPrivate MamanUserFooPrivate;
enum  {
	MAMAN_USER_FOO_0_PROPERTY,
	MAMAN_USER_FOO_NUM_PROPERTIES
};
static GParamSpec* maman_user_foo_properties[MAMAN_USER_FOO_NUM_PROPERTIES];
enum  {
	MAMAN_USER_FOO_ACTIVATED_SIGNAL,
	MAMAN_USER_FOO_NUM_SIGNALS
};
static guint maman_user_foo_signals[MAMAN_USER_FOO_NUM_SIGNALS] = {0};

#define MAMAN_TYPE_USER_BAR (maman_user_bar_get_type ())
#define MAMAN_USER_BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_USER_BAR, MamanUserBar))
#define MAMAN_USER_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_USER_BAR, MamanUserBarClass))
#define MAMAN_IS_USER_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_USER_BAR))
#define MAMAN_IS_USER_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_USER_BAR))
#define MAMAN_USER_BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_USER_BAR, MamanUserBarClass))

typedef struct _MamanUserBar MamanUserBar;
typedef struct _MamanUserBarClass MamanUserBarClass;
typedef struct _MamanUserBarPrivate MamanUserBarPrivate;
enum  {
	MAMAN_USER_BAR_0_PROPERTY,
	MAMAN_USER_BAR_NUM_PROPERTIES
};
static GParamSpec* maman_user_bar_properties[MAMAN_USER_BAR_NUM_PROPERTIES];

#define MAMAN_TYPE_RETURN_FOO (maman_return_foo_get_type ())
#define MAMAN_RETURN_FOO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_RETURN_FOO, MamanReturnFoo))
#define MAMAN_RETURN_FOO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_RETURN_FOO, MamanReturnFooClass))
#define MAMAN_IS_RETURN_FOO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_RETURN_FOO))
#define MAMAN_IS_RETURN_FOO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_RETURN_FOO))
#define MAMAN_RETURN_FOO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_RETURN_FOO, MamanReturnFooClass))

typedef struct _MamanReturnFoo MamanReturnFoo;
typedef struct _MamanReturnFooClass MamanReturnFooClass;
typedef struct _MamanReturnFooPrivate MamanReturnFooPrivate;
enum  {
	MAMAN_RETURN_FOO_0_PROPERTY,
	MAMAN_RETURN_FOO_NUM_PROPERTIES
};
static GParamSpec* maman_return_foo_properties[MAMAN_RETURN_FOO_NUM_PROPERTIES];
enum  {
	MAMAN_RETURN_FOO_INT_ACTIVATED_SIGNAL,
	MAMAN_RETURN_FOO_STRING_ACTIVATED_SIGNAL,
	MAMAN_RETURN_FOO_NUM_SIGNALS
};
static guint maman_return_foo_signals[MAMAN_RETURN_FOO_NUM_SIGNALS] = {0};

#define MAMAN_TYPE_RETURN_BAR (maman_return_bar_get_type ())
#define MAMAN_RETURN_BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_RETURN_BAR, MamanReturnBar))
#define MAMAN_RETURN_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_RETURN_BAR, MamanReturnBarClass))
#define MAMAN_IS_RETURN_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_RETURN_BAR))
#define MAMAN_IS_RETURN_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_RETURN_BAR))
#define MAMAN_RETURN_BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_RETURN_BAR, MamanReturnBarClass))

typedef struct _MamanReturnBar MamanReturnBar;
typedef struct _MamanReturnBarClass MamanReturnBarClass;
typedef struct _MamanReturnBarPrivate MamanReturnBarPrivate;
enum  {
	MAMAN_RETURN_BAR_0_PROPERTY,
	MAMAN_RETURN_BAR_NUM_PROPERTIES
};
static GParamSpec* maman_return_bar_properties[MAMAN_RETURN_BAR_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _MamanFoo {
	GObject parent_instance;
	MamanFooPrivate * priv;
};

struct _MamanFooClass {
	GObjectClass parent_class;
};

struct _MamanBar {
	GObject parent_instance;
	MamanBarPrivate * priv;
};

struct _MamanBarClass {
	GObjectClass parent_class;
};

struct _MamanUserFoo {
	GObject parent_instance;
	MamanUserFooPrivate * priv;
};

struct _MamanUserFooClass {
	GObjectClass parent_class;
};

struct _MamanUserBar {
	GObject parent_instance;
	MamanUserBarPrivate * priv;
};

struct _MamanUserBarClass {
	GObjectClass parent_class;
};

struct _MamanReturnFoo {
	GObject parent_instance;
	MamanReturnFooPrivate * priv;
};

struct _MamanReturnFooClass {
	GObjectClass parent_class;
};

struct _MamanReturnBar {
	GObject parent_instance;
	MamanReturnBarPrivate * priv;
};

struct _MamanReturnBarClass {
	GObjectClass parent_class;
};

VALA_EXTERN gint counter;
gint counter = 0;
static gpointer maman_foo_parent_class = NULL;
static gpointer maman_bar_parent_class = NULL;
static gpointer maman_user_foo_parent_class = NULL;
static gpointer maman_user_bar_parent_class = NULL;
static gpointer maman_return_foo_parent_class = NULL;
static gpointer maman_return_bar_parent_class = NULL;

VALA_EXTERN GType maman_foo_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MamanFoo, g_object_unref)
VALA_EXTERN void maman_foo_do_action (MamanFoo* self,
                          gboolean b);
VALA_EXTERN MamanFoo* maman_foo_new (void);
VALA_EXTERN MamanFoo* maman_foo_construct (GType object_type);
static GType maman_foo_get_type_once (void);
VALA_EXTERN GType maman_bar_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MamanBar, g_object_unref)
static void maman_bar_activated (MamanBar* self,
                          MamanFoo* foo,
                          gboolean b);
VALA_EXTERN void maman_bar_run (MamanBar* self);
static void _vala_lambda0_ (MamanBar* self,
                     MamanFoo* foo,
                     gboolean b);
static void __vala_lambda0__maman_foo_activated (MamanFoo* _sender,
                                          gboolean b,
                                          gpointer self);
static void _maman_bar_activated_maman_foo_activated (MamanFoo* _sender,
                                               gboolean b,
                                               gpointer self);
VALA_EXTERN MamanBar* maman_bar_new (void);
VALA_EXTERN MamanBar* maman_bar_construct (GType object_type);
static GType maman_bar_get_type_once (void);
VALA_EXTERN GType maman_user_foo_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MamanUserFoo, g_object_unref)
VALA_EXTERN void maman_user_foo_do_action (MamanUserFoo* self);
VALA_EXTERN MamanUserFoo* maman_user_foo_new (void);
VALA_EXTERN MamanUserFoo* maman_user_foo_construct (GType object_type);
static void g_cclosure_user_marshal_VOID__INT_INT_POINTER (GClosure * closure,
                                                    GValue * return_value,
                                                    guint n_param_values,
                                                    const GValue * param_values,
                                                    gpointer invocation_hint,
                                                    gpointer marshal_data);
static GType maman_user_foo_get_type_once (void);
VALA_EXTERN GType maman_user_bar_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MamanUserBar, g_object_unref)
VALA_EXTERN void maman_user_bar_run (MamanUserBar* self);
static void _vala_lambda1_ (MamanUserBar* self,
                     MamanUserFoo* foo,
                     gint i1,
                     gint i2,
                     gint* i3);
static void __vala_lambda1__maman_user_foo_activated (MamanUserFoo* _sender,
                                               gint i1,
                                               gint i2,
                                               gint* i3,
                                               gpointer self);
VALA_EXTERN MamanUserBar* maman_user_bar_new (void);
VALA_EXTERN MamanUserBar* maman_user_bar_construct (GType object_type);
static GType maman_user_bar_get_type_once (void);
VALA_EXTERN GType maman_return_foo_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MamanReturnFoo, g_object_unref)
VALA_EXTERN MamanReturnFoo* maman_return_foo_new (void);
VALA_EXTERN MamanReturnFoo* maman_return_foo_construct (GType object_type);
static void g_cclosure_user_marshal_INT__INT (GClosure * closure,
                                       GValue * return_value,
                                       guint n_param_values,
                                       const GValue * param_values,
                                       gpointer invocation_hint,
                                       gpointer marshal_data);
static void g_cclosure_user_marshal_STRING__STRING (GClosure * closure,
                                             GValue * return_value,
                                             guint n_param_values,
                                             const GValue * param_values,
                                             gpointer invocation_hint,
                                             gpointer marshal_data);
static GType maman_return_foo_get_type_once (void);
VALA_EXTERN GType maman_return_bar_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MamanReturnBar, g_object_unref)
VALA_EXTERN void maman_return_bar_run (MamanReturnBar* self);
static gint _vala_lambda2_ (MamanReturnBar* self,
                     MamanReturnFoo* foo,
                     gint arg);
static gint __vala_lambda2__maman_return_foo_int_activated (MamanReturnFoo* _sender,
                                                     gint arg,
                                                     gpointer self);
static gchar* _vala_lambda3_ (MamanReturnBar* self,
                       MamanReturnFoo* foo,
                       const gchar* arg);
static gchar* __vala_lambda3__maman_return_foo_string_activated (MamanReturnFoo* _sender,
                                                          const gchar* arg,
                                                          gpointer self);
VALA_EXTERN MamanReturnBar* maman_return_bar_new (void);
VALA_EXTERN MamanReturnBar* maman_return_bar_construct (GType object_type);
static GType maman_return_bar_get_type_once (void);
static void _vala_main (void);

void
maman_foo_do_action (MamanFoo* self,
                     gboolean b)
{
	g_return_if_fail (MAMAN_IS_FOO (self));
	g_signal_emit (self, maman_foo_signals[MAMAN_FOO_ACTIVATED_SIGNAL], 0, b);
}

MamanFoo*
maman_foo_construct (GType object_type)
{
	MamanFoo * self = NULL;
	self = (MamanFoo*) g_object_new (object_type, NULL);
	return self;
}

MamanFoo*
maman_foo_new (void)
{
	return maman_foo_construct (MAMAN_TYPE_FOO);
}

static void
maman_foo_class_init (MamanFooClass * klass,
                      gpointer klass_data)
{
	maman_foo_parent_class = g_type_class_peek_parent (klass);
	maman_foo_signals[MAMAN_FOO_ACTIVATED_SIGNAL] = g_signal_new ("activated", MAMAN_TYPE_FOO, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__BOOLEAN, G_TYPE_NONE, 1, G_TYPE_BOOLEAN);
}

static void
maman_foo_instance_init (MamanFoo * self,
                         gpointer klass)
{
}

static GType
maman_foo_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (MamanFooClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) maman_foo_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MamanFoo), 0, (GInstanceInitFunc) maman_foo_instance_init, NULL };
	GType maman_foo_type_id;
	maman_foo_type_id = g_type_register_static (G_TYPE_OBJECT, "MamanFoo", &g_define_type_info, 0);
	return maman_foo_type_id;
}

GType
maman_foo_get_type (void)
{
	static volatile gsize maman_foo_type_id__once = 0;
	if (g_once_init_enter (&maman_foo_type_id__once)) {
		GType maman_foo_type_id;
		maman_foo_type_id = maman_foo_get_type_once ();
		g_once_init_leave (&maman_foo_type_id__once, maman_foo_type_id);
	}
	return maman_foo_type_id__once;
}

static void
maman_bar_activated (MamanBar* self,
                     MamanFoo* foo,
                     gboolean b)
{
	g_return_if_fail (MAMAN_IS_BAR (self));
	g_return_if_fail (MAMAN_IS_FOO (foo));
	if (b) {
		g_assert_not_reached ();
	} else {
		FILE* _tmp0_;
		gint _tmp1_;
		_tmp0_ = stdout;
		fprintf (_tmp0_, " 5");
		counter = counter + 1;
		_tmp1_ = counter;
		_vala_assert (_tmp1_ == 5, "++counter == 5");
	}
}

static void
_vala_lambda0_ (MamanBar* self,
                MamanFoo* foo,
                gboolean b)
{
	g_return_if_fail (MAMAN_IS_FOO (foo));
	if (b) {
		FILE* _tmp0_;
		gint _tmp1_;
		_tmp0_ = stdout;
		fprintf (_tmp0_, " 8");
		counter = counter + 1;
		_tmp1_ = counter;
		_vala_assert (_tmp1_ == 8, "++counter == 8");
	} else {
		FILE* _tmp2_;
		gint _tmp3_;
		_tmp2_ = stdout;
		fprintf (_tmp2_, " 4");
		counter = counter + 1;
		_tmp3_ = counter;
		_vala_assert (_tmp3_ == 4, "++counter == 4");
	}
}

static void
__vala_lambda0__maman_foo_activated (MamanFoo* _sender,
                                     gboolean b,
                                     gpointer self)
{
	_vala_lambda0_ ((MamanBar*) self, _sender, b);
}

static void
_maman_bar_activated_maman_foo_activated (MamanFoo* _sender,
                                          gboolean b,
                                          gpointer self)
{
	maman_bar_activated ((MamanBar*) self, _sender, b);
}

void
maman_bar_run (MamanBar* self)
{
	FILE* _tmp0_;
	gint _tmp1_;
	MamanFoo* foo = NULL;
	MamanFoo* _tmp2_;
	FILE* _tmp3_;
	gint _tmp4_;
	FILE* _tmp5_;
	gint _tmp6_;
	guint _tmp7_;
	FILE* _tmp8_;
	gint _tmp9_;
	FILE* _tmp10_;
	gint _tmp11_;
	g_return_if_fail (MAMAN_IS_BAR (self));
	_tmp0_ = stdout;
	fprintf (_tmp0_, " 2");
	counter = counter + 1;
	_tmp1_ = counter;
	_vala_assert (_tmp1_ == 2, "++counter == 2");
	_tmp2_ = maman_foo_new ();
	foo = _tmp2_;
	g_signal_connect_object (foo, "activated", (GCallback) __vala_lambda0__maman_foo_activated, self, 0);
	g_signal_connect_object (foo, "activated", (GCallback) _maman_bar_activated_maman_foo_activated, self, 0);
	_tmp3_ = stdout;
	fprintf (_tmp3_, " 3");
	counter = counter + 1;
	_tmp4_ = counter;
	_vala_assert (_tmp4_ == 3, "++counter == 3");
	maman_foo_do_action (foo, FALSE);
	_tmp5_ = stdout;
	fprintf (_tmp5_, " 6");
	counter = counter + 1;
	_tmp6_ = counter;
	_vala_assert (_tmp6_ == 6, "++counter == 6");
	g_signal_parse_name ("activated", MAMAN_TYPE_FOO, &_tmp7_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (foo, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp7_, 0, NULL, (GCallback) _maman_bar_activated_maman_foo_activated, self);
	_tmp8_ = stdout;
	fprintf (_tmp8_, " 7");
	counter = counter + 1;
	_tmp9_ = counter;
	_vala_assert (_tmp9_ == 7, "++counter == 7");
	maman_foo_do_action (foo, TRUE);
	_tmp10_ = stdout;
	fprintf (_tmp10_, " 9");
	counter = counter + 1;
	_tmp11_ = counter;
	_vala_assert (_tmp11_ == 9, "++counter == 9");
	_g_object_unref0 (foo);
}

MamanBar*
maman_bar_construct (GType object_type)
{
	MamanBar * self = NULL;
	self = (MamanBar*) g_object_new (object_type, NULL);
	return self;
}

MamanBar*
maman_bar_new (void)
{
	return maman_bar_construct (MAMAN_TYPE_BAR);
}

static void
maman_bar_class_init (MamanBarClass * klass,
                      gpointer klass_data)
{
	maman_bar_parent_class = g_type_class_peek_parent (klass);
}

static void
maman_bar_instance_init (MamanBar * self,
                         gpointer klass)
{
}

static GType
maman_bar_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (MamanBarClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) maman_bar_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MamanBar), 0, (GInstanceInitFunc) maman_bar_instance_init, NULL };
	GType maman_bar_type_id;
	maman_bar_type_id = g_type_register_static (G_TYPE_OBJECT, "MamanBar", &g_define_type_info, 0);
	return maman_bar_type_id;
}

GType
maman_bar_get_type (void)
{
	static volatile gsize maman_bar_type_id__once = 0;
	if (g_once_init_enter (&maman_bar_type_id__once)) {
		GType maman_bar_type_id;
		maman_bar_type_id = maman_bar_get_type_once ();
		g_once_init_leave (&maman_bar_type_id__once, maman_bar_type_id);
	}
	return maman_bar_type_id__once;
}

void
maman_user_foo_do_action (MamanUserFoo* self)
{
	gint i = 0;
	gint _tmp0_ = 0;
	g_return_if_fail (MAMAN_IS_USER_FOO (self));
	g_signal_emit (self, maman_user_foo_signals[MAMAN_USER_FOO_ACTIVATED_SIGNAL], 0, 6, -2, &_tmp0_);
	i = _tmp0_;
	_vala_assert (i == 4, "i == 4");
}

MamanUserFoo*
maman_user_foo_construct (GType object_type)
{
	MamanUserFoo * self = NULL;
	self = (MamanUserFoo*) g_object_new (object_type, NULL);
	return self;
}

MamanUserFoo*
maman_user_foo_new (void)
{
	return maman_user_foo_construct (MAMAN_TYPE_USER_FOO);
}

static void
g_cclosure_user_marshal_VOID__INT_INT_POINTER (GClosure * closure,
                                               GValue * return_value,
                                               guint n_param_values,
                                               const GValue * param_values,
                                               gpointer invocation_hint,
                                               gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__INT_INT_POINTER) (gpointer data1, gint arg_1, gint arg_2, gpointer arg_3, gpointer data2);
	register GMarshalFunc_VOID__INT_INT_POINTER callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 4);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__INT_INT_POINTER) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_int (param_values + 1), g_value_get_int (param_values + 2), g_value_get_pointer (param_values + 3), data2);
}

static void
maman_user_foo_class_init (MamanUserFooClass * klass,
                           gpointer klass_data)
{
	maman_user_foo_parent_class = g_type_class_peek_parent (klass);
	maman_user_foo_signals[MAMAN_USER_FOO_ACTIVATED_SIGNAL] = g_signal_new ("activated", MAMAN_TYPE_USER_FOO, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__INT_INT_POINTER, G_TYPE_NONE, 3, G_TYPE_INT, G_TYPE_INT, G_TYPE_POINTER);
}

static void
maman_user_foo_instance_init (MamanUserFoo * self,
                              gpointer klass)
{
}

static GType
maman_user_foo_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (MamanUserFooClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) maman_user_foo_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MamanUserFoo), 0, (GInstanceInitFunc) maman_user_foo_instance_init, NULL };
	GType maman_user_foo_type_id;
	maman_user_foo_type_id = g_type_register_static (G_TYPE_OBJECT, "MamanUserFoo", &g_define_type_info, 0);
	return maman_user_foo_type_id;
}

GType
maman_user_foo_get_type (void)
{
	static volatile gsize maman_user_foo_type_id__once = 0;
	if (g_once_init_enter (&maman_user_foo_type_id__once)) {
		GType maman_user_foo_type_id;
		maman_user_foo_type_id = maman_user_foo_get_type_once ();
		g_once_init_leave (&maman_user_foo_type_id__once, maman_user_foo_type_id);
	}
	return maman_user_foo_type_id__once;
}

static void
_vala_lambda1_ (MamanUserBar* self,
                MamanUserFoo* foo,
                gint i1,
                gint i2,
                gint* i3)
{
	gint _vala_i3 = 0;
	FILE* _tmp0_;
	gint _tmp1_;
	g_return_if_fail (MAMAN_IS_USER_FOO (foo));
	_tmp0_ = stdout;
	fprintf (_tmp0_, " %d", i1 + i2);
	_vala_i3 = i1 + i2;
	counter = counter + 1;
	_tmp1_ = counter;
	_vala_assert (_tmp1_ == 4, "++counter == 4");
	if (i3) {
		*i3 = _vala_i3;
	}
}

static void
__vala_lambda1__maman_user_foo_activated (MamanUserFoo* _sender,
                                          gint i1,
                                          gint i2,
                                          gint* i3,
                                          gpointer self)
{
	_vala_lambda1_ ((MamanUserBar*) self, _sender, i1, i2, i3);
}

void
maman_user_bar_run (MamanUserBar* self)
{
	FILE* _tmp0_;
	gint _tmp1_;
	MamanUserFoo* foo = NULL;
	MamanUserFoo* _tmp2_;
	FILE* _tmp3_;
	gint _tmp4_;
	FILE* _tmp5_;
	gint _tmp6_;
	g_return_if_fail (MAMAN_IS_USER_BAR (self));
	_tmp0_ = stdout;
	fprintf (_tmp0_, " 2");
	counter = counter + 1;
	_tmp1_ = counter;
	_vala_assert (_tmp1_ == 2, "++counter == 2");
	_tmp2_ = maman_user_foo_new ();
	foo = _tmp2_;
	g_signal_connect_object (foo, "activated", (GCallback) __vala_lambda1__maman_user_foo_activated, self, 0);
	_tmp3_ = stdout;
	fprintf (_tmp3_, " 3");
	counter = counter + 1;
	_tmp4_ = counter;
	_vala_assert (_tmp4_ == 3, "++counter == 3");
	maman_user_foo_do_action (foo);
	_tmp5_ = stdout;
	fprintf (_tmp5_, " 5");
	counter = counter + 1;
	_tmp6_ = counter;
	_vala_assert (_tmp6_ == 5, "++counter == 5");
	_g_object_unref0 (foo);
}

MamanUserBar*
maman_user_bar_construct (GType object_type)
{
	MamanUserBar * self = NULL;
	self = (MamanUserBar*) g_object_new (object_type, NULL);
	return self;
}

MamanUserBar*
maman_user_bar_new (void)
{
	return maman_user_bar_construct (MAMAN_TYPE_USER_BAR);
}

static void
maman_user_bar_class_init (MamanUserBarClass * klass,
                           gpointer klass_data)
{
	maman_user_bar_parent_class = g_type_class_peek_parent (klass);
}

static void
maman_user_bar_instance_init (MamanUserBar * self,
                              gpointer klass)
{
}

static GType
maman_user_bar_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (MamanUserBarClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) maman_user_bar_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MamanUserBar), 0, (GInstanceInitFunc) maman_user_bar_instance_init, NULL };
	GType maman_user_bar_type_id;
	maman_user_bar_type_id = g_type_register_static (G_TYPE_OBJECT, "MamanUserBar", &g_define_type_info, 0);
	return maman_user_bar_type_id;
}

GType
maman_user_bar_get_type (void)
{
	static volatile gsize maman_user_bar_type_id__once = 0;
	if (g_once_init_enter (&maman_user_bar_type_id__once)) {
		GType maman_user_bar_type_id;
		maman_user_bar_type_id = maman_user_bar_get_type_once ();
		g_once_init_leave (&maman_user_bar_type_id__once, maman_user_bar_type_id);
	}
	return maman_user_bar_type_id__once;
}

MamanReturnFoo*
maman_return_foo_construct (GType object_type)
{
	MamanReturnFoo * self = NULL;
	self = (MamanReturnFoo*) g_object_new (object_type, NULL);
	return self;
}

MamanReturnFoo*
maman_return_foo_new (void)
{
	return maman_return_foo_construct (MAMAN_TYPE_RETURN_FOO);
}

static void
g_cclosure_user_marshal_INT__INT (GClosure * closure,
                                  GValue * return_value,
                                  guint n_param_values,
                                  const GValue * param_values,
                                  gpointer invocation_hint,
                                  gpointer marshal_data)
{
	typedef gint (*GMarshalFunc_INT__INT) (gpointer data1, gint arg_1, gpointer data2);
	register GMarshalFunc_INT__INT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	gint v_return;
	cc = (GCClosure *) closure;
	g_return_if_fail (return_value != NULL);
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_INT__INT) (marshal_data ? marshal_data : cc->callback);
	v_return = callback (data1, g_value_get_int (param_values + 1), data2);
	g_value_set_int (return_value, v_return);
}

static void
g_cclosure_user_marshal_STRING__STRING (GClosure * closure,
                                        GValue * return_value,
                                        guint n_param_values,
                                        const GValue * param_values,
                                        gpointer invocation_hint,
                                        gpointer marshal_data)
{
	typedef const char* (*GMarshalFunc_STRING__STRING) (gpointer data1, const char* arg_1, gpointer data2);
	register GMarshalFunc_STRING__STRING callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	const char* v_return;
	cc = (GCClosure *) closure;
	g_return_if_fail (return_value != NULL);
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_STRING__STRING) (marshal_data ? marshal_data : cc->callback);
	v_return = callback (data1, g_value_get_string (param_values + 1), data2);
	g_value_take_string (return_value, v_return);
}

static void
maman_return_foo_class_init (MamanReturnFooClass * klass,
                             gpointer klass_data)
{
	maman_return_foo_parent_class = g_type_class_peek_parent (klass);
	maman_return_foo_signals[MAMAN_RETURN_FOO_INT_ACTIVATED_SIGNAL] = g_signal_new ("int-activated", MAMAN_TYPE_RETURN_FOO, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_INT__INT, G_TYPE_INT, 1, G_TYPE_INT);
	maman_return_foo_signals[MAMAN_RETURN_FOO_STRING_ACTIVATED_SIGNAL] = g_signal_new ("string-activated", MAMAN_TYPE_RETURN_FOO, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_STRING__STRING, G_TYPE_STRING, 1, G_TYPE_STRING);
}

static void
maman_return_foo_instance_init (MamanReturnFoo * self,
                                gpointer klass)
{
}

static GType
maman_return_foo_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (MamanReturnFooClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) maman_return_foo_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MamanReturnFoo), 0, (GInstanceInitFunc) maman_return_foo_instance_init, NULL };
	GType maman_return_foo_type_id;
	maman_return_foo_type_id = g_type_register_static (G_TYPE_OBJECT, "MamanReturnFoo", &g_define_type_info, 0);
	return maman_return_foo_type_id;
}

GType
maman_return_foo_get_type (void)
{
	static volatile gsize maman_return_foo_type_id__once = 0;
	if (g_once_init_enter (&maman_return_foo_type_id__once)) {
		GType maman_return_foo_type_id;
		maman_return_foo_type_id = maman_return_foo_get_type_once ();
		g_once_init_leave (&maman_return_foo_type_id__once, maman_return_foo_type_id);
	}
	return maman_return_foo_type_id__once;
}

static gint
_vala_lambda2_ (MamanReturnBar* self,
                MamanReturnFoo* foo,
                gint arg)
{
	FILE* _tmp0_;
	gint _tmp1_;
	gint result;
	g_return_val_if_fail (MAMAN_IS_RETURN_FOO (foo), -1);
	_tmp0_ = stdout;
	fprintf (_tmp0_, " %d", arg);
	counter = counter + 1;
	_tmp1_ = counter;
	_vala_assert (_tmp1_ == 3, "++counter == 3");
	result = arg + 1;
	return result;
}

static gint
__vala_lambda2__maman_return_foo_int_activated (MamanReturnFoo* _sender,
                                                gint arg,
                                                gpointer self)
{
	gint result;
	result = _vala_lambda2_ ((MamanReturnBar*) self, _sender, arg);
	return result;
}

static gchar*
_vala_lambda3_ (MamanReturnBar* self,
                MamanReturnFoo* foo,
                const gchar* arg)
{
	FILE* _tmp0_;
	gint _tmp1_;
	gchar* _tmp2_;
	gchar* result;
	g_return_val_if_fail (MAMAN_IS_RETURN_FOO (foo), NULL);
	g_return_val_if_fail (arg != NULL, NULL);
	_tmp0_ = stdout;
	fprintf (_tmp0_, "%s", arg);
	counter = counter + 1;
	_tmp1_ = counter;
	_vala_assert (_tmp1_ == 5, "++counter == 5");
	_tmp2_ = g_strdup (" 6");
	result = _tmp2_;
	return result;
}

static gchar*
__vala_lambda3__maman_return_foo_string_activated (MamanReturnFoo* _sender,
                                                   const gchar* arg,
                                                   gpointer self)
{
	gchar* result;
	result = _vala_lambda3_ ((MamanReturnBar*) self, _sender, arg);
	return result;
}

void
maman_return_bar_run (MamanReturnBar* self)
{
	FILE* _tmp0_;
	gint _tmp1_;
	MamanReturnFoo* foo = NULL;
	MamanReturnFoo* _tmp2_;
	FILE* _tmp3_;
	gint _tmp4_ = 0;
	gint _tmp5_;
	FILE* _tmp6_;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	gint _tmp9_;
	FILE* _tmp10_;
	gint _tmp11_;
	g_return_if_fail (MAMAN_IS_RETURN_BAR (self));
	_tmp0_ = stdout;
	fprintf (_tmp0_, " 2");
	counter = counter + 1;
	_tmp1_ = counter;
	_vala_assert (_tmp1_ == 2, "++counter == 2");
	_tmp2_ = maman_return_foo_new ();
	foo = _tmp2_;
	g_signal_connect_object (foo, "int-activated", (GCallback) __vala_lambda2__maman_return_foo_int_activated, self, 0);
	g_signal_connect_object (foo, "string-activated", (GCallback) __vala_lambda3__maman_return_foo_string_activated, self, 0);
	_tmp3_ = stdout;
	g_signal_emit (foo, maman_return_foo_signals[MAMAN_RETURN_FOO_INT_ACTIVATED_SIGNAL], 0, 3, &_tmp4_);
	fprintf (_tmp3_, " %d", _tmp4_);
	counter = counter + 1;
	_tmp5_ = counter;
	_vala_assert (_tmp5_ == 4, "++counter == 4");
	_tmp6_ = stdout;
	g_signal_emit (foo, maman_return_foo_signals[MAMAN_RETURN_FOO_STRING_ACTIVATED_SIGNAL], 0, " 5", &_tmp7_);
	_tmp8_ = _tmp7_;
	fprintf (_tmp6_, "%s", _tmp8_);
	_g_free0 (_tmp8_);
	counter = counter + 1;
	_tmp9_ = counter;
	_vala_assert (_tmp9_ == 6, "++counter == 6");
	_tmp10_ = stdout;
	fprintf (_tmp10_, " 7");
	counter = counter + 1;
	_tmp11_ = counter;
	_vala_assert (_tmp11_ == 7, "++counter == 7");
	_g_object_unref0 (foo);
}

MamanReturnBar*
maman_return_bar_construct (GType object_type)
{
	MamanReturnBar * self = NULL;
	self = (MamanReturnBar*) g_object_new (object_type, NULL);
	return self;
}

MamanReturnBar*
maman_return_bar_new (void)
{
	return maman_return_bar_construct (MAMAN_TYPE_RETURN_BAR);
}

static void
maman_return_bar_class_init (MamanReturnBarClass * klass,
                             gpointer klass_data)
{
	maman_return_bar_parent_class = g_type_class_peek_parent (klass);
}

static void
maman_return_bar_instance_init (MamanReturnBar * self,
                                gpointer klass)
{
}

static GType
maman_return_bar_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (MamanReturnBarClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) maman_return_bar_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MamanReturnBar), 0, (GInstanceInitFunc) maman_return_bar_instance_init, NULL };
	GType maman_return_bar_type_id;
	maman_return_bar_type_id = g_type_register_static (G_TYPE_OBJECT, "MamanReturnBar", &g_define_type_info, 0);
	return maman_return_bar_type_id;
}

GType
maman_return_bar_get_type (void)
{
	static volatile gsize maman_return_bar_type_id__once = 0;
	if (g_once_init_enter (&maman_return_bar_type_id__once)) {
		GType maman_return_bar_type_id;
		maman_return_bar_type_id = maman_return_bar_get_type_once ();
		g_once_init_leave (&maman_return_bar_type_id__once, maman_return_bar_type_id);
	}
	return maman_return_bar_type_id__once;
}

static void
_vala_main (void)
{
	FILE* _tmp0_;
	MamanBar* bar = NULL;
	MamanBar* _tmp1_;
	FILE* _tmp2_;
	FILE* _tmp3_;
	MamanUserBar* user_bar = NULL;
	MamanUserBar* _tmp4_;
	FILE* _tmp5_;
	gint _tmp6_;
	FILE* _tmp7_;
	MamanReturnBar* return_bar = NULL;
	MamanReturnBar* _tmp8_;
	FILE* _tmp9_;
	gint _tmp10_;
	_tmp0_ = stdout;
	fprintf (_tmp0_, "Signal Test: 1");
	counter = 1;
	_tmp1_ = maman_bar_new ();
	bar = _tmp1_;
	maman_bar_run (bar);
	_tmp2_ = stdout;
	fprintf (_tmp2_, " 10\n");
	_tmp3_ = stdout;
	fprintf (_tmp3_, "User Signal Test: 1");
	counter = 1;
	_tmp4_ = maman_user_bar_new ();
	user_bar = _tmp4_;
	maman_user_bar_run (user_bar);
	_tmp5_ = stdout;
	fprintf (_tmp5_, " 6\n");
	counter = counter + 1;
	_tmp6_ = counter;
	_vala_assert (_tmp6_ == 6, "++counter == 6");
	_tmp7_ = stdout;
	fprintf (_tmp7_, "Signal Return Test: 1");
	counter = 1;
	_tmp8_ = maman_return_bar_new ();
	return_bar = _tmp8_;
	maman_return_bar_run (return_bar);
	_tmp9_ = stdout;
	fprintf (_tmp9_, " 8\n");
	counter = counter + 1;
	_tmp10_ = counter;
	_vala_assert (_tmp10_ == 8, "++counter == 8");
	_g_object_unref0 (return_bar);
	_g_object_unref0 (user_bar);
	_g_object_unref0 (bar);
}

int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}

