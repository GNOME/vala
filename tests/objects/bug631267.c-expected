/* objects_bug631267.c generated by valac, the Vala compiler
 * generated from objects_bug631267.vala, do not modify */

#include <glib-object.h>
#include <glib.h>
#include <string.h>
#include <stdlib.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_FOBJECT (fobject_get_type ())
#define FOBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FOBJECT, FObject))
#define FOBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FOBJECT, FObjectClass))
#define IS_FOBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FOBJECT))
#define IS_FOBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FOBJECT))
#define FOBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FOBJECT, FObjectClass))

typedef struct _FObject FObject;
typedef struct _FObjectClass FObjectClass;
typedef struct _FObjectPrivate FObjectPrivate;
enum  {
	FOBJECT_0_PROPERTY,
	FOBJECT_NUM_PROPERTIES
};
static GParamSpec* fobject_properties[FOBJECT_NUM_PROPERTIES];

#define TYPE_FSTRUCT (fstruct_get_type ())
typedef struct _FStruct FStruct;

#define TYPE_FOO (foo_get_type ())
#define FOO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FOO, Foo))
#define FOO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FOO, FooClass))
#define IS_FOO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FOO))
#define IS_FOO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FOO))
#define FOO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FOO, FooClass))

typedef struct _Foo Foo;
typedef struct _FooClass FooClass;
typedef struct _FooPrivate FooPrivate;
enum  {
	FOO_0_PROPERTY,
	FOO_S_PROPERTY,
	FOO_A_PROPERTY,
	FOO_I_PROPERTY,
	FOO_O_PROPERTY,
	FOO_T_PROPERTY,
	FOO_P_PROPERTY,
	FOO_FOO_PROPERTY,
	FOO_BAR_PROPERTY,
	FOO_NUM_PROPERTIES
};
static GParamSpec* foo_properties[FOO_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _FObject {
	GObject parent_instance;
	FObjectPrivate * priv;
};

struct _FObjectClass {
	GObjectClass parent_class;
};

struct _FStruct {
	gint i;
};

struct _Foo {
	GObject parent_instance;
	FooPrivate * priv;
};

struct _FooClass {
	GObjectClass parent_class;
};

struct _FooPrivate {
	gchar* _s;
	gchar** _a;
	gint _a_length1;
	gint __a_size_;
	gint _i;
	FObject* _o;
	FStruct _t;
	void* _p;
};

static gpointer fobject_parent_class = NULL;
static gint Foo_private_offset;
static gpointer foo_parent_class = NULL;

VALA_EXTERN GType fobject_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FObject, g_object_unref)
VALA_EXTERN FObject* fobject_new (void);
VALA_EXTERN FObject* fobject_construct (GType object_type);
static GType fobject_get_type_once (void);
VALA_EXTERN GType fstruct_get_type (void) G_GNUC_CONST ;
VALA_EXTERN FStruct* fstruct_dup (const FStruct* self);
VALA_EXTERN void fstruct_free (FStruct* self);
VALA_EXTERN GType foo_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Foo, g_object_unref)
VALA_EXTERN Foo* foo_new (void);
VALA_EXTERN Foo* foo_construct (GType object_type);
VALA_EXTERN const gchar* foo_get_s (Foo* self);
VALA_EXTERN void foo_set_s (Foo* self,
                const gchar* value);
VALA_EXTERN gchar** foo_get_a (Foo* self,
                   gint* result_length1);
VALA_EXTERN void foo_set_a (Foo* self,
                gchar** value,
                gint value_length1);
VALA_EXTERN gint foo_get_i (Foo* self);
VALA_EXTERN void foo_set_i (Foo* self,
                gint value);
VALA_EXTERN FObject* foo_get_o (Foo* self);
VALA_EXTERN void foo_set_o (Foo* self,
                FObject* value);
VALA_EXTERN void foo_get_t (Foo* self,
                FStruct * result);
VALA_EXTERN void foo_set_t (Foo* self,
                FStruct * value);
static gboolean _fstruct_equal (const FStruct * s1,
                         const FStruct * s2);
VALA_EXTERN void* foo_get_p (Foo* self);
VALA_EXTERN void foo_set_p (Foo* self,
                void* value);
VALA_EXTERN gint foo_get_foo (Foo* self);
VALA_EXTERN void foo_set_bar (Foo* self,
                  gint value);
static void foo_finalize (GObject * obj);
static GType foo_get_type_once (void);
static void _vala_foo_get_property (GObject * object,
                             guint property_id,
                             GValue * value,
                             GParamSpec * pspec);
static void _vala_foo_set_property (GObject * object,
                             guint property_id,
                             const GValue * value,
                             GParamSpec * pspec);
static void _vala_main (void);
static void _vala_lambda0_ (void);
static void __vala_lambda0__g_object_notify (GObject* _sender,
                                      GParamSpec* pspec,
                                      gpointer self);
static void _vala_lambda1_ (void);
static void __vala_lambda1__g_object_notify (GObject* _sender,
                                      GParamSpec* pspec,
                                      gpointer self);
static void _vala_lambda2_ (void);
static void __vala_lambda2__g_object_notify (GObject* _sender,
                                      GParamSpec* pspec,
                                      gpointer self);
static void _vala_lambda3_ (void);
static void __vala_lambda3__g_object_notify (GObject* _sender,
                                      GParamSpec* pspec,
                                      gpointer self);
static void _vala_lambda4_ (void);
static void __vala_lambda4__g_object_notify (GObject* _sender,
                                      GParamSpec* pspec,
                                      gpointer self);
static void _vala_lambda5_ (void);
static void __vala_lambda5__g_object_notify (GObject* _sender,
                                      GParamSpec* pspec,
                                      gpointer self);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);

FObject*
fobject_construct (GType object_type)
{
	FObject * self = NULL;
	self = (FObject*) g_object_new (object_type, NULL);
	return self;
}

FObject*
fobject_new (void)
{
	return fobject_construct (TYPE_FOBJECT);
}

static void
fobject_class_init (FObjectClass * klass,
                    gpointer klass_data)
{
	fobject_parent_class = g_type_class_peek_parent (klass);
}

static void
fobject_instance_init (FObject * self,
                       gpointer klass)
{
}

static GType
fobject_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FObjectClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fobject_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FObject), 0, (GInstanceInitFunc) fobject_instance_init, NULL };
	GType fobject_type_id;
	fobject_type_id = g_type_register_static (G_TYPE_OBJECT, "FObject", &g_define_type_info, 0);
	return fobject_type_id;
}

GType
fobject_get_type (void)
{
	static volatile gsize fobject_type_id__once = 0;
	if (g_once_init_enter (&fobject_type_id__once)) {
		GType fobject_type_id;
		fobject_type_id = fobject_get_type_once ();
		g_once_init_leave (&fobject_type_id__once, fobject_type_id);
	}
	return fobject_type_id__once;
}

FStruct*
fstruct_dup (const FStruct* self)
{
	FStruct* dup;
	dup = g_new0 (FStruct, 1);
	memcpy (dup, self, sizeof (FStruct));
	return dup;
}

void
fstruct_free (FStruct* self)
{
	g_free (self);
}

static GType
fstruct_get_type_once (void)
{
	GType fstruct_type_id;
	fstruct_type_id = g_boxed_type_register_static ("FStruct", (GBoxedCopyFunc) fstruct_dup, (GBoxedFreeFunc) fstruct_free);
	return fstruct_type_id;
}

GType
fstruct_get_type (void)
{
	static volatile gsize fstruct_type_id__once = 0;
	if (g_once_init_enter (&fstruct_type_id__once)) {
		GType fstruct_type_id;
		fstruct_type_id = fstruct_get_type_once ();
		g_once_init_leave (&fstruct_type_id__once, fstruct_type_id);
	}
	return fstruct_type_id__once;
}

static inline gpointer
foo_get_instance_private (Foo* self)
{
	return G_STRUCT_MEMBER_P (self, Foo_private_offset);
}

Foo*
foo_construct (GType object_type)
{
	Foo * self = NULL;
	self = (Foo*) g_object_new (object_type, NULL);
	return self;
}

Foo*
foo_new (void)
{
	return foo_construct (TYPE_FOO);
}

const gchar*
foo_get_s (Foo* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (IS_FOO (self), NULL);
	_tmp0_ = self->priv->_s;
	result = _tmp0_;
	return result;
}

void
foo_set_s (Foo* self,
           const gchar* value)
{
	gchar* old_value;
	g_return_if_fail (IS_FOO (self));
	old_value = foo_get_s (self);
	if (g_strcmp0 (value, old_value) != 0) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (value);
		_g_free0 (self->priv->_s);
		self->priv->_s = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, foo_properties[FOO_S_PROPERTY]);
	}
}

gchar**
foo_get_a (Foo* self,
           gint* result_length1)
{
	gchar** result;
	gchar** _tmp0_;
	gint _tmp0__length1;
	gchar** _tmp1_;
	gint _tmp1__length1;
	g_return_val_if_fail (IS_FOO (self), NULL);
	_tmp0_ = self->priv->_a;
	_tmp0__length1 = self->priv->_a_length1;
	_tmp1_ = _tmp0_;
	_tmp1__length1 = _tmp0__length1;
	if (result_length1) {
		*result_length1 = _tmp1__length1;
	}
	result = _tmp1_;
	return result;
}

void
foo_set_a (Foo* self,
           gchar** value,
           gint value_length1)
{
	gchar** old_value;
	gint old_value_length;
	g_return_if_fail (IS_FOO (self));
	old_value = foo_get_a (self, &old_value_length);
	if (old_value != value) {
		self->priv->_a = value;
		self->priv->_a_length1 = value_length1;
		self->priv->__a_size_ = self->priv->_a_length1;
		g_object_notify_by_pspec ((GObject *) self, foo_properties[FOO_A_PROPERTY]);
	}
}

gint
foo_get_i (Foo* self)
{
	gint result;
	g_return_val_if_fail (IS_FOO (self), -1);
	result = self->priv->_i;
	return result;
}

void
foo_set_i (Foo* self,
           gint value)
{
	gint old_value;
	g_return_if_fail (IS_FOO (self));
	old_value = foo_get_i (self);
	if (old_value != value) {
		self->priv->_i = value;
		g_object_notify_by_pspec ((GObject *) self, foo_properties[FOO_I_PROPERTY]);
	}
}

FObject*
foo_get_o (Foo* self)
{
	FObject* result;
	FObject* _tmp0_;
	g_return_val_if_fail (IS_FOO (self), NULL);
	_tmp0_ = self->priv->_o;
	result = _tmp0_;
	return result;
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

void
foo_set_o (Foo* self,
           FObject* value)
{
	FObject* old_value;
	g_return_if_fail (IS_FOO (self));
	old_value = foo_get_o (self);
	if (old_value != value) {
		FObject* _tmp0_;
		_tmp0_ = _g_object_ref0 (value);
		_g_object_unref0 (self->priv->_o);
		self->priv->_o = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, foo_properties[FOO_O_PROPERTY]);
	}
}

void
foo_get_t (Foo* self,
           FStruct * result)
{
	FStruct _tmp0_;
	g_return_if_fail (IS_FOO (self));
	_tmp0_ = self->priv->_t;
	*result = _tmp0_;
	return;
}

static gboolean
_fstruct_equal (const FStruct * s1,
                const FStruct * s2)
{
	if (s1 == s2) {
		return TRUE;
	}
	if (s1 == NULL) {
		return FALSE;
	}
	if (s2 == NULL) {
		return FALSE;
	}
	if (s1->i != s2->i) {
		return FALSE;
	}
	return TRUE;
}

void
foo_set_t (Foo* self,
           FStruct * value)
{
	FStruct old_value;
	g_return_if_fail (IS_FOO (self));
	foo_get_t (self, &old_value);
	if (_fstruct_equal (value, &old_value) != TRUE) {
		FStruct _tmp0_;
		_tmp0_ = *value;
		self->priv->_t = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, foo_properties[FOO_T_PROPERTY]);
	}
}

void*
foo_get_p (Foo* self)
{
	void* result;
	void* _tmp0_;
	g_return_val_if_fail (IS_FOO (self), NULL);
	_tmp0_ = self->priv->_p;
	result = _tmp0_;
	return result;
}

void
foo_set_p (Foo* self,
           void* value)
{
	void* old_value;
	g_return_if_fail (IS_FOO (self));
	old_value = foo_get_p (self);
	if (old_value != value) {
		self->priv->_p = value;
		g_object_notify_by_pspec ((GObject *) self, foo_properties[FOO_P_PROPERTY]);
	}
}

gint
foo_get_foo (Foo* self)
{
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (IS_FOO (self), -1);
	_tmp0_ = self->priv->_i;
	result = _tmp0_;
	return result;
}

void
foo_set_bar (Foo* self,
             gint value)
{
	g_return_if_fail (IS_FOO (self));
	foo_set_i (self, value);
	g_object_notify_by_pspec ((GObject *) self, foo_properties[FOO_BAR_PROPERTY]);
}

static void
foo_class_init (FooClass * klass,
                gpointer klass_data)
{
	foo_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &Foo_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_foo_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_foo_set_property;
	G_OBJECT_CLASS (klass)->finalize = foo_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOO_S_PROPERTY, foo_properties[FOO_S_PROPERTY] = g_param_spec_string ("s", "s", "s", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOO_A_PROPERTY, foo_properties[FOO_A_PROPERTY] = g_param_spec_boxed ("a", "a", "a", G_TYPE_STRV, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOO_I_PROPERTY, foo_properties[FOO_I_PROPERTY] = g_param_spec_int ("i", "i", "i", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOO_O_PROPERTY, foo_properties[FOO_O_PROPERTY] = g_param_spec_object ("o", "o", "o", TYPE_FOBJECT, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOO_T_PROPERTY, foo_properties[FOO_T_PROPERTY] = g_param_spec_boxed ("t", "t", "t", TYPE_FSTRUCT, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOO_P_PROPERTY, foo_properties[FOO_P_PROPERTY] = g_param_spec_pointer ("p", "p", "p", G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOO_FOO_PROPERTY, foo_properties[FOO_FOO_PROPERTY] = g_param_spec_int ("foo", "foo", "foo", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOO_BAR_PROPERTY, foo_properties[FOO_BAR_PROPERTY] = g_param_spec_int ("bar", "bar", "bar", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_WRITABLE));
}

static void
foo_instance_init (Foo * self,
                   gpointer klass)
{
	self->priv = foo_get_instance_private (self);
}

static void
foo_finalize (GObject * obj)
{
	Foo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FOO, Foo);
	_g_free0 (self->priv->_s);
	_g_object_unref0 (self->priv->_o);
	G_OBJECT_CLASS (foo_parent_class)->finalize (obj);
}

static GType
foo_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FooClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) foo_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Foo), 0, (GInstanceInitFunc) foo_instance_init, NULL };
	GType foo_type_id;
	foo_type_id = g_type_register_static (G_TYPE_OBJECT, "Foo", &g_define_type_info, 0);
	Foo_private_offset = g_type_add_instance_private (foo_type_id, sizeof (FooPrivate));
	return foo_type_id;
}

GType
foo_get_type (void)
{
	static volatile gsize foo_type_id__once = 0;
	if (g_once_init_enter (&foo_type_id__once)) {
		GType foo_type_id;
		foo_type_id = foo_get_type_once ();
		g_once_init_leave (&foo_type_id__once, foo_type_id);
	}
	return foo_type_id__once;
}

static void
_vala_foo_get_property (GObject * object,
                        guint property_id,
                        GValue * value,
                        GParamSpec * pspec)
{
	Foo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_FOO, Foo);
	switch (property_id) {
		case FOO_S_PROPERTY:
		g_value_set_string (value, foo_get_s (self));
		break;
		case FOO_A_PROPERTY:
		{
			int length;
			g_value_set_boxed (value, foo_get_a (self, &length));
		}
		break;
		case FOO_I_PROPERTY:
		g_value_set_int (value, foo_get_i (self));
		break;
		case FOO_O_PROPERTY:
		g_value_set_object (value, foo_get_o (self));
		break;
		case FOO_T_PROPERTY:
		{
			FStruct boxed;
			foo_get_t (self, &boxed);
			g_value_set_boxed (value, &boxed);
		}
		break;
		case FOO_P_PROPERTY:
		g_value_set_pointer (value, foo_get_p (self));
		break;
		case FOO_FOO_PROPERTY:
		g_value_set_int (value, foo_get_foo (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_foo_set_property (GObject * object,
                        guint property_id,
                        const GValue * value,
                        GParamSpec * pspec)
{
	Foo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_FOO, Foo);
	switch (property_id) {
		case FOO_S_PROPERTY:
		foo_set_s (self, g_value_get_string (value));
		break;
		case FOO_A_PROPERTY:
		{
			gpointer boxed;
			boxed = g_value_get_boxed (value);
			foo_set_a (self, boxed, (boxed == NULL) ? 0 : g_strv_length (boxed));
		}
		break;
		case FOO_I_PROPERTY:
		foo_set_i (self, g_value_get_int (value));
		break;
		case FOO_O_PROPERTY:
		foo_set_o (self, g_value_get_object (value));
		break;
		case FOO_T_PROPERTY:
		foo_set_t (self, g_value_get_boxed (value));
		break;
		case FOO_P_PROPERTY:
		foo_set_p (self, g_value_get_pointer (value));
		break;
		case FOO_BAR_PROPERTY:
		foo_set_bar (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_lambda0_ (void)
{
	g_error ("objects_bug631267.vala:39: string-type equality failed");
}

static void
__vala_lambda0__g_object_notify (GObject* _sender,
                                 GParamSpec* pspec,
                                 gpointer self)
{
	_vala_lambda0_ ();
}

static void
_vala_lambda1_ (void)
{
	g_error ("objects_bug631267.vala:40: array-type equality failed");
}

static void
__vala_lambda1__g_object_notify (GObject* _sender,
                                 GParamSpec* pspec,
                                 gpointer self)
{
	_vala_lambda1_ ();
}

static void
_vala_lambda2_ (void)
{
	g_error ("objects_bug631267.vala:41: simple-type equality failed");
}

static void
__vala_lambda2__g_object_notify (GObject* _sender,
                                 GParamSpec* pspec,
                                 gpointer self)
{
	_vala_lambda2_ ();
}

static void
_vala_lambda3_ (void)
{
	g_error ("objects_bug631267.vala:42: object-type equality failed");
}

static void
__vala_lambda3__g_object_notify (GObject* _sender,
                                 GParamSpec* pspec,
                                 gpointer self)
{
	_vala_lambda3_ ();
}

static void
_vala_lambda4_ (void)
{
	g_error ("objects_bug631267.vala:43: struct-type equality failed");
}

static void
__vala_lambda4__g_object_notify (GObject* _sender,
                                 GParamSpec* pspec,
                                 gpointer self)
{
	_vala_lambda4_ ();
}

static void
_vala_lambda5_ (void)
{
	g_error ("objects_bug631267.vala:44: pointer-type equality failed");
}

static void
__vala_lambda5__g_object_notify (GObject* _sender,
                                 GParamSpec* pspec,
                                 gpointer self)
{
	_vala_lambda5_ ();
}

static void
_vala_main (void)
{
	gchar* s = NULL;
	gchar* _tmp0_;
	gchar** a = NULL;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar** _tmp3_;
	gint a_length1;
	gint _a_size_;
	gint i = 0;
	FObject* o = NULL;
	FObject* _tmp4_;
	FStruct t = {0};
	FStruct _tmp5_ = {0};
	void* p = NULL;
	Foo* foo = NULL;
	Foo* _tmp6_;
	FStruct _tmp7_;
	FStruct _tmp8_;
	_tmp0_ = g_strdup ("bar");
	s = _tmp0_;
	_tmp1_ = g_strdup ("foo");
	_tmp2_ = g_strdup ("baz");
	_tmp3_ = g_new0 (gchar*, 2 + 1);
	_tmp3_[0] = _tmp1_;
	_tmp3_[1] = _tmp2_;
	a = _tmp3_;
	a_length1 = 2;
	_a_size_ = a_length1;
	i = 42;
	_tmp4_ = fobject_new ();
	o = _tmp4_;
	t = _tmp5_;
	p = &o;
	_tmp6_ = foo_new ();
	foo = _tmp6_;
	foo_set_s (foo, s);
	foo_set_a (foo, a, a_length1);
	foo_set_i (foo, i);
	foo_set_o (foo, o);
	_tmp7_ = t;
	foo_set_t (foo, &_tmp7_);
	foo_set_p (foo, p);
	g_signal_connect (G_TYPE_CHECK_INSTANCE_CAST (foo, G_TYPE_OBJECT, GObject), "notify::s", (GCallback) __vala_lambda0__g_object_notify, NULL);
	g_signal_connect (G_TYPE_CHECK_INSTANCE_CAST (foo, G_TYPE_OBJECT, GObject), "notify::a", (GCallback) __vala_lambda1__g_object_notify, NULL);
	g_signal_connect (G_TYPE_CHECK_INSTANCE_CAST (foo, G_TYPE_OBJECT, GObject), "notify::i", (GCallback) __vala_lambda2__g_object_notify, NULL);
	g_signal_connect (G_TYPE_CHECK_INSTANCE_CAST (foo, G_TYPE_OBJECT, GObject), "notify::o", (GCallback) __vala_lambda3__g_object_notify, NULL);
	g_signal_connect (G_TYPE_CHECK_INSTANCE_CAST (foo, G_TYPE_OBJECT, GObject), "notify::t", (GCallback) __vala_lambda4__g_object_notify, NULL);
	g_signal_connect (G_TYPE_CHECK_INSTANCE_CAST (foo, G_TYPE_OBJECT, GObject), "notify::p", (GCallback) __vala_lambda5__g_object_notify, NULL);
	foo_set_s (foo, s);
	foo_set_a (foo, a, a_length1);
	foo_set_i (foo, i);
	foo_set_o (foo, o);
	_tmp8_ = t;
	foo_set_t (foo, &_tmp8_);
	foo_set_p (foo, p);
	_g_object_unref0 (foo);
	_g_object_unref0 (o);
	a = (_vala_array_free (a, a_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (s);
}

int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

