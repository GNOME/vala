/* objects_property_real_struct_assignment.c generated by valac, the Vala compiler
 * generated from objects_property_real_struct_assignment.vala, do not modify */

#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_FOO (foo_get_type ())
typedef struct _Foo Foo;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_MANAM (manam_get_type ())
#define MANAM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MANAM, Manam))
#define MANAM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MANAM, ManamClass))
#define IS_MANAM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MANAM))
#define IS_MANAM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MANAM))
#define MANAM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MANAM, ManamClass))

typedef struct _Manam Manam;
typedef struct _ManamClass ManamClass;
typedef struct _ManamPrivate ManamPrivate;
enum  {
	MANAM_0_PROPERTY,
	MANAM_FAZ_PROPERTY,
	MANAM_NUM_PROPERTIES
};
static GParamSpec* manam_properties[MANAM_NUM_PROPERTIES];

#define TYPE_BAR (bar_get_type ())
#define BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BAR, Bar))
#define BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BAR, BarClass))
#define IS_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BAR))
#define IS_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BAR))
#define BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BAR, BarClass))

typedef struct _Bar Bar;
typedef struct _BarClass BarClass;
typedef struct _BarPrivate BarPrivate;
enum  {
	BAR_0_PROPERTY,
	BAR_FOO_PROPERTY,
	BAR_NUM_PROPERTIES
};
static GParamSpec* bar_properties[BAR_NUM_PROPERTIES];
#define _foo_free0(var) ((var == NULL) ? NULL : (var = (foo_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _Foo {
	gchar* s;
};

struct _Manam {
	GObject parent_instance;
	ManamPrivate * priv;
};

struct _ManamClass {
	GObjectClass parent_class;
	void (*get_faz) (Manam* self, Foo * result);
	void (*set_faz) (Manam* self, Foo * value);
};

struct _ManamPrivate {
	Foo _faz;
};

struct _Bar {
	Manam parent_instance;
	BarPrivate * priv;
};

struct _BarClass {
	ManamClass parent_class;
};

struct _BarPrivate {
	Foo _foo;
};

static gint Manam_private_offset;
static gpointer manam_parent_class = NULL;
static gint Bar_private_offset;
static gpointer bar_parent_class = NULL;

VALA_EXTERN GType foo_get_type (void) G_GNUC_CONST ;
VALA_EXTERN Foo* foo_dup (const Foo* self);
VALA_EXTERN void foo_free (Foo* self);
VALA_EXTERN void foo_copy (const Foo* self,
               Foo* dest);
VALA_EXTERN void foo_destroy (Foo* self);
G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC (Foo, foo_destroy)
VALA_EXTERN Foo* get_foo (void);
VALA_EXTERN GType manam_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Manam, g_object_unref)
VALA_EXTERN void manam_get_faz (Manam* self,
                    Foo * result);
VALA_EXTERN void manam_set_faz (Manam* self,
                    Foo * value);
VALA_EXTERN Manam* manam_new (void);
VALA_EXTERN Manam* manam_construct (GType object_type);
static gboolean _foo_equal (const Foo * s1,
                     const Foo * s2);
static void manam_finalize (GObject * obj);
static GType manam_get_type_once (void);
static void _vala_manam_get_property (GObject * object,
                               guint property_id,
                               GValue * value,
                               GParamSpec * pspec);
static void _vala_manam_set_property (GObject * object,
                               guint property_id,
                               const GValue * value,
                               GParamSpec * pspec);
VALA_EXTERN GType bar_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Bar, g_object_unref)
VALA_EXTERN Bar* bar_new (void);
VALA_EXTERN Bar* bar_construct (GType object_type);
VALA_EXTERN void bar_set_foo (Bar* self,
                  Foo * value);
VALA_EXTERN void bar_get_foo (Bar* self,
                  Foo * result);
static void bar_finalize (GObject * obj);
static GType bar_get_type_once (void);
static void _vala_bar_get_property (GObject * object,
                             guint property_id,
                             GValue * value,
                             GParamSpec * pspec);
static void _vala_bar_set_property (GObject * object,
                             guint property_id,
                             const GValue * value,
                             GParamSpec * pspec);
static void _vala_main (void);

void
foo_copy (const Foo* self,
          Foo* dest)
{
	const gchar* _tmp0_;
	gchar* _tmp1_;
	_tmp0_ = (*self).s;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*dest).s);
	(*dest).s = _tmp1_;
}

void
foo_destroy (Foo* self)
{
	_g_free0 ((*self).s);
}

Foo*
foo_dup (const Foo* self)
{
	Foo* dup;
	dup = g_new0 (Foo, 1);
	foo_copy (self, dup);
	return dup;
}

void
foo_free (Foo* self)
{
	foo_destroy (self);
	g_free (self);
}

static GType
foo_get_type_once (void)
{
	GType foo_type_id;
	foo_type_id = g_boxed_type_register_static ("Foo", (GBoxedCopyFunc) foo_dup, (GBoxedFreeFunc) foo_free);
	return foo_type_id;
}

GType
foo_get_type (void)
{
	static volatile gsize foo_type_id__once = 0;
	if (g_once_init_enter (&foo_type_id__once)) {
		GType foo_type_id;
		foo_type_id = foo_get_type_once ();
		g_once_init_leave (&foo_type_id__once, foo_type_id);
	}
	return foo_type_id__once;
}

static gpointer
_foo_dup0 (gpointer self)
{
	return self ? foo_dup (self) : NULL;
}

Foo*
get_foo (void)
{
	gchar* _tmp0_;
	Foo _tmp1_ = {0};
	Foo _tmp2_;
	Foo* _tmp3_;
	Foo* _tmp4_;
	Foo* result;
	_tmp0_ = g_strdup ("foo");
	_g_free0 (_tmp1_.s);
	_tmp1_.s = _tmp0_;
	_tmp2_ = _tmp1_;
	_tmp3_ = _foo_dup0 (&_tmp2_);
	_tmp4_ = _tmp3_;
	foo_destroy (&_tmp2_);
	result = _tmp4_;
	return result;
}

static inline gpointer
manam_get_instance_private (Manam* self)
{
	return G_STRUCT_MEMBER_P (self, Manam_private_offset);
}

Manam*
manam_construct (GType object_type)
{
	Manam * self = NULL;
	self = (Manam*) g_object_new (object_type, NULL);
	return self;
}

Manam*
manam_new (void)
{
	return manam_construct (TYPE_MANAM);
}

void
manam_get_faz (Manam* self,
               Foo * result)
{
	ManamClass* _klass_;
	g_return_if_fail (IS_MANAM (self));
	_klass_ = MANAM_GET_CLASS (self);
	if (_klass_->get_faz) {
		_klass_->get_faz (self, result);
	}
	return;
}

static void
manam_real_get_faz (Manam* base,
                    Foo * result)
{
	Manam* self;
	Foo _tmp0_;
	self = base;
	_tmp0_ = self->priv->_faz;
	*result = _tmp0_;
	return;
}

void
manam_set_faz (Manam* self,
               Foo * value)
{
	ManamClass* _klass_;
	g_return_if_fail (IS_MANAM (self));
	_klass_ = MANAM_GET_CLASS (self);
	if (_klass_->set_faz) {
		_klass_->set_faz (self, value);
	}
}

static gboolean
_foo_equal (const Foo * s1,
            const Foo * s2)
{
	if (s1 == s2) {
		return TRUE;
	}
	if (s1 == NULL) {
		return FALSE;
	}
	if (s2 == NULL) {
		return FALSE;
	}
	if (g_strcmp0 (s1->s, s2->s)) {
		return FALSE;
	}
	return TRUE;
}

static void
manam_real_set_faz (Manam* base,
                    Foo * value)
{
	Manam* self;
	Foo old_value;
	self = base;
	manam_real_get_faz (base, &old_value);
	if (_foo_equal (value, &old_value) != TRUE) {
		Foo _tmp0_;
		Foo _tmp1_;
		Foo _tmp2_ = {0};
		_tmp0_ = *value;
		_tmp1_ = _tmp0_;
		foo_copy (&_tmp1_, &_tmp2_);
		foo_destroy (&self->priv->_faz);
		self->priv->_faz = _tmp2_;
		g_object_notify_by_pspec ((GObject *) self, manam_properties[MANAM_FAZ_PROPERTY]);
	}
}

static void
manam_class_init (ManamClass * klass,
                  gpointer klass_data)
{
	manam_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &Manam_private_offset);
	MANAM_CLASS (klass)->get_faz = (void (*) (Manam*, Foo*)) manam_real_get_faz;
	MANAM_CLASS (klass)->set_faz = (void (*) (Manam*, Foo*)) manam_real_set_faz;
	G_OBJECT_CLASS (klass)->get_property = _vala_manam_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_manam_set_property;
	G_OBJECT_CLASS (klass)->finalize = manam_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), MANAM_FAZ_PROPERTY, manam_properties[MANAM_FAZ_PROPERTY] = g_param_spec_boxed ("faz", "faz", "faz", TYPE_FOO, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}

static void
manam_instance_init (Manam * self,
                     gpointer klass)
{
	self->priv = manam_get_instance_private (self);
}

static void
manam_finalize (GObject * obj)
{
	Manam * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_MANAM, Manam);
	foo_destroy (&self->priv->_faz);
	G_OBJECT_CLASS (manam_parent_class)->finalize (obj);
}

static GType
manam_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (ManamClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) manam_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Manam), 0, (GInstanceInitFunc) manam_instance_init, NULL };
	GType manam_type_id;
	manam_type_id = g_type_register_static (G_TYPE_OBJECT, "Manam", &g_define_type_info, 0);
	Manam_private_offset = g_type_add_instance_private (manam_type_id, sizeof (ManamPrivate));
	return manam_type_id;
}

GType
manam_get_type (void)
{
	static volatile gsize manam_type_id__once = 0;
	if (g_once_init_enter (&manam_type_id__once)) {
		GType manam_type_id;
		manam_type_id = manam_get_type_once ();
		g_once_init_leave (&manam_type_id__once, manam_type_id);
	}
	return manam_type_id__once;
}

static void
_vala_manam_get_property (GObject * object,
                          guint property_id,
                          GValue * value,
                          GParamSpec * pspec)
{
	Manam * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_MANAM, Manam);
	switch (property_id) {
		case MANAM_FAZ_PROPERTY:
		{
			Foo boxed;
			manam_get_faz (self, &boxed);
			g_value_set_boxed (value, &boxed);
		}
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_manam_set_property (GObject * object,
                          guint property_id,
                          const GValue * value,
                          GParamSpec * pspec)
{
	Manam * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_MANAM, Manam);
	switch (property_id) {
		case MANAM_FAZ_PROPERTY:
		manam_set_faz (self, g_value_get_boxed (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
bar_get_instance_private (Bar* self)
{
	return G_STRUCT_MEMBER_P (self, Bar_private_offset);
}

Bar*
bar_construct (GType object_type)
{
	Bar * self = NULL;
	self = (Bar*) manam_construct (object_type);
	{
		Foo* _tmp0_;
		Foo* _tmp1_;
		Foo _tmp2_;
		_tmp0_ = get_foo ();
		_tmp1_ = _tmp0_;
		_tmp2_ = *_tmp1_;
		bar_set_foo (self, &_tmp2_);
		_foo_free0 (_tmp1_);
	}
	{
		Foo* _tmp3_;
		Foo* _tmp4_;
		Foo _tmp5_;
		_tmp3_ = get_foo ();
		_tmp4_ = _tmp3_;
		_tmp5_ = *_tmp4_;
		MANAM_CLASS (bar_parent_class)->set_faz (G_TYPE_CHECK_INSTANCE_CAST (self, TYPE_MANAM, Manam), &_tmp5_);
		_foo_free0 (_tmp4_);
	}
	{
		Foo* _tmp6_;
		Foo _tmp7_;
		_tmp6_ = get_foo ();
		_tmp7_ = (Foo) (*_tmp6_);
		bar_set_foo (self, &_tmp7_);
		foo_destroy (&_tmp7_);
		_g_free0 (_tmp6_);
	}
	{
		Foo* _tmp8_;
		Foo _tmp9_;
		_tmp8_ = get_foo ();
		_tmp9_ = (Foo) (*_tmp8_);
		MANAM_CLASS (bar_parent_class)->set_faz (G_TYPE_CHECK_INSTANCE_CAST (self, TYPE_MANAM, Manam), &_tmp9_);
		foo_destroy (&_tmp9_);
		_g_free0 (_tmp8_);
	}
	{
		Foo* _tmp10_;
		Foo _tmp11_;
		_tmp10_ = get_foo ();
		_tmp11_ = (Foo) (*_tmp10_);
		bar_set_foo (self, &_tmp11_);
		foo_destroy (&_tmp11_);
		_g_free0 (_tmp10_);
	}
	{
		Foo* _tmp12_;
		Foo _tmp13_;
		_tmp12_ = get_foo ();
		_tmp13_ = (Foo) (*_tmp12_);
		MANAM_CLASS (bar_parent_class)->set_faz (G_TYPE_CHECK_INSTANCE_CAST (self, TYPE_MANAM, Manam), &_tmp13_);
		foo_destroy (&_tmp13_);
		_g_free0 (_tmp12_);
	}
	{
		Foo* f = NULL;
		Foo* _tmp14_;
		Foo _tmp15_;
		_tmp14_ = get_foo ();
		f = _tmp14_;
		_tmp15_ = (Foo) (*f);
		bar_set_foo (self, &_tmp15_);
		_foo_free0 (f);
	}
	{
		Foo* f = NULL;
		Foo* _tmp16_;
		Foo _tmp17_;
		_tmp16_ = get_foo ();
		f = _tmp16_;
		_tmp17_ = (Foo) (*f);
		MANAM_CLASS (bar_parent_class)->set_faz (G_TYPE_CHECK_INSTANCE_CAST (self, TYPE_MANAM, Manam), &_tmp17_);
		_foo_free0 (f);
	}
	{
		Foo* f = NULL;
		Foo* _tmp18_;
		Foo _tmp19_;
		_tmp18_ = get_foo ();
		f = _tmp18_;
		_tmp19_ = (Foo) (*f);
		bar_set_foo (self, &_tmp19_);
		_foo_free0 (f);
	}
	{
		Foo* f = NULL;
		Foo* _tmp20_;
		Foo _tmp21_;
		_tmp20_ = get_foo ();
		f = _tmp20_;
		_tmp21_ = (Foo) (*f);
		MANAM_CLASS (bar_parent_class)->set_faz (G_TYPE_CHECK_INSTANCE_CAST (self, TYPE_MANAM, Manam), &_tmp21_);
		_foo_free0 (f);
	}
	return self;
}

Bar*
bar_new (void)
{
	return bar_construct (TYPE_BAR);
}

void
bar_get_foo (Bar* self,
             Foo * result)
{
	Foo _tmp0_;
	g_return_if_fail (IS_BAR (self));
	_tmp0_ = self->priv->_foo;
	*result = _tmp0_;
	return;
}

void
bar_set_foo (Bar* self,
             Foo * value)
{
	Foo old_value;
	g_return_if_fail (IS_BAR (self));
	bar_get_foo (self, &old_value);
	if (_foo_equal (value, &old_value) != TRUE) {
		Foo _tmp0_;
		Foo _tmp1_;
		Foo _tmp2_ = {0};
		_tmp0_ = *value;
		_tmp1_ = _tmp0_;
		foo_copy (&_tmp1_, &_tmp2_);
		foo_destroy (&self->priv->_foo);
		self->priv->_foo = _tmp2_;
		g_object_notify_by_pspec ((GObject *) self, bar_properties[BAR_FOO_PROPERTY]);
	}
}

static void
bar_class_init (BarClass * klass,
                gpointer klass_data)
{
	bar_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &Bar_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_bar_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_bar_set_property;
	G_OBJECT_CLASS (klass)->finalize = bar_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), BAR_FOO_PROPERTY, bar_properties[BAR_FOO_PROPERTY] = g_param_spec_boxed ("foo", "foo", "foo", TYPE_FOO, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}

static void
bar_instance_init (Bar * self,
                   gpointer klass)
{
	self->priv = bar_get_instance_private (self);
}

static void
bar_finalize (GObject * obj)
{
	Bar * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_BAR, Bar);
	foo_destroy (&self->priv->_foo);
	G_OBJECT_CLASS (bar_parent_class)->finalize (obj);
}

static GType
bar_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (BarClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) bar_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Bar), 0, (GInstanceInitFunc) bar_instance_init, NULL };
	GType bar_type_id;
	bar_type_id = g_type_register_static (TYPE_MANAM, "Bar", &g_define_type_info, 0);
	Bar_private_offset = g_type_add_instance_private (bar_type_id, sizeof (BarPrivate));
	return bar_type_id;
}

GType
bar_get_type (void)
{
	static volatile gsize bar_type_id__once = 0;
	if (g_once_init_enter (&bar_type_id__once)) {
		GType bar_type_id;
		bar_type_id = bar_get_type_once ();
		g_once_init_leave (&bar_type_id__once, bar_type_id);
	}
	return bar_type_id__once;
}

static void
_vala_bar_get_property (GObject * object,
                        guint property_id,
                        GValue * value,
                        GParamSpec * pspec)
{
	Bar * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_BAR, Bar);
	switch (property_id) {
		case BAR_FOO_PROPERTY:
		{
			Foo boxed;
			bar_get_foo (self, &boxed);
			g_value_set_boxed (value, &boxed);
		}
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_bar_set_property (GObject * object,
                        guint property_id,
                        const GValue * value,
                        GParamSpec * pspec)
{
	Bar * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_BAR, Bar);
	switch (property_id) {
		case BAR_FOO_PROPERTY:
		bar_set_foo (self, g_value_get_boxed (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_main (void)
{
	Bar* bar = NULL;
	Bar* _tmp0_;
	_tmp0_ = bar_new ();
	bar = _tmp0_;
	_g_object_unref0 (bar);
}

int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}

