/* objects_bug702736.c generated by valac, the Vala compiler
 * generated from objects_bug702736.vala, do not modify */

#include <glib-object.h>
#include <glib.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_CLASS_A (class_a_get_type ())
#define CLASS_A(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CLASS_A, ClassA))
#define CLASS_A_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CLASS_A, ClassAClass))
#define IS_CLASS_A(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CLASS_A))
#define IS_CLASS_A_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CLASS_A))
#define CLASS_A_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CLASS_A, ClassAClass))

typedef struct _ClassA ClassA;
typedef struct _ClassAClass ClassAClass;
typedef struct _ClassAPrivate ClassAPrivate;
enum  {
	CLASS_A_0_PROPERTY,
	CLASS_A_FLAGS_PROPERTY,
	CLASS_A_NUM_PROPERTIES
};
static GParamSpec* class_a_properties[CLASS_A_NUM_PROPERTIES];

#define TYPE_CLASS_B (class_b_get_type ())
#define CLASS_B(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CLASS_B, ClassB))
#define CLASS_B_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CLASS_B, ClassBClass))
#define IS_CLASS_B(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CLASS_B))
#define IS_CLASS_B_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CLASS_B))
#define CLASS_B_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CLASS_B, ClassBClass))

typedef struct _ClassB ClassB;
typedef struct _ClassBClass ClassBClass;
typedef struct _ClassBPrivate ClassBPrivate;
enum  {
	CLASS_B_0_PROPERTY,
	CLASS_B_FLAGS_PROPERTY,
	CLASS_B_NUM_PROPERTIES
};
static GParamSpec* class_b_properties[CLASS_B_NUM_PROPERTIES];

#define TYPE_CLASS_C (class_c_get_type ())
#define CLASS_C(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CLASS_C, ClassC))
#define CLASS_C_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CLASS_C, ClassCClass))
#define IS_CLASS_C(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CLASS_C))
#define IS_CLASS_C_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CLASS_C))
#define CLASS_C_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CLASS_C, ClassCClass))

typedef struct _ClassC ClassC;
typedef struct _ClassCClass ClassCClass;
typedef struct _ClassCPrivate ClassCPrivate;
enum  {
	CLASS_C_0_PROPERTY,
	CLASS_C_NUM_PROPERTIES
};
static GParamSpec* class_c_properties[CLASS_C_NUM_PROPERTIES];

#define TYPE_CLASS_D (class_d_get_type ())
#define CLASS_D(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CLASS_D, ClassD))
#define CLASS_D_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CLASS_D, ClassDClass))
#define IS_CLASS_D(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CLASS_D))
#define IS_CLASS_D_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CLASS_D))
#define CLASS_D_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CLASS_D, ClassDClass))

typedef struct _ClassD ClassD;
typedef struct _ClassDClass ClassDClass;
typedef struct _ClassDPrivate ClassDPrivate;
enum  {
	CLASS_D_0_PROPERTY,
	CLASS_D_FLAGS_PROPERTY,
	CLASS_D_NUM_PROPERTIES
};
static GParamSpec* class_d_properties[CLASS_D_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _ClassA {
	GObject parent_instance;
	ClassAPrivate * priv;
};

struct _ClassAClass {
	GObjectClass parent_class;
	gint (*get_flags) (ClassA* self);
};

struct _ClassB {
	ClassA parent_instance;
	ClassBPrivate * priv;
};

struct _ClassBClass {
	ClassAClass parent_class;
};

struct _ClassC {
	ClassB parent_instance;
	ClassCPrivate * priv;
};

struct _ClassCClass {
	ClassBClass parent_class;
};

struct _ClassD {
	ClassC parent_instance;
	ClassDPrivate * priv;
};

struct _ClassDClass {
	ClassCClass parent_class;
};

static gpointer class_a_parent_class = NULL;
static gpointer class_b_parent_class = NULL;
static gpointer class_c_parent_class = NULL;
static gpointer class_d_parent_class = NULL;

VALA_EXTERN GType class_a_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClassA, g_object_unref)
VALA_EXTERN ClassA* class_a_construct (GType object_type);
VALA_EXTERN gint class_a_get_flags (ClassA* self);
static GType class_a_get_type_once (void);
static void _vala_class_a_get_property (GObject * object,
                                 guint property_id,
                                 GValue * value,
                                 GParamSpec * pspec);
VALA_EXTERN GType class_b_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClassB, g_object_unref)
VALA_EXTERN ClassB* class_b_new (void);
VALA_EXTERN ClassB* class_b_construct (GType object_type);
static GType class_b_get_type_once (void);
static void _vala_class_b_get_property (GObject * object,
                                 guint property_id,
                                 GValue * value,
                                 GParamSpec * pspec);
VALA_EXTERN GType class_c_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClassC, g_object_unref)
VALA_EXTERN void class_c_foo (ClassC* self);
VALA_EXTERN ClassC* class_c_new (void);
VALA_EXTERN ClassC* class_c_construct (GType object_type);
static GType class_c_get_type_once (void);
VALA_EXTERN GType class_d_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClassD, g_object_unref)
VALA_EXTERN ClassD* class_d_new (void);
VALA_EXTERN ClassD* class_d_construct (GType object_type);
static GType class_d_get_type_once (void);
static void _vala_class_d_get_property (GObject * object,
                                 guint property_id,
                                 GValue * value,
                                 GParamSpec * pspec);
static void _vala_main (void);

ClassA*
class_a_construct (GType object_type)
{
	ClassA * self = NULL;
	self = (ClassA*) g_object_new (object_type, NULL);
	return self;
}

gint
class_a_get_flags (ClassA* self)
{
	ClassAClass* _klass_;
	g_return_val_if_fail (IS_CLASS_A (self), 0);
	_klass_ = CLASS_A_GET_CLASS (self);
	if (_klass_->get_flags) {
		return _klass_->get_flags (self);
	}
	return -1;
}

static void
class_a_class_init (ClassAClass * klass,
                    gpointer klass_data)
{
	class_a_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->get_property = _vala_class_a_get_property;
	g_object_class_install_property (G_OBJECT_CLASS (klass), CLASS_A_FLAGS_PROPERTY, class_a_properties[CLASS_A_FLAGS_PROPERTY] = g_param_spec_int ("flags", "flags", "flags", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}

static void
class_a_instance_init (ClassA * self,
                       gpointer klass)
{
}

static GType
class_a_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (ClassAClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) class_a_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ClassA), 0, (GInstanceInitFunc) class_a_instance_init, NULL };
	GType class_a_type_id;
	class_a_type_id = g_type_register_static (G_TYPE_OBJECT, "ClassA", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
	return class_a_type_id;
}

GType
class_a_get_type (void)
{
	static volatile gsize class_a_type_id__once = 0;
	if (g_once_init_enter (&class_a_type_id__once)) {
		GType class_a_type_id;
		class_a_type_id = class_a_get_type_once ();
		g_once_init_leave (&class_a_type_id__once, class_a_type_id);
	}
	return class_a_type_id__once;
}

static void
_vala_class_a_get_property (GObject * object,
                            guint property_id,
                            GValue * value,
                            GParamSpec * pspec)
{
	ClassA * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CLASS_A, ClassA);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

ClassB*
class_b_construct (GType object_type)
{
	ClassB * self = NULL;
	self = (ClassB*) class_a_construct (object_type);
	return self;
}

ClassB*
class_b_new (void)
{
	return class_b_construct (TYPE_CLASS_B);
}

static gint
class_b_real_get_flags (ClassA* base)
{
	gint result;
	ClassB* self;
	self = G_TYPE_CHECK_INSTANCE_CAST (base, TYPE_CLASS_B, ClassB);
	result = 1;
	return result;
}

static void
class_b_class_init (ClassBClass * klass,
                    gpointer klass_data)
{
	class_b_parent_class = g_type_class_peek_parent (klass);
	CLASS_A_CLASS (klass)->get_flags = (gint (*) (ClassA*)) class_b_real_get_flags;
	G_OBJECT_CLASS (klass)->get_property = _vala_class_b_get_property;
	g_object_class_install_property (G_OBJECT_CLASS (klass), CLASS_B_FLAGS_PROPERTY, class_b_properties[CLASS_B_FLAGS_PROPERTY] = g_param_spec_int ("flags", "flags", "flags", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}

static void
class_b_instance_init (ClassB * self,
                       gpointer klass)
{
}

static GType
class_b_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (ClassBClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) class_b_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ClassB), 0, (GInstanceInitFunc) class_b_instance_init, NULL };
	GType class_b_type_id;
	class_b_type_id = g_type_register_static (TYPE_CLASS_A, "ClassB", &g_define_type_info, 0);
	return class_b_type_id;
}

GType
class_b_get_type (void)
{
	static volatile gsize class_b_type_id__once = 0;
	if (g_once_init_enter (&class_b_type_id__once)) {
		GType class_b_type_id;
		class_b_type_id = class_b_get_type_once ();
		g_once_init_leave (&class_b_type_id__once, class_b_type_id);
	}
	return class_b_type_id__once;
}

static void
_vala_class_b_get_property (GObject * object,
                            guint property_id,
                            GValue * value,
                            GParamSpec * pspec)
{
	ClassB * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CLASS_B, ClassB);
	switch (property_id) {
		case CLASS_B_FLAGS_PROPERTY:
		g_value_set_int (value, class_a_get_flags (G_TYPE_CHECK_INSTANCE_CAST (self, TYPE_CLASS_A, ClassA)));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

void
class_c_foo (ClassC* self)
{
	g_return_if_fail (IS_CLASS_C (self));
}

ClassC*
class_c_construct (GType object_type)
{
	ClassC * self = NULL;
	self = (ClassC*) class_b_construct (object_type);
	return self;
}

ClassC*
class_c_new (void)
{
	return class_c_construct (TYPE_CLASS_C);
}

static void
class_c_class_init (ClassCClass * klass,
                    gpointer klass_data)
{
	class_c_parent_class = g_type_class_peek_parent (klass);
}

static void
class_c_instance_init (ClassC * self,
                       gpointer klass)
{
}

static GType
class_c_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (ClassCClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) class_c_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ClassC), 0, (GInstanceInitFunc) class_c_instance_init, NULL };
	GType class_c_type_id;
	class_c_type_id = g_type_register_static (TYPE_CLASS_B, "ClassC", &g_define_type_info, 0);
	return class_c_type_id;
}

GType
class_c_get_type (void)
{
	static volatile gsize class_c_type_id__once = 0;
	if (g_once_init_enter (&class_c_type_id__once)) {
		GType class_c_type_id;
		class_c_type_id = class_c_get_type_once ();
		g_once_init_leave (&class_c_type_id__once, class_c_type_id);
	}
	return class_c_type_id__once;
}

ClassD*
class_d_construct (GType object_type)
{
	ClassD * self = NULL;
	self = (ClassD*) class_c_construct (object_type);
	return self;
}

ClassD*
class_d_new (void)
{
	return class_d_construct (TYPE_CLASS_D);
}

static gint
class_d_real_get_flags (ClassA* base)
{
	gint result;
	ClassD* self;
	gint old_flags = 0;
	gint _tmp0_;
	self = G_TYPE_CHECK_INSTANCE_CAST (base, TYPE_CLASS_D, ClassD);
	_tmp0_ = CLASS_A_CLASS (class_d_parent_class)->get_flags (G_TYPE_CHECK_INSTANCE_CAST (G_TYPE_CHECK_INSTANCE_CAST (self, TYPE_CLASS_C, ClassC), TYPE_CLASS_A, ClassA));
	old_flags = _tmp0_;
	result = old_flags | 2;
	return result;
}

static void
class_d_class_init (ClassDClass * klass,
                    gpointer klass_data)
{
	class_d_parent_class = g_type_class_peek_parent (klass);
	CLASS_A_CLASS (klass)->get_flags = (gint (*) (ClassA*)) class_d_real_get_flags;
	G_OBJECT_CLASS (klass)->get_property = _vala_class_d_get_property;
	g_object_class_install_property (G_OBJECT_CLASS (klass), CLASS_D_FLAGS_PROPERTY, class_d_properties[CLASS_D_FLAGS_PROPERTY] = g_param_spec_int ("flags", "flags", "flags", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}

static void
class_d_instance_init (ClassD * self,
                       gpointer klass)
{
}

static GType
class_d_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (ClassDClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) class_d_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ClassD), 0, (GInstanceInitFunc) class_d_instance_init, NULL };
	GType class_d_type_id;
	class_d_type_id = g_type_register_static (TYPE_CLASS_C, "ClassD", &g_define_type_info, 0);
	return class_d_type_id;
}

GType
class_d_get_type (void)
{
	static volatile gsize class_d_type_id__once = 0;
	if (g_once_init_enter (&class_d_type_id__once)) {
		GType class_d_type_id;
		class_d_type_id = class_d_get_type_once ();
		g_once_init_leave (&class_d_type_id__once, class_d_type_id);
	}
	return class_d_type_id__once;
}

static void
_vala_class_d_get_property (GObject * object,
                            guint property_id,
                            GValue * value,
                            GParamSpec * pspec)
{
	ClassD * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CLASS_D, ClassD);
	switch (property_id) {
		case CLASS_D_FLAGS_PROPERTY:
		g_value_set_int (value, class_a_get_flags (G_TYPE_CHECK_INSTANCE_CAST (self, TYPE_CLASS_A, ClassA)));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_main (void)
{
	ClassD* d = NULL;
	ClassD* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	_tmp0_ = class_d_new ();
	d = _tmp0_;
	_tmp1_ = class_a_get_flags (G_TYPE_CHECK_INSTANCE_CAST (d, TYPE_CLASS_A, ClassA));
	_tmp2_ = _tmp1_;
	_vala_assert (_tmp2_ == 3, "d.flags == 3");
	_g_object_unref0 (d);
}

int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}

