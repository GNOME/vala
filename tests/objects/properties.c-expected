/* objects_properties.c generated by valac, the Vala compiler
 * generated from objects_properties.vala, do not modify */

#include <glib-object.h>
#include <glib.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <gobject/gvaluecollector.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

typedef void (*Delegate) (void);

#define TYPE_REAL_STRUCT (real_struct_get_type ())
typedef struct _RealStruct RealStruct;

#define TYPE_NON_PRIV_ACCESS (non_priv_access_get_type ())
#define NON_PRIV_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_NON_PRIV_ACCESS, NonPrivAccess))
#define NON_PRIV_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_NON_PRIV_ACCESS, NonPrivAccessClass))
#define IS_NON_PRIV_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_NON_PRIV_ACCESS))
#define IS_NON_PRIV_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_NON_PRIV_ACCESS))
#define NON_PRIV_ACCESS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_NON_PRIV_ACCESS, NonPrivAccessClass))

typedef struct _NonPrivAccess NonPrivAccess;
typedef struct _NonPrivAccessClass NonPrivAccessClass;
typedef struct _NonPrivAccessPrivate NonPrivAccessPrivate;
enum  {
	NON_PRIV_ACCESS_0_PROPERTY,
	NON_PRIV_ACCESS_REAL_STRUCT_PROPERTY,
	NON_PRIV_ACCESS_NUM_PROPERTIES
};
static GParamSpec* non_priv_access_properties[NON_PRIV_ACCESS_NUM_PROPERTIES];

#define TYPE_SAMPLE (sample_get_type ())
#define SAMPLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SAMPLE, Sample))
#define SAMPLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SAMPLE, SampleClass))
#define IS_SAMPLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SAMPLE))
#define IS_SAMPLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SAMPLE))
#define SAMPLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SAMPLE, SampleClass))

typedef struct _Sample Sample;
typedef struct _SampleClass SampleClass;
typedef struct _SamplePrivate SamplePrivate;
enum  {
	SAMPLE_0_PROPERTY,
	SAMPLE_DELEG_PROPERTY,
	SAMPLE_NAME_PROPERTY,
	SAMPLE_READ_ONLY_PROPERTY,
	SAMPLE_PUBLIC_PROP_PROPERTY,
	SAMPLE_NUM_PROPERTIES
};
static GParamSpec* sample_properties[SAMPLE_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))

#define MAMAN_TYPE_IBAZ (maman_ibaz_get_type ())
#define MAMAN_IBAZ(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_IBAZ, MamanIbaz))
#define MAMAN_IS_IBAZ(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_IBAZ))
#define MAMAN_IBAZ_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), MAMAN_TYPE_IBAZ, MamanIbazIface))

typedef struct _MamanIbaz MamanIbaz;
typedef struct _MamanIbazIface MamanIbazIface;

#define MAMAN_TYPE_BAZ (maman_baz_get_type ())
#define MAMAN_BAZ(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_BAZ, MamanBaz))
#define MAMAN_BAZ_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_BAZ, MamanBazClass))
#define MAMAN_IS_BAZ(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_BAZ))
#define MAMAN_IS_BAZ_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_BAZ))
#define MAMAN_BAZ_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_BAZ, MamanBazClass))

typedef struct _MamanBaz MamanBaz;
typedef struct _MamanBazClass MamanBazClass;
#define _real_struct_free0(var) ((var == NULL) ? NULL : (var = (real_struct_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define MAMAN_TYPE_FOO (maman_foo_get_type ())
#define MAMAN_FOO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_FOO, MamanFoo))
#define MAMAN_FOO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_FOO, MamanFooClass))
#define MAMAN_IS_FOO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_FOO))
#define MAMAN_IS_FOO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_FOO))
#define MAMAN_FOO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_FOO, MamanFooClass))

typedef struct _MamanFoo MamanFoo;
typedef struct _MamanFooClass MamanFooClass;
typedef struct _MamanFooPrivate MamanFooPrivate;
enum  {
	MAMAN_FOO_0_PROPERTY,
	MAMAN_FOO_PUBLIC_BASE_PROPERTY_PROPERTY,
	MAMAN_FOO_ABSTRACT_BASE_PROPERTY_PROPERTY,
	MAMAN_FOO_NUM_PROPERTIES
};
static GParamSpec* maman_foo_properties[MAMAN_FOO_NUM_PROPERTIES];
typedef enum  {
	FOO_ENUM_FOO
} FooEnum;

#define TYPE_FOO_ENUM (foo_enum_get_type ())

#define MAMAN_TYPE_ENUM_DEFAULT (maman_enum_default_get_type ())
#define MAMAN_ENUM_DEFAULT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_ENUM_DEFAULT, MamanEnumDefault))
#define MAMAN_ENUM_DEFAULT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_ENUM_DEFAULT, MamanEnumDefaultClass))
#define MAMAN_IS_ENUM_DEFAULT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_ENUM_DEFAULT))
#define MAMAN_IS_ENUM_DEFAULT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_ENUM_DEFAULT))
#define MAMAN_ENUM_DEFAULT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_ENUM_DEFAULT, MamanEnumDefaultClass))

typedef struct _MamanEnumDefault MamanEnumDefault;
typedef struct _MamanEnumDefaultClass MamanEnumDefaultClass;
typedef struct _MamanEnumDefaultPrivate MamanEnumDefaultPrivate;
typedef struct _MamanParamSpecEnumDefault MamanParamSpecEnumDefault;

#define MAMAN_TYPE_BAR (maman_bar_get_type ())
#define MAMAN_BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_BAR, MamanBar))
#define MAMAN_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_BAR, MamanBarClass))
#define MAMAN_IS_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_BAR))
#define MAMAN_IS_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_BAR))
#define MAMAN_BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_BAR, MamanBarClass))

typedef struct _MamanBar MamanBar;
typedef struct _MamanBarClass MamanBarClass;
typedef struct _MamanBarPrivate MamanBarPrivate;
enum  {
	MAMAN_BAR_0_PROPERTY,
	MAMAN_BAR_PUBLIC_PROPERTY_PROPERTY,
	MAMAN_BAR_ABSTRACT_BASE_PROPERTY_PROPERTY,
	MAMAN_BAR_NUM_PROPERTIES
};
static GParamSpec* maman_bar_properties[MAMAN_BAR_NUM_PROPERTIES];
typedef struct _MamanBazPrivate MamanBazPrivate;
enum  {
	MAMAN_BAZ_0_PROPERTY,
	MAMAN_BAZ_NUMBER_PROPERTY,
	MAMAN_BAZ_NUM_PROPERTIES
};
static GParamSpec* maman_baz_properties[MAMAN_BAZ_NUM_PROPERTIES];

#define MAMAN_TYPE_IBIZ (maman_ibiz_get_type ())
#define MAMAN_IBIZ(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_IBIZ, MamanIBiz))
#define MAMAN_IS_IBIZ(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_IBIZ))
#define MAMAN_IBIZ_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), MAMAN_TYPE_IBIZ, MamanIBizIface))

typedef struct _MamanIBiz MamanIBiz;
typedef struct _MamanIBizIface MamanIBizIface;

#define MAMAN_TYPE_ABIZ (maman_abiz_get_type ())
#define MAMAN_ABIZ(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_ABIZ, MamanABiz))
#define MAMAN_ABIZ_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_ABIZ, MamanABizClass))
#define MAMAN_IS_ABIZ(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_ABIZ))
#define MAMAN_IS_ABIZ_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_ABIZ))
#define MAMAN_ABIZ_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_ABIZ, MamanABizClass))

typedef struct _MamanABiz MamanABiz;
typedef struct _MamanABizClass MamanABizClass;
typedef struct _MamanABizPrivate MamanABizPrivate;
enum  {
	MAMAN_ABIZ_0_PROPERTY,
	MAMAN_ABIZ_NUMBER_PROPERTY,
	MAMAN_ABIZ_NUMBER2_PROPERTY,
	MAMAN_ABIZ_NUM_PROPERTIES
};
static GParamSpec* maman_abiz_properties[MAMAN_ABIZ_NUM_PROPERTIES];

#define MAMAN_TYPE_BIZ (maman_biz_get_type ())
#define MAMAN_BIZ(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_BIZ, MamanBiz))
#define MAMAN_BIZ_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_BIZ, MamanBizClass))
#define MAMAN_IS_BIZ(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_BIZ))
#define MAMAN_IS_BIZ_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_BIZ))
#define MAMAN_BIZ_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_BIZ, MamanBizClass))

typedef struct _MamanBiz MamanBiz;
typedef struct _MamanBizClass MamanBizClass;
typedef struct _MamanBizPrivate MamanBizPrivate;
enum  {
	MAMAN_BIZ_0_PROPERTY,
	MAMAN_BIZ_NUMBER2_PROPERTY,
	MAMAN_BIZ_NUM_PROPERTIES
};
static GParamSpec* maman_biz_properties[MAMAN_BIZ_NUM_PROPERTIES];
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _RealStruct {
	gint field;
};

struct _NonPrivAccess {
	GObject parent_instance;
	NonPrivAccessPrivate * priv;
};

struct _NonPrivAccessClass {
	GObjectClass parent_class;
};

struct _NonPrivAccessPrivate {
	RealStruct _real_struct;
};

struct _Sample {
	GObject parent_instance;
	SamplePrivate * priv;
};

struct _SampleClass {
	GObjectClass parent_class;
};

struct _SamplePrivate {
	gchar* _automatic;
	Delegate _deleg;
	gchar* _name;
	gchar* _read_only;
	gint _public_prop;
	gint _private_prop;
	GRecMutex __lock_public_prop;
	GRecMutex __lock_private_prop;
};

struct _MamanIbazIface {
	GTypeInterface parent_iface;
	gint (*get_number) (MamanIbaz* self);
};

struct _MamanFoo {
	GObject parent_instance;
	MamanFooPrivate * priv;
};

struct _MamanFooClass {
	GObjectClass parent_class;
	gint (*get_abstract_base_property) (MamanFoo* self);
	void (*set_abstract_base_property) (MamanFoo* self, gint value);
};

struct _MamanFooPrivate {
	gint _public_base_property;
};

struct _MamanEnumDefault {
	GTypeInstance parent_instance;
	volatile int ref_count;
	MamanEnumDefaultPrivate * priv;
};

struct _MamanEnumDefaultClass {
	GTypeClass parent_class;
	void (*finalize) (MamanEnumDefault *self);
	FooEnum (*get_bar) (MamanEnumDefault* self);
};

struct _MamanParamSpecEnumDefault {
	GParamSpec parent_instance;
};

struct _MamanBar {
	MamanFoo parent_instance;
	MamanBarPrivate * priv;
};

struct _MamanBarClass {
	MamanFooClass parent_class;
};

struct _MamanBarPrivate {
	gint _public_property;
	gint _abstract_base_property;
};

struct _MamanBaz {
	GObject parent_instance;
	MamanBazPrivate * priv;
};

struct _MamanBazClass {
	GObjectClass parent_class;
};

struct _MamanIBizIface {
	GTypeInterface parent_iface;
	gint (*get_number) (MamanIBiz* self);
	void (*set_number) (MamanIBiz* self, gint value);
};

struct _MamanABiz {
	GObject parent_instance;
	MamanABizPrivate * priv;
};

struct _MamanABizClass {
	GObjectClass parent_class;
	gint (*get_number2) (MamanABiz* self);
	void (*set_number2) (MamanABiz* self, gint value);
};

struct _MamanABizPrivate {
	gint _number;
};

struct _MamanBiz {
	MamanABiz parent_instance;
	MamanBizPrivate * priv;
};

struct _MamanBizClass {
	MamanABizClass parent_class;
};

struct _MamanBizPrivate {
	gint _number2;
};

static gint NonPrivAccess_private_offset;
static gpointer non_priv_access_parent_class = NULL;
static gint Sample_private_offset;
static gpointer sample_parent_class = NULL;
static gint MamanFoo_private_offset;
static gpointer maman_foo_parent_class = NULL;
static gpointer maman_enum_default_parent_class = NULL;
static gint MamanBar_private_offset;
static gpointer maman_bar_parent_class = NULL;
static gpointer maman_baz_parent_class = NULL;
static MamanIbazIface * maman_baz_maman_ibaz_parent_iface = NULL;
static gint MamanABiz_private_offset;
static gpointer maman_abiz_parent_class = NULL;
static MamanIBizIface * maman_abiz_maman_ibiz_parent_iface = NULL;
static gint MamanBiz_private_offset;
static gpointer maman_biz_parent_class = NULL;

VALA_EXTERN GType real_struct_get_type (void) G_GNUC_CONST ;
VALA_EXTERN RealStruct* real_struct_dup (const RealStruct* self);
VALA_EXTERN void real_struct_free (RealStruct* self);
VALA_EXTERN GType non_priv_access_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (NonPrivAccess, g_object_unref)
VALA_EXTERN NonPrivAccess* non_priv_access_new (void);
VALA_EXTERN NonPrivAccess* non_priv_access_construct (GType object_type);
VALA_EXTERN void non_priv_access_get_real_struct (NonPrivAccess* self,
                                      RealStruct * result);
VALA_EXTERN void non_priv_access_set_real_struct (NonPrivAccess* self,
                                      RealStruct * value);
static gboolean _real_struct_equal (const RealStruct * s1,
                             const RealStruct * s2);
static void non_priv_access_finalize (GObject * obj);
static GType non_priv_access_get_type_once (void);
static void _vala_non_priv_access_get_property (GObject * object,
                                         guint property_id,
                                         GValue * value,
                                         GParamSpec * pspec);
static void _vala_non_priv_access_set_property (GObject * object,
                                         guint property_id,
                                         const GValue * value,
                                         GParamSpec * pspec);
VALA_EXTERN GType sample_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Sample, g_object_unref)
VALA_EXTERN Sample* sample_new (const gchar* name);
VALA_EXTERN Sample* sample_construct (GType object_type,
                          const gchar* name);
VALA_EXTERN void sample_set_name (Sample* self,
                      const gchar* value);
VALA_EXTERN void sample_run (Sample* self);
static void _vala_lambda0_ (Sample* self,
                     GObject* s,
                     GParamSpec* p);
static void __vala_lambda0__g_object_notify (GObject* _sender,
                                      GParamSpec* pspec,
                                      gpointer self);
static void sample_set_automatic (Sample* self,
                           const gchar* value);
static const gchar* sample_get_automatic (Sample* self);
VALA_EXTERN const gchar* sample_get_name (Sample* self);
VALA_EXTERN const gchar* sample_get_read_only (Sample* self);
VALA_EXTERN void sample_set_deleg (Sample* self,
                       Delegate value);
VALA_EXTERN gint sample_get_public_prop (Sample* self);
VALA_EXTERN void sample_set_public_prop (Sample* self,
                             gint value);
static gint sample_get_private_prop (Sample* self);
static void sample_set_private_prop (Sample* self,
                              gint value);
static gint sample_main (void);
VALA_EXTERN void maman_bar_run (void);
VALA_EXTERN GType maman_ibaz_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MamanIbaz, g_object_unref)
VALA_EXTERN MamanBaz* maman_baz_new (void);
VALA_EXTERN MamanBaz* maman_baz_construct (GType object_type);
VALA_EXTERN GType maman_baz_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MamanBaz, g_object_unref)
VALA_EXTERN void maman_ibaz_simple_method (MamanIbaz* self);
VALA_EXTERN Delegate sample_get_deleg (Sample* self);
static GObject * sample_constructor (GType type,
                              guint n_construct_properties,
                              GObjectConstructParam * construct_properties);
static void sample_finalize (GObject * obj);
static GType sample_get_type_once (void);
static void _vala_sample_get_property (GObject * object,
                                guint property_id,
                                GValue * value,
                                GParamSpec * pspec);
static void _vala_sample_set_property (GObject * object,
                                guint property_id,
                                const GValue * value,
                                GParamSpec * pspec);
VALA_EXTERN GType maman_foo_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MamanFoo, g_object_unref)
VALA_EXTERN MamanFoo* maman_foo_construct (GType object_type);
VALA_EXTERN gint maman_foo_get_public_base_property (MamanFoo* self);
VALA_EXTERN void maman_foo_set_public_base_property (MamanFoo* self,
                                         gint value);
VALA_EXTERN gint maman_foo_get_abstract_base_property (MamanFoo* self);
VALA_EXTERN void maman_foo_set_abstract_base_property (MamanFoo* self,
                                           gint value);
static void maman_foo_finalize (GObject * obj);
static GType maman_foo_get_type_once (void);
static void _vala_maman_foo_get_property (GObject * object,
                                   guint property_id,
                                   GValue * value,
                                   GParamSpec * pspec);
static void _vala_maman_foo_set_property (GObject * object,
                                   guint property_id,
                                   const GValue * value,
                                   GParamSpec * pspec);
VALA_EXTERN GType foo_enum_get_type (void) G_GNUC_CONST ;
VALA_EXTERN gpointer maman_enum_default_ref (gpointer instance);
VALA_EXTERN void maman_enum_default_unref (gpointer instance);
VALA_EXTERN GParamSpec* maman_param_spec_enum_default (const gchar* name,
                                           const gchar* nick,
                                           const gchar* blurb,
                                           GType object_type,
                                           GParamFlags flags);
VALA_EXTERN void maman_value_set_enum_default (GValue* value,
                                   gpointer v_object);
VALA_EXTERN void maman_value_take_enum_default (GValue* value,
                                    gpointer v_object);
VALA_EXTERN gpointer maman_value_get_enum_default (const GValue* value);
VALA_EXTERN GType maman_enum_default_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MamanEnumDefault, maman_enum_default_unref)
VALA_EXTERN MamanEnumDefault* maman_enum_default_construct (GType object_type);
VALA_EXTERN FooEnum maman_enum_default_get_bar (MamanEnumDefault* self);
static void maman_enum_default_finalize (MamanEnumDefault * obj);
static GType maman_enum_default_get_type_once (void);
VALA_EXTERN GType maman_bar_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MamanBar, g_object_unref)
static void maman_bar_do_action (MamanBar* self);
VALA_EXTERN gint maman_bar_get_public_property (MamanBar* self);
VALA_EXTERN void maman_bar_set_public_property (MamanBar* self,
                                    gint value);
VALA_EXTERN MamanBar* maman_bar_new (void);
VALA_EXTERN MamanBar* maman_bar_construct (GType object_type);
static void maman_bar_finalize (GObject * obj);
static GType maman_bar_get_type_once (void);
static void _vala_maman_bar_get_property (GObject * object,
                                   guint property_id,
                                   GValue * value,
                                   GParamSpec * pspec);
static void _vala_maman_bar_set_property (GObject * object,
                                   guint property_id,
                                   const GValue * value,
                                   GParamSpec * pspec);
VALA_EXTERN gint maman_ibaz_get_number (MamanIbaz* self);
static GType maman_ibaz_get_type_once (void);
static GType maman_baz_get_type_once (void);
static void _vala_maman_baz_get_property (GObject * object,
                                   guint property_id,
                                   GValue * value,
                                   GParamSpec * pspec);
VALA_EXTERN GType maman_ibiz_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MamanIBiz, g_object_unref)
VALA_EXTERN gint maman_ibiz_get_number (MamanIBiz* self);
VALA_EXTERN void maman_ibiz_set_number (MamanIBiz* self,
                            gint value);
static GType maman_ibiz_get_type_once (void);
VALA_EXTERN GType maman_abiz_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MamanABiz, g_object_unref)
VALA_EXTERN MamanABiz* maman_abiz_construct (GType object_type);
VALA_EXTERN gint maman_abiz_get_number2 (MamanABiz* self);
VALA_EXTERN void maman_abiz_set_number2 (MamanABiz* self,
                             gint value);
static void maman_abiz_finalize (GObject * obj);
static GType maman_abiz_get_type_once (void);
static void _vala_maman_abiz_get_property (GObject * object,
                                    guint property_id,
                                    GValue * value,
                                    GParamSpec * pspec);
static void _vala_maman_abiz_set_property (GObject * object,
                                    guint property_id,
                                    const GValue * value,
                                    GParamSpec * pspec);
VALA_EXTERN GType maman_biz_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MamanBiz, g_object_unref)
VALA_EXTERN MamanBiz* maman_biz_new (void);
VALA_EXTERN MamanBiz* maman_biz_construct (GType object_type);
static void maman_biz_finalize (GObject * obj);
static GType maman_biz_get_type_once (void);
static void _vala_maman_biz_get_property (GObject * object,
                                   guint property_id,
                                   GValue * value,
                                   GParamSpec * pspec);
static void _vala_maman_biz_set_property (GObject * object,
                                   guint property_id,
                                   const GValue * value,
                                   GParamSpec * pspec);

RealStruct*
real_struct_dup (const RealStruct* self)
{
	RealStruct* dup;
	dup = g_new0 (RealStruct, 1);
	memcpy (dup, self, sizeof (RealStruct));
	return dup;
}

void
real_struct_free (RealStruct* self)
{
	g_free (self);
}

static GType
real_struct_get_type_once (void)
{
	GType real_struct_type_id;
	real_struct_type_id = g_boxed_type_register_static ("RealStruct", (GBoxedCopyFunc) real_struct_dup, (GBoxedFreeFunc) real_struct_free);
	return real_struct_type_id;
}

GType
real_struct_get_type (void)
{
	static volatile gsize real_struct_type_id__once = 0;
	if (g_once_init_enter (&real_struct_type_id__once)) {
		GType real_struct_type_id;
		real_struct_type_id = real_struct_get_type_once ();
		g_once_init_leave (&real_struct_type_id__once, real_struct_type_id);
	}
	return real_struct_type_id__once;
}

static inline gpointer
non_priv_access_get_instance_private (NonPrivAccess* self)
{
	return G_STRUCT_MEMBER_P (self, NonPrivAccess_private_offset);
}

NonPrivAccess*
non_priv_access_construct (GType object_type)
{
	NonPrivAccess * self = NULL;
	self = (NonPrivAccess*) g_object_new (object_type, NULL);
	return self;
}

NonPrivAccess*
non_priv_access_new (void)
{
	return non_priv_access_construct (TYPE_NON_PRIV_ACCESS);
}

void
non_priv_access_get_real_struct (NonPrivAccess* self,
                                 RealStruct * result)
{
	RealStruct _tmp0_;
	g_return_if_fail (IS_NON_PRIV_ACCESS (self));
	_tmp0_ = self->priv->_real_struct;
	*result = _tmp0_;
	return;
}

static gboolean
_real_struct_equal (const RealStruct * s1,
                    const RealStruct * s2)
{
	if (s1 == s2) {
		return TRUE;
	}
	if (s1 == NULL) {
		return FALSE;
	}
	if (s2 == NULL) {
		return FALSE;
	}
	if (s1->field != s2->field) {
		return FALSE;
	}
	return TRUE;
}

void
non_priv_access_set_real_struct (NonPrivAccess* self,
                                 RealStruct * value)
{
	RealStruct old_value;
	g_return_if_fail (IS_NON_PRIV_ACCESS (self));
	non_priv_access_get_real_struct (self, &old_value);
	if (_real_struct_equal (value, &old_value) != TRUE) {
		RealStruct _tmp0_;
		_tmp0_ = *value;
		self->priv->_real_struct = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, non_priv_access_properties[NON_PRIV_ACCESS_REAL_STRUCT_PROPERTY]);
	}
}

static void
non_priv_access_class_init (NonPrivAccessClass * klass,
                            gpointer klass_data)
{
	non_priv_access_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &NonPrivAccess_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_non_priv_access_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_non_priv_access_set_property;
	G_OBJECT_CLASS (klass)->finalize = non_priv_access_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), NON_PRIV_ACCESS_REAL_STRUCT_PROPERTY, non_priv_access_properties[NON_PRIV_ACCESS_REAL_STRUCT_PROPERTY] = g_param_spec_boxed ("real-struct", "real-struct", "real-struct", TYPE_REAL_STRUCT, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}

static void
non_priv_access_instance_init (NonPrivAccess * self,
                               gpointer klass)
{
	self->priv = non_priv_access_get_instance_private (self);
}

static void
non_priv_access_finalize (GObject * obj)
{
	NonPrivAccess * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_NON_PRIV_ACCESS, NonPrivAccess);
	G_OBJECT_CLASS (non_priv_access_parent_class)->finalize (obj);
}

static GType
non_priv_access_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (NonPrivAccessClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) non_priv_access_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (NonPrivAccess), 0, (GInstanceInitFunc) non_priv_access_instance_init, NULL };
	GType non_priv_access_type_id;
	non_priv_access_type_id = g_type_register_static (G_TYPE_OBJECT, "NonPrivAccess", &g_define_type_info, 0);
	NonPrivAccess_private_offset = g_type_add_instance_private (non_priv_access_type_id, sizeof (NonPrivAccessPrivate));
	return non_priv_access_type_id;
}

GType
non_priv_access_get_type (void)
{
	static volatile gsize non_priv_access_type_id__once = 0;
	if (g_once_init_enter (&non_priv_access_type_id__once)) {
		GType non_priv_access_type_id;
		non_priv_access_type_id = non_priv_access_get_type_once ();
		g_once_init_leave (&non_priv_access_type_id__once, non_priv_access_type_id);
	}
	return non_priv_access_type_id__once;
}

static void
_vala_non_priv_access_get_property (GObject * object,
                                    guint property_id,
                                    GValue * value,
                                    GParamSpec * pspec)
{
	NonPrivAccess * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_NON_PRIV_ACCESS, NonPrivAccess);
	switch (property_id) {
		case NON_PRIV_ACCESS_REAL_STRUCT_PROPERTY:
		{
			RealStruct boxed;
			non_priv_access_get_real_struct (self, &boxed);
			g_value_set_boxed (value, &boxed);
		}
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_non_priv_access_set_property (GObject * object,
                                    guint property_id,
                                    const GValue * value,
                                    GParamSpec * pspec)
{
	NonPrivAccess * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_NON_PRIV_ACCESS, NonPrivAccess);
	switch (property_id) {
		case NON_PRIV_ACCESS_REAL_STRUCT_PROPERTY:
		non_priv_access_set_real_struct (self, g_value_get_boxed (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
sample_get_instance_private (Sample* self)
{
	return G_STRUCT_MEMBER_P (self, Sample_private_offset);
}

Sample*
sample_construct (GType object_type,
                  const gchar* name)
{
	Sample * self = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	self = (Sample*) g_object_new (object_type, NULL);
	sample_set_name (self, name);
	return self;
}

Sample*
sample_new (const gchar* name)
{
	return sample_construct (TYPE_SAMPLE, name);
}

static void
_vala_lambda0_ (Sample* self,
                GObject* s,
                GParamSpec* p)
{
	FILE* _tmp0_;
	const gchar* _tmp1_;
	g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (s, G_TYPE_OBJECT));
	g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (p, G_TYPE_PARAM));
	_tmp0_ = stdout;
	_tmp1_ = p->name;
	fprintf (_tmp0_, "property `%s' has changed!\n", _tmp1_);
}

static void
__vala_lambda0__g_object_notify (GObject* _sender,
                                 GParamSpec* pspec,
                                 gpointer self)
{
	_vala_lambda0_ ((Sample*) self, _sender, pspec);
}

void
sample_run (Sample* self)
{
	FILE* _tmp0_;
	const gchar* _tmp1_;
	FILE* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	FILE* _tmp5_;
	const gchar* _tmp6_;
	const gchar* _tmp7_;
	FILE* _tmp8_;
	const gchar* _tmp9_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (IS_SAMPLE (self));
	g_signal_connect_object (G_TYPE_CHECK_INSTANCE_CAST (self, G_TYPE_OBJECT, GObject), "notify", (GCallback) __vala_lambda0__g_object_notify, self, 0);
	sample_set_automatic (self, "TheNewAutomatic");
	sample_set_name (self, "TheNewName");
	_tmp0_ = stdout;
	_tmp1_ = self->priv->_automatic;
	fprintf (_tmp0_, "automatic: %s\n", _tmp1_);
	_tmp2_ = stdout;
	_tmp3_ = sample_get_name (self);
	_tmp4_ = _tmp3_;
	fprintf (_tmp2_, "name: %s\n", _tmp4_);
	_tmp5_ = stdout;
	_tmp6_ = sample_get_read_only (self);
	_tmp7_ = _tmp6_;
	fprintf (_tmp5_, "read_only: %s\n", _tmp7_);
	_tmp8_ = stdout;
	_tmp9_ = self->priv->_automatic;
	fprintf (_tmp8_, "automatic: %s\n", _tmp9_);
	sample_set_deleg (self, NULL);
	{
		gint _tmp10_;
		_tmp10_ = self->priv->_public_prop;
		g_rec_mutex_lock (&self->priv->__lock_public_prop);
		{
			sample_set_public_prop (self, 42);
		}
		__finally0:
		{
			gint _tmp11_;
			_tmp11_ = self->priv->_public_prop;
			g_rec_mutex_unlock (&self->priv->__lock_public_prop);
		}
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	{
		gint _tmp12_;
		_tmp12_ = self->priv->_private_prop;
		g_rec_mutex_lock (&self->priv->__lock_private_prop);
		{
			sample_set_private_prop (self, 42);
		}
		__finally1:
		{
			gint _tmp13_;
			_tmp13_ = self->priv->_private_prop;
			g_rec_mutex_unlock (&self->priv->__lock_private_prop);
		}
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
}

static gint
sample_main (void)
{
	Sample* test = NULL;
	Sample* _tmp0_;
	FILE* _tmp1_;
	MamanIbaz* ibaz = NULL;
	MamanBaz* _tmp2_;
	FILE* _tmp3_;
	NonPrivAccess* nonpriv = NULL;
	NonPrivAccess* _tmp4_;
	RealStruct _tmp5_ = {0};
	RealStruct* _tmp6_;
	RealStruct* _tmp7_;
	RealStruct* _tmp8_;
	gint result;
	_tmp0_ = sample_new ("InitialName");
	test = _tmp0_;
	sample_run (test);
	maman_bar_run ();
	_tmp1_ = stdout;
	fprintf (_tmp1_, "Interface Properties Test: 1");
	_tmp2_ = maman_baz_new ();
	ibaz = G_TYPE_CHECK_INSTANCE_CAST (_tmp2_, MAMAN_TYPE_IBAZ, MamanIbaz);
	maman_ibaz_simple_method (ibaz);
	_tmp3_ = stdout;
	fprintf (_tmp3_, " 3\n");
	_tmp4_ = non_priv_access_new ();
	nonpriv = _tmp4_;
	_tmp5_.field = 10;
	g_object_set (nonpriv, "real-struct", &_tmp5_, NULL);
	g_object_get (nonpriv, "real-struct", &_tmp6_, NULL);
	_tmp7_ = _tmp6_;
	_tmp8_ = _tmp7_;
	_vala_assert ((*_tmp8_).field == 10, "nonpriv.real_struct.field == 10");
	_real_struct_free0 (_tmp8_);
	result = 0;
	_g_object_unref0 (nonpriv);
	_g_object_unref0 (ibaz);
	_g_object_unref0 (test);
	return result;
}

int
main (int argc,
      char ** argv)
{
	return sample_main ();
}

static const gchar*
sample_get_automatic (Sample* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (IS_SAMPLE (self), NULL);
	_tmp0_ = self->priv->_automatic;
	result = _tmp0_;
	return result;
}

static void
sample_set_automatic (Sample* self,
                      const gchar* value)
{
	gchar* _tmp0_;
	g_return_if_fail (IS_SAMPLE (self));
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_automatic);
	self->priv->_automatic = _tmp0_;
}

Delegate
sample_get_deleg (Sample* self)
{
	Delegate result;
	Delegate _tmp0_;
	g_return_val_if_fail (IS_SAMPLE (self), NULL);
	_tmp0_ = self->priv->_deleg;
	result = _tmp0_;
	return result;
}

void
sample_set_deleg (Sample* self,
                  Delegate value)
{
	Delegate old_value;
	g_return_if_fail (IS_SAMPLE (self));
	old_value = sample_get_deleg (self);
	if (old_value != value) {
		Delegate _tmp0_;
		_tmp0_ = value;
		value = NULL;
		self->priv->_deleg = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, sample_properties[SAMPLE_DELEG_PROPERTY]);
	}
}

const gchar*
sample_get_name (Sample* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (IS_SAMPLE (self), NULL);
	_tmp0_ = self->priv->_name;
	result = _tmp0_;
	return result;
}

void
sample_set_name (Sample* self,
                 const gchar* value)
{
	gchar* _tmp0_;
	g_return_if_fail (IS_SAMPLE (self));
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_name);
	self->priv->_name = _tmp0_;
	g_object_notify_by_pspec ((GObject *) self, sample_properties[SAMPLE_NAME_PROPERTY]);
}

const gchar*
sample_get_read_only (Sample* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (IS_SAMPLE (self), NULL);
	_tmp0_ = self->priv->_read_only;
	result = _tmp0_;
	return result;
}

gint
sample_get_public_prop (Sample* self)
{
	gint result;
	g_return_val_if_fail (IS_SAMPLE (self), 0);
	result = self->priv->_public_prop;
	return result;
}

void
sample_set_public_prop (Sample* self,
                        gint value)
{
	gint old_value;
	g_return_if_fail (IS_SAMPLE (self));
	old_value = sample_get_public_prop (self);
	if (old_value != value) {
		self->priv->_public_prop = value;
		g_object_notify_by_pspec ((GObject *) self, sample_properties[SAMPLE_PUBLIC_PROP_PROPERTY]);
	}
}

static gint
sample_get_private_prop (Sample* self)
{
	gint result;
	g_return_val_if_fail (IS_SAMPLE (self), 0);
	result = self->priv->_private_prop;
	return result;
}

static void
sample_set_private_prop (Sample* self,
                         gint value)
{
	g_return_if_fail (IS_SAMPLE (self));
	self->priv->_private_prop = value;
}

static GObject *
sample_constructor (GType type,
                    guint n_construct_properties,
                    GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	Sample * self;
	gchar* _tmp0_;
	gchar* _tmp1_;
	parent_class = G_OBJECT_CLASS (sample_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SAMPLE, Sample);
	_tmp0_ = g_strdup ("InitialAutomatic");
	_g_free0 (self->priv->_automatic);
	self->priv->_automatic = _tmp0_;
	_tmp1_ = g_strdup ("InitialReadOnly");
	_g_free0 (self->priv->_read_only);
	self->priv->_read_only = _tmp1_;
	return obj;
}

static void
sample_class_init (SampleClass * klass,
                   gpointer klass_data)
{
	sample_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &Sample_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_sample_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_sample_set_property;
	G_OBJECT_CLASS (klass)->constructor = sample_constructor;
	G_OBJECT_CLASS (klass)->finalize = sample_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SAMPLE_DELEG_PROPERTY, sample_properties[SAMPLE_DELEG_PROPERTY] = g_param_spec_pointer ("deleg", "deleg", "deleg", G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SAMPLE_NAME_PROPERTY, sample_properties[SAMPLE_NAME_PROPERTY] = g_param_spec_string ("name", "name", "name", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SAMPLE_READ_ONLY_PROPERTY, sample_properties[SAMPLE_READ_ONLY_PROPERTY] = g_param_spec_string ("read-only", "read-only", "read-only", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SAMPLE_PUBLIC_PROP_PROPERTY, sample_properties[SAMPLE_PUBLIC_PROP_PROPERTY] = g_param_spec_int ("public-prop", "public-prop", "public-prop", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}

static void
sample_instance_init (Sample * self,
                      gpointer klass)
{
	self->priv = sample_get_instance_private (self);
	g_rec_mutex_init (&self->priv->__lock_public_prop);
	g_rec_mutex_init (&self->priv->__lock_private_prop);
}

static void
sample_finalize (GObject * obj)
{
	Sample * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SAMPLE, Sample);
	_g_free0 (self->priv->_automatic);
	_g_free0 (self->priv->_name);
	_g_free0 (self->priv->_read_only);
	g_rec_mutex_clear (&self->priv->__lock_public_prop);
	g_rec_mutex_clear (&self->priv->__lock_private_prop);
	G_OBJECT_CLASS (sample_parent_class)->finalize (obj);
}

static GType
sample_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (SampleClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) sample_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Sample), 0, (GInstanceInitFunc) sample_instance_init, NULL };
	GType sample_type_id;
	sample_type_id = g_type_register_static (G_TYPE_OBJECT, "Sample", &g_define_type_info, 0);
	Sample_private_offset = g_type_add_instance_private (sample_type_id, sizeof (SamplePrivate));
	return sample_type_id;
}

GType
sample_get_type (void)
{
	static volatile gsize sample_type_id__once = 0;
	if (g_once_init_enter (&sample_type_id__once)) {
		GType sample_type_id;
		sample_type_id = sample_get_type_once ();
		g_once_init_leave (&sample_type_id__once, sample_type_id);
	}
	return sample_type_id__once;
}

static void
_vala_sample_get_property (GObject * object,
                           guint property_id,
                           GValue * value,
                           GParamSpec * pspec)
{
	Sample * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_SAMPLE, Sample);
	switch (property_id) {
		case SAMPLE_DELEG_PROPERTY:
		g_value_set_pointer (value, sample_get_deleg (self));
		break;
		case SAMPLE_NAME_PROPERTY:
		g_value_set_string (value, sample_get_name (self));
		break;
		case SAMPLE_READ_ONLY_PROPERTY:
		g_value_set_string (value, sample_get_read_only (self));
		break;
		case SAMPLE_PUBLIC_PROP_PROPERTY:
		g_value_set_int (value, sample_get_public_prop (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_sample_set_property (GObject * object,
                           guint property_id,
                           const GValue * value,
                           GParamSpec * pspec)
{
	Sample * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_SAMPLE, Sample);
	switch (property_id) {
		case SAMPLE_DELEG_PROPERTY:
		sample_set_deleg (self, g_value_get_pointer (value));
		break;
		case SAMPLE_NAME_PROPERTY:
		sample_set_name (self, g_value_get_string (value));
		break;
		case SAMPLE_PUBLIC_PROP_PROPERTY:
		sample_set_public_prop (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
maman_foo_get_instance_private (MamanFoo* self)
{
	return G_STRUCT_MEMBER_P (self, MamanFoo_private_offset);
}

MamanFoo*
maman_foo_construct (GType object_type)
{
	MamanFoo * self = NULL;
	self = (MamanFoo*) g_object_new (object_type, NULL);
	return self;
}

gint
maman_foo_get_public_base_property (MamanFoo* self)
{
	gint result;
	g_return_val_if_fail (MAMAN_IS_FOO (self), 0);
	result = self->priv->_public_base_property;
	return result;
}

void
maman_foo_set_public_base_property (MamanFoo* self,
                                    gint value)
{
	g_return_if_fail (MAMAN_IS_FOO (self));
	self->priv->_public_base_property = value;
	g_object_notify_by_pspec ((GObject *) self, maman_foo_properties[MAMAN_FOO_PUBLIC_BASE_PROPERTY_PROPERTY]);
}

gint
maman_foo_get_abstract_base_property (MamanFoo* self)
{
	MamanFooClass* _klass_;
	g_return_val_if_fail (MAMAN_IS_FOO (self), 0);
	_klass_ = MAMAN_FOO_GET_CLASS (self);
	if (_klass_->get_abstract_base_property) {
		return _klass_->get_abstract_base_property (self);
	}
	return -1;
}

void
maman_foo_set_abstract_base_property (MamanFoo* self,
                                      gint value)
{
	MamanFooClass* _klass_;
	g_return_if_fail (MAMAN_IS_FOO (self));
	_klass_ = MAMAN_FOO_GET_CLASS (self);
	if (_klass_->set_abstract_base_property) {
		_klass_->set_abstract_base_property (self, value);
	}
}

static void
maman_foo_class_init (MamanFooClass * klass,
                      gpointer klass_data)
{
	maman_foo_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &MamanFoo_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_maman_foo_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_maman_foo_set_property;
	G_OBJECT_CLASS (klass)->finalize = maman_foo_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAMAN_FOO_PUBLIC_BASE_PROPERTY_PROPERTY, maman_foo_properties[MAMAN_FOO_PUBLIC_BASE_PROPERTY_PROPERTY] = g_param_spec_int ("public-base-property", "public-base-property", "public-base-property", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAMAN_FOO_ABSTRACT_BASE_PROPERTY_PROPERTY, maman_foo_properties[MAMAN_FOO_ABSTRACT_BASE_PROPERTY_PROPERTY] = g_param_spec_int ("abstract-base-property", "abstract-base-property", "abstract-base-property", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}

static void
maman_foo_instance_init (MamanFoo * self,
                         gpointer klass)
{
	self->priv = maman_foo_get_instance_private (self);
	self->priv->_public_base_property = 2;
}

static void
maman_foo_finalize (GObject * obj)
{
	MamanFoo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, MAMAN_TYPE_FOO, MamanFoo);
	G_OBJECT_CLASS (maman_foo_parent_class)->finalize (obj);
}

static GType
maman_foo_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (MamanFooClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) maman_foo_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MamanFoo), 0, (GInstanceInitFunc) maman_foo_instance_init, NULL };
	GType maman_foo_type_id;
	maman_foo_type_id = g_type_register_static (G_TYPE_OBJECT, "MamanFoo", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
	MamanFoo_private_offset = g_type_add_instance_private (maman_foo_type_id, sizeof (MamanFooPrivate));
	return maman_foo_type_id;
}

GType
maman_foo_get_type (void)
{
	static volatile gsize maman_foo_type_id__once = 0;
	if (g_once_init_enter (&maman_foo_type_id__once)) {
		GType maman_foo_type_id;
		maman_foo_type_id = maman_foo_get_type_once ();
		g_once_init_leave (&maman_foo_type_id__once, maman_foo_type_id);
	}
	return maman_foo_type_id__once;
}

static void
_vala_maman_foo_get_property (GObject * object,
                              guint property_id,
                              GValue * value,
                              GParamSpec * pspec)
{
	MamanFoo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, MAMAN_TYPE_FOO, MamanFoo);
	switch (property_id) {
		case MAMAN_FOO_PUBLIC_BASE_PROPERTY_PROPERTY:
		g_value_set_int (value, maman_foo_get_public_base_property (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_maman_foo_set_property (GObject * object,
                              guint property_id,
                              const GValue * value,
                              GParamSpec * pspec)
{
	MamanFoo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, MAMAN_TYPE_FOO, MamanFoo);
	switch (property_id) {
		case MAMAN_FOO_PUBLIC_BASE_PROPERTY_PROPERTY:
		maman_foo_set_public_base_property (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static GType
foo_enum_get_type_once (void)
{
	static const GEnumValue values[] = {{FOO_ENUM_FOO, "FOO_ENUM_FOO", "foo"}, {0, NULL, NULL}};
	GType foo_enum_type_id;
	foo_enum_type_id = g_enum_register_static ("FooEnum", values);
	return foo_enum_type_id;
}

GType
foo_enum_get_type (void)
{
	static volatile gsize foo_enum_type_id__once = 0;
	if (g_once_init_enter (&foo_enum_type_id__once)) {
		GType foo_enum_type_id;
		foo_enum_type_id = foo_enum_get_type_once ();
		g_once_init_leave (&foo_enum_type_id__once, foo_enum_type_id);
	}
	return foo_enum_type_id__once;
}

MamanEnumDefault*
maman_enum_default_construct (GType object_type)
{
	MamanEnumDefault* self = NULL;
	self = (MamanEnumDefault*) g_type_create_instance (object_type);
	return self;
}

FooEnum
maman_enum_default_get_bar (MamanEnumDefault* self)
{
	MamanEnumDefaultClass* _klass_;
	g_return_val_if_fail (MAMAN_IS_ENUM_DEFAULT (self), 0);
	_klass_ = MAMAN_ENUM_DEFAULT_GET_CLASS (self);
	if (_klass_->get_bar) {
		return _klass_->get_bar (self);
	}
	return 0;
}

static void
maman_value_enum_default_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
maman_value_enum_default_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		maman_enum_default_unref (value->data[0].v_pointer);
	}
}

static void
maman_value_enum_default_copy_value (const GValue* src_value,
                                     GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = maman_enum_default_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
maman_value_enum_default_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
maman_value_enum_default_collect_value (GValue* value,
                                        guint n_collect_values,
                                        GTypeCValue* collect_values,
                                        guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		MamanEnumDefault * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = maman_enum_default_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
maman_value_enum_default_lcopy_value (const GValue* value,
                                      guint n_collect_values,
                                      GTypeCValue* collect_values,
                                      guint collect_flags)
{
	MamanEnumDefault ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = maman_enum_default_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
maman_param_spec_enum_default (const gchar* name,
                               const gchar* nick,
                               const gchar* blurb,
                               GType object_type,
                               GParamFlags flags)
{
	MamanParamSpecEnumDefault* spec;
	g_return_val_if_fail (g_type_is_a (object_type, MAMAN_TYPE_ENUM_DEFAULT), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
maman_value_get_enum_default (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, MAMAN_TYPE_ENUM_DEFAULT), NULL);
	return value->data[0].v_pointer;
}

void
maman_value_set_enum_default (GValue* value,
                              gpointer v_object)
{
	MamanEnumDefault * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, MAMAN_TYPE_ENUM_DEFAULT));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, MAMAN_TYPE_ENUM_DEFAULT));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		maman_enum_default_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		maman_enum_default_unref (old);
	}
}

void
maman_value_take_enum_default (GValue* value,
                               gpointer v_object)
{
	MamanEnumDefault * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, MAMAN_TYPE_ENUM_DEFAULT));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, MAMAN_TYPE_ENUM_DEFAULT));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		maman_enum_default_unref (old);
	}
}

static void
maman_enum_default_class_init (MamanEnumDefaultClass * klass,
                               gpointer klass_data)
{
	maman_enum_default_parent_class = g_type_class_peek_parent (klass);
	((MamanEnumDefaultClass *) klass)->finalize = maman_enum_default_finalize;
}

static void
maman_enum_default_instance_init (MamanEnumDefault * self,
                                  gpointer klass)
{
	self->ref_count = 1;
}

static void
maman_enum_default_finalize (MamanEnumDefault * obj)
{
	MamanEnumDefault * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, MAMAN_TYPE_ENUM_DEFAULT, MamanEnumDefault);
	g_signal_handlers_destroy (self);
}

static GType
maman_enum_default_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { maman_value_enum_default_init, maman_value_enum_default_free_value, maman_value_enum_default_copy_value, maman_value_enum_default_peek_pointer, "p", maman_value_enum_default_collect_value, "p", maman_value_enum_default_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (MamanEnumDefaultClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) maman_enum_default_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MamanEnumDefault), 0, (GInstanceInitFunc) maman_enum_default_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType maman_enum_default_type_id;
	maman_enum_default_type_id = g_type_register_fundamental (g_type_fundamental_next (), "MamanEnumDefault", &g_define_type_info, &g_define_type_fundamental_info, G_TYPE_FLAG_ABSTRACT);
	return maman_enum_default_type_id;
}

GType
maman_enum_default_get_type (void)
{
	static volatile gsize maman_enum_default_type_id__once = 0;
	if (g_once_init_enter (&maman_enum_default_type_id__once)) {
		GType maman_enum_default_type_id;
		maman_enum_default_type_id = maman_enum_default_get_type_once ();
		g_once_init_leave (&maman_enum_default_type_id__once, maman_enum_default_type_id);
	}
	return maman_enum_default_type_id__once;
}

gpointer
maman_enum_default_ref (gpointer instance)
{
	MamanEnumDefault * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
maman_enum_default_unref (gpointer instance)
{
	MamanEnumDefault * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		MAMAN_ENUM_DEFAULT_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static inline gpointer
maman_bar_get_instance_private (MamanBar* self)
{
	return G_STRUCT_MEMBER_P (self, MamanBar_private_offset);
}

static void
maman_bar_do_action (MamanBar* self)
{
	FILE* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	FILE* _tmp4_;
	gint _tmp5_;
	gint _tmp6_;
	gint _tmp7_;
	g_return_if_fail (MAMAN_IS_BAR (self));
	_tmp0_ = stdout;
	_tmp1_ = maman_foo_get_public_base_property (G_TYPE_CHECK_INSTANCE_CAST (self, MAMAN_TYPE_FOO, MamanFoo));
	_tmp2_ = _tmp1_;
	_tmp3_ = self->priv->_public_property;
	fprintf (_tmp0_, " %d %d", _tmp2_, _tmp3_);
	maman_foo_set_public_base_property (G_TYPE_CHECK_INSTANCE_CAST (self, MAMAN_TYPE_FOO, MamanFoo), 4);
	maman_bar_set_public_property (self, 5);
	_tmp4_ = stdout;
	_tmp5_ = maman_foo_get_public_base_property (G_TYPE_CHECK_INSTANCE_CAST (self, MAMAN_TYPE_FOO, MamanFoo));
	_tmp6_ = _tmp5_;
	_tmp7_ = self->priv->_public_property;
	fprintf (_tmp4_, " %d %d", _tmp6_, _tmp7_);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

void
maman_bar_run (void)
{
	FILE* _tmp0_;
	MamanBar* bar = NULL;
	MamanBar* _tmp1_;
	MamanFoo* foo = NULL;
	MamanFoo* _tmp2_;
	FILE* _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	FILE* _tmp6_;
	_tmp0_ = stdout;
	fprintf (_tmp0_, "Property Test: 1");
	_tmp1_ = maman_bar_new ();
	bar = _tmp1_;
	maman_bar_do_action (bar);
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (bar, MAMAN_TYPE_FOO, MamanFoo));
	foo = _tmp2_;
	maman_foo_set_abstract_base_property (foo, 6);
	_tmp3_ = stdout;
	_tmp4_ = maman_foo_get_abstract_base_property (foo);
	_tmp5_ = _tmp4_;
	fprintf (_tmp3_, " %d", _tmp5_);
	_tmp6_ = stdout;
	fprintf (_tmp6_, " 7\n");
	_g_object_unref0 (foo);
	_g_object_unref0 (bar);
}

MamanBar*
maman_bar_construct (GType object_type)
{
	MamanBar * self = NULL;
	self = (MamanBar*) maman_foo_construct (object_type);
	return self;
}

MamanBar*
maman_bar_new (void)
{
	return maman_bar_construct (MAMAN_TYPE_BAR);
}

gint
maman_bar_get_public_property (MamanBar* self)
{
	gint result;
	g_return_val_if_fail (MAMAN_IS_BAR (self), 0);
	result = self->priv->_public_property;
	return result;
}

void
maman_bar_set_public_property (MamanBar* self,
                               gint value)
{
	gint old_value;
	g_return_if_fail (MAMAN_IS_BAR (self));
	old_value = maman_bar_get_public_property (self);
	if (old_value != value) {
		self->priv->_public_property = value;
		g_object_notify_by_pspec ((GObject *) self, maman_bar_properties[MAMAN_BAR_PUBLIC_PROPERTY_PROPERTY]);
	}
}

static gint
maman_bar_real_get_abstract_base_property (MamanFoo* base)
{
	gint result;
	MamanBar* self;
	self = G_TYPE_CHECK_INSTANCE_CAST (base, MAMAN_TYPE_BAR, MamanBar);
	result = self->priv->_abstract_base_property;
	return result;
}

static void
maman_bar_real_set_abstract_base_property (MamanFoo* base,
                                           gint value)
{
	MamanBar* self;
	gint old_value;
	self = G_TYPE_CHECK_INSTANCE_CAST (base, MAMAN_TYPE_BAR, MamanBar);
	old_value = maman_bar_real_get_abstract_base_property (base);
	if (old_value != value) {
		self->priv->_abstract_base_property = value;
		g_object_notify_by_pspec ((GObject *) self, maman_bar_properties[MAMAN_BAR_ABSTRACT_BASE_PROPERTY_PROPERTY]);
	}
}

static void
maman_bar_class_init (MamanBarClass * klass,
                      gpointer klass_data)
{
	maman_bar_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &MamanBar_private_offset);
	MAMAN_FOO_CLASS (klass)->get_abstract_base_property = (gint (*) (MamanFoo*)) maman_bar_real_get_abstract_base_property;
	MAMAN_FOO_CLASS (klass)->set_abstract_base_property = (void (*) (MamanFoo*, gint)) maman_bar_real_set_abstract_base_property;
	G_OBJECT_CLASS (klass)->get_property = _vala_maman_bar_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_maman_bar_set_property;
	G_OBJECT_CLASS (klass)->finalize = maman_bar_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAMAN_BAR_PUBLIC_PROPERTY_PROPERTY, maman_bar_properties[MAMAN_BAR_PUBLIC_PROPERTY_PROPERTY] = g_param_spec_int ("public-property", "public-property", "public-property", G_MININT, G_MAXINT, 3, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAMAN_BAR_ABSTRACT_BASE_PROPERTY_PROPERTY, maman_bar_properties[MAMAN_BAR_ABSTRACT_BASE_PROPERTY_PROPERTY] = g_param_spec_int ("abstract-base-property", "abstract-base-property", "abstract-base-property", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}

static void
maman_bar_instance_init (MamanBar * self,
                         gpointer klass)
{
	self->priv = maman_bar_get_instance_private (self);
	self->priv->_public_property = 3;
}

static void
maman_bar_finalize (GObject * obj)
{
	MamanBar * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, MAMAN_TYPE_BAR, MamanBar);
	G_OBJECT_CLASS (maman_bar_parent_class)->finalize (obj);
}

static GType
maman_bar_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (MamanBarClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) maman_bar_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MamanBar), 0, (GInstanceInitFunc) maman_bar_instance_init, NULL };
	GType maman_bar_type_id;
	maman_bar_type_id = g_type_register_static (MAMAN_TYPE_FOO, "MamanBar", &g_define_type_info, 0);
	MamanBar_private_offset = g_type_add_instance_private (maman_bar_type_id, sizeof (MamanBarPrivate));
	return maman_bar_type_id;
}

GType
maman_bar_get_type (void)
{
	static volatile gsize maman_bar_type_id__once = 0;
	if (g_once_init_enter (&maman_bar_type_id__once)) {
		GType maman_bar_type_id;
		maman_bar_type_id = maman_bar_get_type_once ();
		g_once_init_leave (&maman_bar_type_id__once, maman_bar_type_id);
	}
	return maman_bar_type_id__once;
}

static void
_vala_maman_bar_get_property (GObject * object,
                              guint property_id,
                              GValue * value,
                              GParamSpec * pspec)
{
	MamanBar * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, MAMAN_TYPE_BAR, MamanBar);
	switch (property_id) {
		case MAMAN_BAR_PUBLIC_PROPERTY_PROPERTY:
		g_value_set_int (value, maman_bar_get_public_property (self));
		break;
		case MAMAN_BAR_ABSTRACT_BASE_PROPERTY_PROPERTY:
		g_value_set_int (value, maman_foo_get_abstract_base_property (G_TYPE_CHECK_INSTANCE_CAST (self, MAMAN_TYPE_FOO, MamanFoo)));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_maman_bar_set_property (GObject * object,
                              guint property_id,
                              const GValue * value,
                              GParamSpec * pspec)
{
	MamanBar * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, MAMAN_TYPE_BAR, MamanBar);
	switch (property_id) {
		case MAMAN_BAR_PUBLIC_PROPERTY_PROPERTY:
		maman_bar_set_public_property (self, g_value_get_int (value));
		break;
		case MAMAN_BAR_ABSTRACT_BASE_PROPERTY_PROPERTY:
		maman_foo_set_abstract_base_property (G_TYPE_CHECK_INSTANCE_CAST (self, MAMAN_TYPE_FOO, MamanFoo), g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

void
maman_ibaz_simple_method (MamanIbaz* self)
{
	gint n = 0;
	gint _tmp0_;
	gint _tmp1_;
	FILE* _tmp2_;
	_tmp0_ = maman_ibaz_get_number (self);
	_tmp1_ = _tmp0_;
	n = _tmp1_;
	_tmp2_ = stdout;
	fprintf (_tmp2_, " %d", n);
}

gint
maman_ibaz_get_number (MamanIbaz* self)
{
	MamanIbazIface* _iface_;
	g_return_val_if_fail (MAMAN_IS_IBAZ (self), 0);
	_iface_ = MAMAN_IBAZ_GET_INTERFACE (self);
	if (_iface_->get_number) {
		return _iface_->get_number (self);
	}
	return -1;
}

static void
maman_ibaz_default_init (MamanIbazIface * iface,
                         gpointer iface_data)
{
	g_object_interface_install_property (iface, g_param_spec_int ("number", "number", "number", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}

static GType
maman_ibaz_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (MamanIbazIface), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) maman_ibaz_default_init, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
	GType maman_ibaz_type_id;
	maman_ibaz_type_id = g_type_register_static (G_TYPE_INTERFACE, "MamanIbaz", &g_define_type_info, 0);
	g_type_interface_add_prerequisite (maman_ibaz_type_id, G_TYPE_OBJECT);
	return maman_ibaz_type_id;
}

GType
maman_ibaz_get_type (void)
{
	static volatile gsize maman_ibaz_type_id__once = 0;
	if (g_once_init_enter (&maman_ibaz_type_id__once)) {
		GType maman_ibaz_type_id;
		maman_ibaz_type_id = maman_ibaz_get_type_once ();
		g_once_init_leave (&maman_ibaz_type_id__once, maman_ibaz_type_id);
	}
	return maman_ibaz_type_id__once;
}

MamanBaz*
maman_baz_construct (GType object_type)
{
	MamanBaz * self = NULL;
	self = (MamanBaz*) g_object_new (object_type, NULL);
	return self;
}

MamanBaz*
maman_baz_new (void)
{
	return maman_baz_construct (MAMAN_TYPE_BAZ);
}

static gint
maman_baz_real_get_number (MamanIbaz* base)
{
	gint result;
	MamanBaz* self;
	self = G_TYPE_CHECK_INSTANCE_CAST (base, MAMAN_TYPE_BAZ, MamanBaz);
	result = 2;
	return result;
}

static void
maman_baz_class_init (MamanBazClass * klass,
                      gpointer klass_data)
{
	maman_baz_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->get_property = _vala_maman_baz_get_property;
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAMAN_BAZ_NUMBER_PROPERTY, maman_baz_properties[MAMAN_BAZ_NUMBER_PROPERTY] = g_param_spec_int ("number", "number", "number", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}

static void
maman_baz_maman_ibaz_interface_init (MamanIbazIface * iface,
                                     gpointer iface_data)
{
	maman_baz_maman_ibaz_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_number = maman_baz_real_get_number;
}

static void
maman_baz_instance_init (MamanBaz * self,
                         gpointer klass)
{
}

static GType
maman_baz_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (MamanBazClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) maman_baz_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MamanBaz), 0, (GInstanceInitFunc) maman_baz_instance_init, NULL };
	static const GInterfaceInfo maman_ibaz_info = { (GInterfaceInitFunc) maman_baz_maman_ibaz_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType maman_baz_type_id;
	maman_baz_type_id = g_type_register_static (G_TYPE_OBJECT, "MamanBaz", &g_define_type_info, 0);
	g_type_add_interface_static (maman_baz_type_id, MAMAN_TYPE_IBAZ, &maman_ibaz_info);
	return maman_baz_type_id;
}

GType
maman_baz_get_type (void)
{
	static volatile gsize maman_baz_type_id__once = 0;
	if (g_once_init_enter (&maman_baz_type_id__once)) {
		GType maman_baz_type_id;
		maman_baz_type_id = maman_baz_get_type_once ();
		g_once_init_leave (&maman_baz_type_id__once, maman_baz_type_id);
	}
	return maman_baz_type_id__once;
}

static void
_vala_maman_baz_get_property (GObject * object,
                              guint property_id,
                              GValue * value,
                              GParamSpec * pspec)
{
	MamanBaz * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, MAMAN_TYPE_BAZ, MamanBaz);
	switch (property_id) {
		case MAMAN_BAZ_NUMBER_PROPERTY:
		g_value_set_int (value, maman_ibaz_get_number (G_TYPE_CHECK_INSTANCE_CAST (self, MAMAN_TYPE_IBAZ, MamanIbaz)));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

gint
maman_ibiz_get_number (MamanIBiz* self)
{
	MamanIBizIface* _iface_;
	g_return_val_if_fail (MAMAN_IS_IBIZ (self), 0);
	_iface_ = MAMAN_IBIZ_GET_INTERFACE (self);
	if (_iface_->get_number) {
		return _iface_->get_number (self);
	}
	return -1;
}

void
maman_ibiz_set_number (MamanIBiz* self,
                       gint value)
{
	MamanIBizIface* _iface_;
	g_return_if_fail (MAMAN_IS_IBIZ (self));
	_iface_ = MAMAN_IBIZ_GET_INTERFACE (self);
	if (_iface_->set_number) {
		_iface_->set_number (self, value);
	}
}

static void
maman_ibiz_default_init (MamanIBizIface * iface,
                         gpointer iface_data)
{
	g_object_interface_install_property (iface, g_param_spec_int ("number", "number", "number", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}

static GType
maman_ibiz_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (MamanIBizIface), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) maman_ibiz_default_init, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
	GType maman_ibiz_type_id;
	maman_ibiz_type_id = g_type_register_static (G_TYPE_INTERFACE, "MamanIBiz", &g_define_type_info, 0);
	g_type_interface_add_prerequisite (maman_ibiz_type_id, G_TYPE_OBJECT);
	return maman_ibiz_type_id;
}

GType
maman_ibiz_get_type (void)
{
	static volatile gsize maman_ibiz_type_id__once = 0;
	if (g_once_init_enter (&maman_ibiz_type_id__once)) {
		GType maman_ibiz_type_id;
		maman_ibiz_type_id = maman_ibiz_get_type_once ();
		g_once_init_leave (&maman_ibiz_type_id__once, maman_ibiz_type_id);
	}
	return maman_ibiz_type_id__once;
}

static inline gpointer
maman_abiz_get_instance_private (MamanABiz* self)
{
	return G_STRUCT_MEMBER_P (self, MamanABiz_private_offset);
}

MamanABiz*
maman_abiz_construct (GType object_type)
{
	MamanABiz * self = NULL;
	self = (MamanABiz*) g_object_new (object_type, NULL);
	return self;
}

static gint
maman_abiz_real_get_number (MamanIBiz* base)
{
	gint result;
	MamanABiz* self;
	self = G_TYPE_CHECK_INSTANCE_CAST (base, MAMAN_TYPE_ABIZ, MamanABiz);
	result = self->priv->_number;
	return result;
}

static void
maman_abiz_real_set_number (MamanIBiz* base,
                            gint value)
{
	MamanABiz* self;
	gint old_value;
	self = G_TYPE_CHECK_INSTANCE_CAST (base, MAMAN_TYPE_ABIZ, MamanABiz);
	old_value = maman_abiz_real_get_number (base);
	if (old_value != value) {
		self->priv->_number = value;
		g_object_notify_by_pspec ((GObject *) self, maman_abiz_properties[MAMAN_ABIZ_NUMBER_PROPERTY]);
	}
}

gint
maman_abiz_get_number2 (MamanABiz* self)
{
	MamanABizClass* _klass_;
	g_return_val_if_fail (MAMAN_IS_ABIZ (self), 0);
	_klass_ = MAMAN_ABIZ_GET_CLASS (self);
	if (_klass_->get_number2) {
		return _klass_->get_number2 (self);
	}
	return -1;
}

void
maman_abiz_set_number2 (MamanABiz* self,
                        gint value)
{
	MamanABizClass* _klass_;
	g_return_if_fail (MAMAN_IS_ABIZ (self));
	_klass_ = MAMAN_ABIZ_GET_CLASS (self);
	if (_klass_->set_number2) {
		_klass_->set_number2 (self, value);
	}
}

static void
maman_abiz_class_init (MamanABizClass * klass,
                       gpointer klass_data)
{
	maman_abiz_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &MamanABiz_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_maman_abiz_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_maman_abiz_set_property;
	G_OBJECT_CLASS (klass)->finalize = maman_abiz_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAMAN_ABIZ_NUMBER_PROPERTY, maman_abiz_properties[MAMAN_ABIZ_NUMBER_PROPERTY] = g_param_spec_int ("number", "number", "number", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAMAN_ABIZ_NUMBER2_PROPERTY, maman_abiz_properties[MAMAN_ABIZ_NUMBER2_PROPERTY] = g_param_spec_int ("number2", "number2", "number2", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}

static void
maman_abiz_maman_ibiz_interface_init (MamanIBizIface * iface,
                                      gpointer iface_data)
{
	maman_abiz_maman_ibiz_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_number = maman_abiz_real_get_number;
	iface->set_number = maman_abiz_real_set_number;
}

static void
maman_abiz_instance_init (MamanABiz * self,
                          gpointer klass)
{
	self->priv = maman_abiz_get_instance_private (self);
}

static void
maman_abiz_finalize (GObject * obj)
{
	MamanABiz * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, MAMAN_TYPE_ABIZ, MamanABiz);
	G_OBJECT_CLASS (maman_abiz_parent_class)->finalize (obj);
}

static GType
maman_abiz_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (MamanABizClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) maman_abiz_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MamanABiz), 0, (GInstanceInitFunc) maman_abiz_instance_init, NULL };
	static const GInterfaceInfo maman_ibiz_info = { (GInterfaceInitFunc) maman_abiz_maman_ibiz_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType maman_abiz_type_id;
	maman_abiz_type_id = g_type_register_static (G_TYPE_OBJECT, "MamanABiz", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
	g_type_add_interface_static (maman_abiz_type_id, MAMAN_TYPE_IBIZ, &maman_ibiz_info);
	MamanABiz_private_offset = g_type_add_instance_private (maman_abiz_type_id, sizeof (MamanABizPrivate));
	return maman_abiz_type_id;
}

GType
maman_abiz_get_type (void)
{
	static volatile gsize maman_abiz_type_id__once = 0;
	if (g_once_init_enter (&maman_abiz_type_id__once)) {
		GType maman_abiz_type_id;
		maman_abiz_type_id = maman_abiz_get_type_once ();
		g_once_init_leave (&maman_abiz_type_id__once, maman_abiz_type_id);
	}
	return maman_abiz_type_id__once;
}

static void
_vala_maman_abiz_get_property (GObject * object,
                               guint property_id,
                               GValue * value,
                               GParamSpec * pspec)
{
	MamanABiz * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, MAMAN_TYPE_ABIZ, MamanABiz);
	switch (property_id) {
		case MAMAN_ABIZ_NUMBER_PROPERTY:
		g_value_set_int (value, maman_ibiz_get_number (G_TYPE_CHECK_INSTANCE_CAST (self, MAMAN_TYPE_IBIZ, MamanIBiz)));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_maman_abiz_set_property (GObject * object,
                               guint property_id,
                               const GValue * value,
                               GParamSpec * pspec)
{
	MamanABiz * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, MAMAN_TYPE_ABIZ, MamanABiz);
	switch (property_id) {
		case MAMAN_ABIZ_NUMBER_PROPERTY:
		maman_ibiz_set_number (G_TYPE_CHECK_INSTANCE_CAST (self, MAMAN_TYPE_IBIZ, MamanIBiz), g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
maman_biz_get_instance_private (MamanBiz* self)
{
	return G_STRUCT_MEMBER_P (self, MamanBiz_private_offset);
}

MamanBiz*
maman_biz_construct (GType object_type)
{
	MamanBiz * self = NULL;
	self = (MamanBiz*) maman_abiz_construct (object_type);
	return self;
}

MamanBiz*
maman_biz_new (void)
{
	return maman_biz_construct (MAMAN_TYPE_BIZ);
}

static gint
maman_biz_real_get_number2 (MamanABiz* base)
{
	gint result;
	MamanBiz* self;
	self = G_TYPE_CHECK_INSTANCE_CAST (base, MAMAN_TYPE_BIZ, MamanBiz);
	result = self->priv->_number2;
	return result;
}

static void
maman_biz_real_set_number2 (MamanABiz* base,
                            gint value)
{
	MamanBiz* self;
	gint old_value;
	self = G_TYPE_CHECK_INSTANCE_CAST (base, MAMAN_TYPE_BIZ, MamanBiz);
	old_value = maman_biz_real_get_number2 (base);
	if (old_value != value) {
		self->priv->_number2 = value;
		g_object_notify_by_pspec ((GObject *) self, maman_biz_properties[MAMAN_BIZ_NUMBER2_PROPERTY]);
	}
}

static void
maman_biz_class_init (MamanBizClass * klass,
                      gpointer klass_data)
{
	maman_biz_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &MamanBiz_private_offset);
	MAMAN_ABIZ_CLASS (klass)->get_number2 = (gint (*) (MamanABiz*)) maman_biz_real_get_number2;
	MAMAN_ABIZ_CLASS (klass)->set_number2 = (void (*) (MamanABiz*, gint)) maman_biz_real_set_number2;
	G_OBJECT_CLASS (klass)->get_property = _vala_maman_biz_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_maman_biz_set_property;
	G_OBJECT_CLASS (klass)->finalize = maman_biz_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAMAN_BIZ_NUMBER2_PROPERTY, maman_biz_properties[MAMAN_BIZ_NUMBER2_PROPERTY] = g_param_spec_int ("number2", "number2", "number2", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}

static void
maman_biz_instance_init (MamanBiz * self,
                         gpointer klass)
{
	self->priv = maman_biz_get_instance_private (self);
}

static void
maman_biz_finalize (GObject * obj)
{
	MamanBiz * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, MAMAN_TYPE_BIZ, MamanBiz);
	G_OBJECT_CLASS (maman_biz_parent_class)->finalize (obj);
}

static GType
maman_biz_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (MamanBizClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) maman_biz_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MamanBiz), 0, (GInstanceInitFunc) maman_biz_instance_init, NULL };
	GType maman_biz_type_id;
	maman_biz_type_id = g_type_register_static (MAMAN_TYPE_ABIZ, "MamanBiz", &g_define_type_info, 0);
	MamanBiz_private_offset = g_type_add_instance_private (maman_biz_type_id, sizeof (MamanBizPrivate));
	return maman_biz_type_id;
}

GType
maman_biz_get_type (void)
{
	static volatile gsize maman_biz_type_id__once = 0;
	if (g_once_init_enter (&maman_biz_type_id__once)) {
		GType maman_biz_type_id;
		maman_biz_type_id = maman_biz_get_type_once ();
		g_once_init_leave (&maman_biz_type_id__once, maman_biz_type_id);
	}
	return maman_biz_type_id__once;
}

static void
_vala_maman_biz_get_property (GObject * object,
                              guint property_id,
                              GValue * value,
                              GParamSpec * pspec)
{
	MamanBiz * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, MAMAN_TYPE_BIZ, MamanBiz);
	switch (property_id) {
		case MAMAN_BIZ_NUMBER2_PROPERTY:
		g_value_set_int (value, maman_abiz_get_number2 (G_TYPE_CHECK_INSTANCE_CAST (self, MAMAN_TYPE_ABIZ, MamanABiz)));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_maman_biz_set_property (GObject * object,
                              guint property_id,
                              const GValue * value,
                              GParamSpec * pspec)
{
	MamanBiz * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, MAMAN_TYPE_BIZ, MamanBiz);
	switch (property_id) {
		case MAMAN_BIZ_NUMBER2_PROPERTY:
		maman_abiz_set_number2 (G_TYPE_CHECK_INSTANCE_CAST (self, MAMAN_TYPE_ABIZ, MamanABiz), g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

