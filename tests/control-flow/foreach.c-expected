/* control_flow_foreach.c generated by valac, the Vala compiler
 * generated from control_flow_foreach.vala, do not modify */

#include <glib-object.h>
#include <glib.h>
#include <stdlib.h>
#include <string.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define _g_value_array_free0(var) ((var == NULL) ? NULL : (var = (g_value_array_free (var), NULL)))
#define __vala_GValue_free0(var) ((var == NULL) ? NULL : (var = (_vala_GValue_free (var), NULL)))
#define _g_ptr_array_unref0(var) ((var == NULL) ? NULL : (var = (g_ptr_array_unref (var), NULL)))
#define _g_sequence_free0(var) ((var == NULL) ? NULL : (var = (g_sequence_free (var), NULL)))
#define _g_array_unref0(var) ((var == NULL) ? NULL : (var = (g_array_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

VALA_EXTERN void test_owned (GValueArray* array);
VALA_EXTERN void test_unowned (GValueArray* array);
VALA_EXTERN void test_foreach_gvaluearray (void);
VALA_EXTERN void test_generic_array_owned (GPtrArray* array);
static GValue* _g_value_dup (GValue* self);
static void _vala_GValue_free (GValue* self);
VALA_EXTERN void test_generic_array_unowned (GPtrArray* array);
VALA_EXTERN void test_foreach_genericarray (void);
static void __vala_GValue_free0_ (gpointer var);
VALA_EXTERN void test_gsequence_owned (GSequence* sequence);
VALA_EXTERN void test_gsequence_unowned (GSequence* sequence);
VALA_EXTERN void test_foreach_gsequence (void);
VALA_EXTERN void test_garray_owned (GArray* array);
VALA_EXTERN void test_garray_unowned (GArray* array);
VALA_EXTERN void test_foreach_garray (void);
static void _vala_GValue_free_function_content_of (gpointer data);
VALA_EXTERN void test_foreach_multidim_array (void);
VALA_EXTERN void test_foreach_const_array (void);
VALA_EXTERN void test_foreach_slice_array (void);
VALA_EXTERN void test_foreach_string (void);
static void _vala_main (void);

const gint FOO[6] = {1, 2, 3, 4, 5, 6};
const gint BAR[6] = {6, 5, 4, 3, 2, 1};

void
test_owned (GValueArray* array)
{
	guint i = 0U;
	g_return_if_fail (array != NULL);
	i = (guint) 0;
	{
		GValueArray* item_collection = NULL;
		guint item_index = 0U;
		item_collection = array;
		for (item_index = 0; item_index < item_collection->n_values; item_index = item_index + 1) {
			GValue _tmp0_;
			GValue _tmp1_ = {0};
			GValue item = {0};
			_tmp0_ = *g_value_array_get_nth (item_collection, item_index);
			if (G_IS_VALUE (&_tmp0_)) {
				g_value_init (&_tmp1_, G_VALUE_TYPE (&_tmp0_));
				g_value_copy (&_tmp0_, &_tmp1_);
			} else {
				_tmp1_ = _tmp0_;
			}
			item = _tmp1_;
			{
				guint _tmp2_;
				_tmp2_ = i;
				i = _tmp2_ + 1;
				G_IS_VALUE (&item) ? (g_value_unset (&item), NULL) : NULL;
			}
		}
	}
	_vala_assert (i == ((guint) 3), "i == 3");
}

void
test_unowned (GValueArray* array)
{
	guint i = 0U;
	g_return_if_fail (array != NULL);
	i = (guint) 0;
	{
		GValueArray* item_collection = NULL;
		guint item_index = 0U;
		item_collection = array;
		for (item_index = 0; item_index < item_collection->n_values; item_index = item_index + 1) {
			GValue item = {0};
			item = *g_value_array_get_nth (item_collection, item_index);
			{
				guint _tmp0_;
				_tmp0_ = i;
				i = _tmp0_ + 1;
			}
		}
	}
	_vala_assert (i == ((guint) 3), "i == 3");
}

void
test_foreach_gvaluearray (void)
{
	GValue value = {0};
	GValueArray* array = NULL;
	GValueArray* _tmp0_;
	GValue _tmp1_ = {0};
	GValue _tmp2_;
	GValue _tmp3_ = {0};
	GValue _tmp4_;
	GValue _tmp5_ = {0};
	GValue _tmp6_;
	_tmp0_ = g_value_array_new ((guint) 3);
	array = _tmp0_;
	g_value_init (&_tmp1_, G_TYPE_INT);
	g_value_set_int (&_tmp1_, 1);
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
	value = _tmp1_;
	_tmp2_ = value;
	g_value_array_append (array, &_tmp2_);
	g_value_init (&_tmp3_, G_TYPE_DOUBLE);
	g_value_set_double (&_tmp3_, 2.0);
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
	value = _tmp3_;
	_tmp4_ = value;
	g_value_array_append (array, &_tmp4_);
	g_value_init (&_tmp5_, G_TYPE_STRING);
	g_value_set_string (&_tmp5_, "three");
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
	value = _tmp5_;
	_tmp6_ = value;
	g_value_array_append (array, &_tmp6_);
	test_owned (array);
	test_unowned (array);
	_g_value_array_free0 (array);
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
}

static GValue*
_g_value_dup (GValue* self)
{
	return g_boxed_copy (G_TYPE_VALUE, self);
}

static gpointer
__g_value_dup0 (gpointer self)
{
	return self ? _g_value_dup (self) : NULL;
}

static void
_vala_GValue_free (GValue* self)
{
	g_boxed_free (G_TYPE_VALUE, self);
}

void
test_generic_array_owned (GPtrArray* array)
{
	guint i = 0U;
	g_return_if_fail (array != NULL);
	i = (guint) 0;
	{
		GPtrArray* item_collection = NULL;
		guint item_index = 0U;
		item_collection = array;
		for (item_index = 0; item_index < item_collection->len; item_index = item_index + 1) {
			GValue* _tmp0_;
			GValue* item = NULL;
			_tmp0_ = __g_value_dup0 ((GValue*) g_ptr_array_index (item_collection, item_index));
			item = _tmp0_;
			{
				guint _tmp1_;
				_tmp1_ = i;
				i = _tmp1_ + 1;
				__vala_GValue_free0 (item);
			}
		}
	}
	_vala_assert (i == ((guint) 3), "i == 3");
}

void
test_generic_array_unowned (GPtrArray* array)
{
	guint i = 0U;
	g_return_if_fail (array != NULL);
	i = (guint) 0;
	{
		GPtrArray* item_collection = NULL;
		guint item_index = 0U;
		item_collection = array;
		for (item_index = 0; item_index < item_collection->len; item_index = item_index + 1) {
			GValue* item = NULL;
			item = (GValue*) g_ptr_array_index (item_collection, item_index);
			{
				guint _tmp0_;
				_tmp0_ = i;
				i = _tmp0_ + 1;
			}
		}
	}
	_vala_assert (i == ((guint) 3), "i == 3");
}

static void
__vala_GValue_free0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (_vala_GValue_free (var), NULL));
}

void
test_foreach_genericarray (void)
{
	GValue value = {0};
	GPtrArray* array = NULL;
	GPtrArray* _tmp0_;
	GValue _tmp1_ = {0};
	GValue _tmp2_;
	GValue _tmp3_;
	GValue* _tmp4_;
	GValue _tmp5_ = {0};
	GValue _tmp6_;
	GValue _tmp7_;
	GValue* _tmp8_;
	GValue _tmp9_ = {0};
	GValue _tmp10_;
	GValue _tmp11_;
	GValue* _tmp12_;
	_tmp0_ = g_ptr_array_new_full ((guint) 0, __vala_GValue_free0_);
	array = _tmp0_;
	g_value_init (&_tmp1_, G_TYPE_INT);
	g_value_set_int (&_tmp1_, 1);
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
	value = _tmp1_;
	_tmp2_ = value;
	_tmp3_ = _tmp2_;
	_tmp4_ = __g_value_dup0 (&_tmp3_);
	g_ptr_array_add (array, _tmp4_);
	g_value_init (&_tmp5_, G_TYPE_DOUBLE);
	g_value_set_double (&_tmp5_, 2.0);
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
	value = _tmp5_;
	_tmp6_ = value;
	_tmp7_ = _tmp6_;
	_tmp8_ = __g_value_dup0 (&_tmp7_);
	g_ptr_array_add (array, _tmp8_);
	g_value_init (&_tmp9_, G_TYPE_STRING);
	g_value_set_string (&_tmp9_, "three");
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
	value = _tmp9_;
	_tmp10_ = value;
	_tmp11_ = _tmp10_;
	_tmp12_ = __g_value_dup0 (&_tmp11_);
	g_ptr_array_add (array, _tmp12_);
	test_generic_array_owned (array);
	test_generic_array_unowned (array);
	_g_ptr_array_unref0 (array);
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
}

void
test_gsequence_owned (GSequence* sequence)
{
	guint i = 0U;
	g_return_if_fail (sequence != NULL);
	i = (guint) 0;
	{
		GSequence* item_collection = NULL;
		GSequenceIter* item_iter = NULL;
		item_collection = sequence;
		for (item_iter = g_sequence_get_begin_iter (item_collection); !g_sequence_iter_is_end (item_iter); item_iter = g_sequence_iter_next (item_iter)) {
			GValue* _tmp0_;
			GValue* item = NULL;
			_tmp0_ = __g_value_dup0 ((GValue*) g_sequence_get (item_iter));
			item = _tmp0_;
			{
				guint _tmp1_;
				_tmp1_ = i;
				i = _tmp1_ + 1;
				__vala_GValue_free0 (item);
			}
		}
	}
	_vala_assert (i == ((guint) 3), "i == 3");
}

void
test_gsequence_unowned (GSequence* sequence)
{
	guint i = 0U;
	g_return_if_fail (sequence != NULL);
	i = (guint) 0;
	{
		GSequence* item_collection = NULL;
		GSequenceIter* item_iter = NULL;
		item_collection = sequence;
		for (item_iter = g_sequence_get_begin_iter (item_collection); !g_sequence_iter_is_end (item_iter); item_iter = g_sequence_iter_next (item_iter)) {
			GValue* item = NULL;
			item = (GValue*) g_sequence_get (item_iter);
			{
				guint _tmp0_;
				_tmp0_ = i;
				i = _tmp0_ + 1;
			}
		}
	}
	_vala_assert (i == ((guint) 3), "i == 3");
}

void
test_foreach_gsequence (void)
{
	GValue value = {0};
	GSequence* sequence = NULL;
	GSequence* _tmp0_;
	GValue _tmp1_ = {0};
	GValue _tmp2_;
	GValue _tmp3_;
	GValue* _tmp4_;
	GSequenceIter* _tmp5_;
	GValue _tmp6_ = {0};
	GValue _tmp7_;
	GValue _tmp8_;
	GValue* _tmp9_;
	GSequenceIter* _tmp10_;
	GValue _tmp11_ = {0};
	GValue _tmp12_;
	GValue _tmp13_;
	GValue* _tmp14_;
	GSequenceIter* _tmp15_;
	_tmp0_ = g_sequence_new (__vala_GValue_free0_);
	sequence = _tmp0_;
	g_value_init (&_tmp1_, G_TYPE_INT);
	g_value_set_int (&_tmp1_, 1);
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
	value = _tmp1_;
	_tmp2_ = value;
	_tmp3_ = _tmp2_;
	_tmp4_ = __g_value_dup0 (&_tmp3_);
	_tmp5_ = g_sequence_append (sequence, _tmp4_);
	g_value_init (&_tmp6_, G_TYPE_DOUBLE);
	g_value_set_double (&_tmp6_, 2.0);
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
	value = _tmp6_;
	_tmp7_ = value;
	_tmp8_ = _tmp7_;
	_tmp9_ = __g_value_dup0 (&_tmp8_);
	_tmp10_ = g_sequence_append (sequence, _tmp9_);
	g_value_init (&_tmp11_, G_TYPE_STRING);
	g_value_set_string (&_tmp11_, "three");
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
	value = _tmp11_;
	_tmp12_ = value;
	_tmp13_ = _tmp12_;
	_tmp14_ = __g_value_dup0 (&_tmp13_);
	_tmp15_ = g_sequence_append (sequence, _tmp14_);
	test_gsequence_owned (sequence);
	test_gsequence_unowned (sequence);
	_g_sequence_free0 (sequence);
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
}

void
test_garray_owned (GArray* array)
{
	guint i = 0U;
	g_return_if_fail (array != NULL);
	i = (guint) 0;
	{
		GArray* item_collection = NULL;
		guint item_index = 0U;
		item_collection = array;
		for (item_index = 0; item_index < item_collection->len; item_index = item_index + 1) {
			GValue* _tmp0_;
			GValue* item = NULL;
			_tmp0_ = __g_value_dup0 (g_array_index (item_collection, GValue*, item_index));
			item = _tmp0_;
			{
				guint _tmp1_;
				_tmp1_ = i;
				i = _tmp1_ + 1;
				__vala_GValue_free0 (item);
			}
		}
	}
	_vala_assert (i == ((guint) 3), "i == 3");
}

void
test_garray_unowned (GArray* array)
{
	guint i = 0U;
	g_return_if_fail (array != NULL);
	i = (guint) 0;
	{
		GArray* item_collection = NULL;
		guint item_index = 0U;
		item_collection = array;
		for (item_index = 0; item_index < item_collection->len; item_index = item_index + 1) {
			GValue* item = NULL;
			item = g_array_index (item_collection, GValue*, item_index);
			{
				guint _tmp0_;
				_tmp0_ = i;
				i = _tmp0_ + 1;
			}
		}
	}
	_vala_assert (i == ((guint) 3), "i == 3");
}

static void
_vala_GValue_free_function_content_of (gpointer data)
{
	GValue* self;
	self = *((GValue**) data);
	__vala_GValue_free0_ (self);
}

void
test_foreach_garray (void)
{
	GValue value = {0};
	GArray* array = NULL;
	GArray* _tmp0_;
	GValue _tmp1_ = {0};
	GValue _tmp2_;
	GValue _tmp3_;
	GValue* _tmp4_;
	GValue _tmp5_ = {0};
	GValue _tmp6_;
	GValue _tmp7_;
	GValue* _tmp8_;
	GValue _tmp9_ = {0};
	GValue _tmp10_;
	GValue _tmp11_;
	GValue* _tmp12_;
	_tmp0_ = g_array_new (TRUE, TRUE, sizeof (GValue*));
	g_array_set_clear_func (_tmp0_, (GDestroyNotify) _vala_GValue_free_function_content_of);
	array = _tmp0_;
	g_value_init (&_tmp1_, G_TYPE_INT);
	g_value_set_int (&_tmp1_, 1);
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
	value = _tmp1_;
	_tmp2_ = value;
	_tmp3_ = _tmp2_;
	_tmp4_ = __g_value_dup0 (&_tmp3_);
	g_array_append_val (array, _tmp4_);
	g_value_init (&_tmp5_, G_TYPE_DOUBLE);
	g_value_set_double (&_tmp5_, 2.0);
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
	value = _tmp5_;
	_tmp6_ = value;
	_tmp7_ = _tmp6_;
	_tmp8_ = __g_value_dup0 (&_tmp7_);
	g_array_append_val (array, _tmp8_);
	g_value_init (&_tmp9_, G_TYPE_STRING);
	g_value_set_string (&_tmp9_, "three");
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
	value = _tmp9_;
	_tmp10_ = value;
	_tmp11_ = _tmp10_;
	_tmp12_ = __g_value_dup0 (&_tmp11_);
	g_array_append_val (array, _tmp12_);
	test_garray_owned (array);
	test_garray_unowned (array);
	_g_array_unref0 (array);
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
}

void
test_foreach_multidim_array (void)
{
	gint* foo = NULL;
	gint* _tmp0_;
	gint foo_length1;
	gint foo_length2;
	gchar* _result_ = NULL;
	gchar* _tmp1_;
	gint* _tmp2_;
	gint _tmp2__length1;
	gint _tmp2__length2;
	const gchar* _tmp7_;
	_tmp0_ = g_new0 (gint, 3 * 2);
	_tmp0_[0] = 1;
	_tmp0_[1] = 2;
	_tmp0_[2] = 3;
	_tmp0_[3] = 4;
	_tmp0_[4] = 5;
	_tmp0_[5] = 6;
	foo = _tmp0_;
	foo_length1 = 3;
	foo_length2 = 2;
	_tmp1_ = g_strdup ("");
	_result_ = _tmp1_;
	_tmp2_ = foo;
	_tmp2__length1 = foo_length1;
	_tmp2__length2 = foo_length2;
	{
		gint* i_collection = NULL;
		gint i_collection_length1 = 0;
		gint i_collection_length2 = 0;
		gint i_it = 0;
		i_collection = _tmp2_;
		i_collection_length1 = _tmp2__length1 * _tmp2__length2;
		for (i_it = 0; i_it < i_collection_length1; i_it = i_it + 1) {
			gint i = 0;
			i = i_collection[i_it];
			{
				const gchar* _tmp3_;
				gchar* _tmp4_;
				gchar* _tmp5_;
				gchar* _tmp6_;
				_tmp3_ = _result_;
				_tmp4_ = g_strdup_printf ("%i", i);
				_tmp5_ = _tmp4_;
				_tmp6_ = g_strconcat (_tmp3_, _tmp5_, NULL);
				_g_free0 (_result_);
				_result_ = _tmp6_;
				_g_free0 (_tmp5_);
			}
		}
	}
	_tmp7_ = _result_;
	_vala_assert (g_strcmp0 (_tmp7_, "123456") == 0, "result == \"123456\"");
	_g_free0 (_result_);
	foo = (g_free (foo), NULL);
}

void
test_foreach_const_array (void)
{
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	const gchar* _tmp5_;
	gchar* result2 = NULL;
	gchar* _tmp6_;
	const gchar* _tmp11_;
	_tmp0_ = g_strdup ("");
	_result_ = _tmp0_;
	{
		gint* i_collection = NULL;
		gint i_collection_length1 = 0;
		gint _i_collection_size_ = 0;
		gint i_it = 0;
		i_collection = FOO;
		i_collection_length1 = G_N_ELEMENTS (FOO);
		for (i_it = 0; i_it < i_collection_length1; i_it = i_it + 1) {
			gint i = 0;
			i = i_collection[i_it];
			{
				const gchar* _tmp1_;
				gchar* _tmp2_;
				gchar* _tmp3_;
				gchar* _tmp4_;
				_tmp1_ = _result_;
				_tmp2_ = g_strdup_printf ("%i", i);
				_tmp3_ = _tmp2_;
				_tmp4_ = g_strconcat (_tmp1_, _tmp3_, NULL);
				_g_free0 (_result_);
				_result_ = _tmp4_;
				_g_free0 (_tmp3_);
			}
		}
	}
	_tmp5_ = _result_;
	_vala_assert (g_strcmp0 (_tmp5_, "123456") == 0, "result == \"123456\"");
	_tmp6_ = g_strdup ("");
	result2 = _tmp6_;
	{
		gint* i_collection = NULL;
		gint i_collection_length1 = 0;
		gint _i_collection_size_ = 0;
		gint i_it = 0;
		i_collection = BAR;
		i_collection_length1 = G_N_ELEMENTS (BAR);
		for (i_it = 0; i_it < i_collection_length1; i_it = i_it + 1) {
			gint i = 0;
			i = i_collection[i_it];
			{
				const gchar* _tmp7_;
				gchar* _tmp8_;
				gchar* _tmp9_;
				gchar* _tmp10_;
				_tmp7_ = result2;
				_tmp8_ = g_strdup_printf ("%i", i);
				_tmp9_ = _tmp8_;
				_tmp10_ = g_strconcat (_tmp7_, _tmp9_, NULL);
				_g_free0 (result2);
				result2 = _tmp10_;
				_g_free0 (_tmp9_);
			}
		}
	}
	_tmp11_ = result2;
	_vala_assert (g_strcmp0 (_tmp11_, "654321") == 0, "result2 == \"654321\"");
	_g_free0 (result2);
	_g_free0 (_result_);
}

void
test_foreach_slice_array (void)
{
	gint* foo = NULL;
	gint* _tmp0_;
	gint foo_length1;
	gint _foo_size_;
	gchar* _result_ = NULL;
	gchar* _tmp1_;
	gint* _tmp2_;
	gint _tmp2__length1;
	gint* _tmp3_;
	gint _tmp3__length1;
	const gchar* _tmp8_;
	_tmp0_ = g_new0 (gint, 6);
	_tmp0_[0] = 1;
	_tmp0_[1] = 2;
	_tmp0_[2] = 3;
	_tmp0_[3] = 4;
	_tmp0_[4] = 5;
	_tmp0_[5] = 6;
	foo = _tmp0_;
	foo_length1 = 6;
	_foo_size_ = foo_length1;
	_tmp1_ = g_strdup ("");
	_result_ = _tmp1_;
	_tmp2_ = foo;
	_tmp2__length1 = foo_length1;
	_tmp3_ = foo;
	_tmp3__length1 = foo_length1;
	{
		gint* i_collection = NULL;
		gint i_collection_length1 = 0;
		gint _i_collection_size_ = 0;
		gint i_it = 0;
		i_collection = _tmp2_ + 1;
		i_collection_length1 = (_tmp3__length1 - 1) - 1;
		for (i_it = 0; i_it < i_collection_length1; i_it = i_it + 1) {
			gint i = 0;
			i = i_collection[i_it];
			{
				const gchar* _tmp4_;
				gchar* _tmp5_;
				gchar* _tmp6_;
				gchar* _tmp7_;
				_tmp4_ = _result_;
				_tmp5_ = g_strdup_printf ("%i", i);
				_tmp6_ = _tmp5_;
				_tmp7_ = g_strconcat (_tmp4_, _tmp6_, NULL);
				_g_free0 (_result_);
				_result_ = _tmp7_;
				_g_free0 (_tmp6_);
			}
		}
	}
	_tmp8_ = _result_;
	_vala_assert (g_strcmp0 (_tmp8_, "2345") == 0, "result == \"2345\"");
	_g_free0 (_result_);
	foo = (g_free (foo), NULL);
}

void
test_foreach_string (void)
{
	guint i = 0U;
	gchar* s = NULL;
	gchar* _tmp0_;
	const gchar* _tmp1_;
	i = (guint) 0;
	_tmp0_ = g_strdup ("abc àçêö 你好");
	s = _tmp0_;
	_tmp1_ = s;
	{
		const gchar* c_collection = NULL;
		const gchar* c_iter = NULL;
		c_collection = _tmp1_;
		_vala_warn_if_fail (g_utf8_validate (c_collection, -1, NULL), "Invalid UTF-8 string");
		for (c_iter = c_collection; (*c_iter) != '\0'; c_iter = g_utf8_next_char (c_iter)) {
			gunichar c = 0U;
			c = g_utf8_get_char (c_iter);
			{
				guint _tmp2_;
				_tmp2_ = i;
				i = _tmp2_ + 1;
			}
		}
	}
	_vala_assert (i == ((guint) 11), "i == 11");
	_g_free0 (s);
}

static void
_vala_main (void)
{
	test_foreach_gvaluearray ();
	test_foreach_garray ();
	test_foreach_genericarray ();
	test_foreach_gsequence ();
	test_foreach_const_array ();
	test_foreach_multidim_array ();
	test_foreach_slice_array ();
	test_foreach_string ();
}

int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}

